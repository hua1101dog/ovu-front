/*! OvuRouteMap v1.2 | (c) Copyright Airocov inc. | build: September day 2019 Monday */ ! function (t) {
    function e(r) {
        if (i[r]) return i[r].exports;
        var n = i[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return t[r].call(n.exports, n, n.exports, e), n.l = !0, n.exports
    }
    var i = {};
    e.m = t, e.c = i, e.d = function (t, i, r) {
        e.o(t, i) || Object.defineProperty(t, i, {
            configurable: !1,
            enumerable: !0,
            get: r
        })
    }, e.n = function (t) {
        var i = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return e.d(i, "a", i), i
    }, e.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, e.p = "", e(e.s = 95)
}([function (t, e) {
    var i = t.exports = {
        version: "2.5.7"
    };
    "number" == typeof __e && (__e = i)
}, function (t, e, i) {
    var r = i(5),
        n = i(0),
        o = i(16),
        a = i(15),
        s = i(14),
        l = function (t, e, i) {
            var h, c, u, p = t & l.F,
                f = t & l.G,
                d = t & l.S,
                m = t & l.P,
                g = t & l.B,
                v = t & l.W,
                y = f ? n : n[e] || (n[e] = {}),
                A = y.prototype,
                x = f ? r : d ? r[e] : (r[e] || {}).prototype;
            f && (i = e);
            for (h in i)(c = !p && x && void 0 !== x[h]) && s(y, h) || (u = c ? x[h] : i[h], y[h] = f && "function" != typeof x[h] ? i[h] : g && c ? o(u, r) : v && x[h] == u ? function (t) {
                var e = function (e, i, r) {
                    if (this instanceof t) {
                        switch (arguments.length) {
                            case 0:
                                return new t;
                            case 1:
                                return new t(e);
                            case 2:
                                return new t(e, i)
                        }
                        return new t(e, i, r)
                    }
                    return t.apply(this, arguments)
                };
                return e.prototype = t.prototype, e
            }(u) : m && "function" == typeof u ? o(Function.call, u) : u, m && ((y.virtual || (y.virtual = {}))[h] = u, t & l.R && A && !A[h] && a(A, h, u)))
        };
    l.F = 1, l.G = 2, l.S = 4, l.P = 8, l.B = 16, l.W = 32, l.U = 64, l.R = 128, t.exports = l
}, function (t, e, i) {
    "use strict";
    e.__esModule = !0, e.default = function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
}, function (t, e, i) {
    "use strict";
    e.__esModule = !0;
    var r = i(123),
        n = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r);
    e.default = function () {
        function t(t, e) {
            for (var i = 0; i < e.length; i++) {
                var r = e[i];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, n.default)(t, r.key, r)
            }
        }
        return function (e, i, r) {
            return i && t(e.prototype, i), r && t(e, r), e
        }
    }()
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var n, o, a, s = i(137),
        l = r(s),
        h = i(140),
        c = r(h),
        u = i(44),
        p = r(u),
        f = i(9),
        d = r(f),
        m = i(143),
        g = r(m),
        v = i(41),
        y = r(v),
        A = i(82),
        x = r(A),
        _ = i(39),
        w = r(_),
        b = i(153),
        M = r(b),
        T = i(157),
        S = r(T),
        E = i(161),
        C = r(E),
        P = i(83),
        L = r(P);
    ! function (i, r) {
        "object" === (0, L.default)(e) && void 0 !== t ? r(e) : (o = [e], n = r, void 0 !== (a = "function" == typeof n ? n.apply(e, o) : n) && (t.exports = a))
    }(0, function (t) {
        function e() {}

        function i(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function r() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function n(t, e, i, r) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== r ? r : 1
        }

        function o(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function a() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function s(t, e, r, n, o, l, h, c, u, p) {
            Object.defineProperty(this, "id", {
                value: wl++
            }), this.uuid = _l.generateUUID(), this.name = "", this.image = void 0 !== t ? t : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : cs, this.wrapT = void 0 !== n ? n : cs, this.magFilter = void 0 !== o ? o : ms, this.minFilter = void 0 !== l ? l : vs, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== h ? h : Rs, this.type = void 0 !== c ? c : ys, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new a, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== p ? p : pl, this.version = 0, this.onUpdate = null
        }

        function h(t, e, i, r) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== r ? r : 1
        }

        function u(t, e, i) {
            this.width = t, this.height = e, this.scissor = new h(0, 0, t, e), this.scissorTest = !1, this.viewport = new h(0, 0, t, e), i = i || {}, void 0 === i.minFilter && (i.minFilter = ms), this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function f(t, e, i) {
            u.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
        }

        function m(t, e, i, r, n, o, a, l, h, c, u, p) {
            s.call(this, null, o, a, l, h, c, r, n, u, p), this.image = {
                data: t,
                width: e,
                height: i
            }, this.magFilter = void 0 !== h ? h : ps, this.minFilter = void 0 !== c ? c : ps, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }

        function v(t, e) {
            this.min = void 0 !== t ? t : new o(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new o(-1 / 0, -1 / 0, -1 / 0)
        }

        function A(t, e) {
            this.center = void 0 !== t ? t : new o, this.radius = void 0 !== e ? e : 0
        }

        function _(t, e) {
            this.normal = void 0 !== t ? t : new o(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function b(t, e, i, r, n, o) {
            this.planes = [void 0 !== t ? t : new _, void 0 !== e ? e : new _, void 0 !== i ? i : new _, void 0 !== r ? r : new _, void 0 !== n ? n : new _, void 0 !== o ? o : new _]
        }

        function T(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        function E(t) {
            function e(e, i) {
                var r = e.array,
                    n = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                    o = t.createBuffer();
                t.bindBuffer(i, o), t.bufferData(i, r, n), e.onUploadCallback();
                var a = t.FLOAT;
                return r instanceof Float32Array ? a = t.FLOAT : r instanceof Float64Array || (r instanceof Uint16Array ? a = t.UNSIGNED_SHORT : r instanceof Int16Array ? a = t.SHORT : r instanceof Uint32Array ? a = t.UNSIGNED_INT : r instanceof Int32Array ? a = t.INT : r instanceof Int8Array ? a = t.BYTE : r instanceof Uint8Array && (a = t.UNSIGNED_BYTE)), {
                    buffer: o,
                    type: a,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: e.version
                }
            }

            function i(e, i, r) {
                var n = i.array,
                    o = i.updateRange;
                t.bindBuffer(r, e), !1 === i.dynamic ? t.bufferData(r, n, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(r, 0, n) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, o.offset * n.BYTES_PER_ELEMENT, n.subarray(o.offset, o.offset + o.count)), o.count = -1)
            }

            function r(t) {
                return t.isInterleavedBufferAttribute && (t = t.data), a.get(t)
            }

            function n(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var i = a.get(e);
                i && (t.deleteBuffer(i.buffer), a.delete(e))
            }

            function o(t, r) {
                t.isInterleavedBufferAttribute && (t = t.data);
                var n = a.get(t);
                void 0 === n ? a.set(t, e(t, r)) : n.version < t.version && (i(n.buffer, t, r), n.version = t.version)
            }
            var a = new g.default;
            return {
                get: r,
                remove: n,
                update: o
            }
        }

        function P(t, e, i, r) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = r || P.DefaultOrder
        }

        function D() {
            this.mask = 1
        }

        function R() {
            function t() {
                l.setFromEuler(s, !1)
            }

            function e() {
                s.setFromQuaternion(l, void 0, !1)
            }
            Object.defineProperty(this, "id", {
                value: Cl++
            }), this.uuid = _l.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = R.DefaultUp.clone();
            var i = new o,
                s = new P,
                l = new n,
                h = new o(1, 1, 1);
            s.onChange(t), l.onChange(e), (0, x.default)(this, {
                position: {
                    enumerable: !0,
                    value: i
                },
                rotation: {
                    enumerable: !0,
                    value: s
                },
                quaternion: {
                    enumerable: !0,
                    value: l
                },
                scale: {
                    enumerable: !0,
                    value: h
                },
                modelViewMatrix: {
                    value: new r
                },
                normalMatrix: {
                    value: new a
                }
            }), this.matrix = new r, this.matrixWorld = new r, this.matrixAutoUpdate = R.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new D, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function I() {
            R.call(this), this.type = "Camera", this.matrixWorldInverse = new r, this.projectionMatrix = new r
        }

        function O(t, e, i, r, n, o) {
            I.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = r, this.near = void 0 !== n ? n : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
        }

        function B(t, e, i, r, n, a) {
            this.a = t, this.b = e, this.c = i, this.normal = r && r.isVector3 ? r : new o, this.vertexNormals = Array.isArray(r) ? r : [], this.color = n && n.isColor ? n : new T, this.vertexColors = Array.isArray(n) ? n : [], this.materialIndex = void 0 !== a ? a : 0
        }

        function N() {
            Object.defineProperty(this, "id", {
                value: Pl += 2
            }), this.uuid = _l.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function k(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function F(t, e, i) {
            k.call(this, new Int8Array(t), e, i)
        }

        function z(t, e, i) {
            k.call(this, new Uint8Array(t), e, i)
        }

        function U(t, e, i) {
            k.call(this, new Uint8ClampedArray(t), e, i)
        }

        function G(t, e, i) {
            k.call(this, new Int16Array(t), e, i)
        }

        function V(t, e, i) {
            k.call(this, new Uint16Array(t), e, i)
        }

        function H(t, e, i) {
            k.call(this, new Int32Array(t), e, i)
        }

        function j(t, e, i) {
            k.call(this, new Uint32Array(t), e, i)
        }

        function W(t, e, i) {
            k.call(this, new Float32Array(t), e, i)
        }

        function Y(t, e, i) {
            k.call(this, new Float64Array(t), e, i)
        }

        function X() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function Q(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, r = t.length; i < r; ++i) t[i] > e && (e = t[i]);
            return e
        }

        function J() {
            Object.defineProperty(this, "id", {
                value: Ll += 2
            }), this.uuid = _l.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function q(t, e, i, r, n, o) {
            N.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: r,
                heightSegments: n,
                depthSegments: o
            }, this.fromBufferGeometry(new Z(t, e, i, r, n, o)), this.mergeVertices()
        }

        function Z(t, e, i, r, n, a) {
            function s(t, e, i, r, n, a, s, m, g, v, y) {
                var A, x, _ = a / g,
                    w = s / v,
                    b = a / 2,
                    M = s / 2,
                    T = m / 2,
                    S = g + 1,
                    E = v + 1,
                    C = 0,
                    P = 0,
                    L = new o;
                for (x = 0; x < E; x++) {
                    var D = x * w - M;
                    for (A = 0; A < S; A++) {
                        var R = A * _ - b;
                        L[t] = R * r, L[e] = D * n, L[i] = T, c.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[i] = m > 0 ? 1 : -1, u.push(L.x, L.y, L.z), p.push(A / g), p.push(1 - x / v), C += 1
                    }
                }
                for (x = 0; x < v; x++)
                    for (A = 0; A < g; A++) {
                        var I = f + A + S * x,
                            O = f + A + S * (x + 1),
                            B = f + (A + 1) + S * (x + 1),
                            N = f + (A + 1) + S * x;
                        h.push(I, O, N), h.push(O, B, N), P += 6
                    }
                l.addGroup(d, P, y), d += P, f += C
            }
            J.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: r,
                heightSegments: n,
                depthSegments: a
            };
            var l = this;
            t = t || 1, e = e || 1, i = i || 1, r = Math.floor(r) || 1, n = Math.floor(n) || 1, a = Math.floor(a) || 1;
            var h = [],
                c = [],
                u = [],
                p = [],
                f = 0,
                d = 0;
            s("z", "y", "x", -1, -1, i, e, t, a, n, 0), s("z", "y", "x", 1, -1, i, e, -t, a, n, 1), s("x", "z", "y", 1, 1, t, i, e, r, a, 2), s("x", "z", "y", 1, -1, t, i, -e, r, a, 3), s("x", "y", "z", 1, -1, t, e, i, r, n, 4), s("x", "y", "z", -1, -1, t, e, -i, r, n, 5), this.setIndex(h), this.addAttribute("position", new W(c, 3)), this.addAttribute("normal", new W(u, 3)), this.addAttribute("uv", new W(p, 2))
        }

        function K(t, e, i, r) {
            N.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: r
            }, this.fromBufferGeometry(new $(t, e, i, r)), this.mergeVertices()
        }

        function $(t, e, i, r) {
            J.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: r
            }, t = t || 1, e = e || 1;
            var n, o, a = t / 2,
                s = e / 2,
                l = Math.floor(i) || 1,
                h = Math.floor(r) || 1,
                c = l + 1,
                u = h + 1,
                p = t / l,
                f = e / h,
                d = [],
                m = [],
                g = [],
                v = [];
            for (o = 0; o < u; o++) {
                var y = o * f - s;
                for (n = 0; n < c; n++) {
                    var A = n * p - a;
                    m.push(A, -y, 0), g.push(0, 0, 1), v.push(n / l), v.push(1 - o / h)
                }
            }
            for (o = 0; o < h; o++)
                for (n = 0; n < l; n++) {
                    var x = n + c * o,
                        _ = n + c * (o + 1),
                        w = n + 1 + c * (o + 1),
                        b = n + 1 + c * o;
                    d.push(x, _, b), d.push(_, w, b)
                }
            this.setIndex(d), this.addAttribute("position", new W(m, 3)), this.addAttribute("normal", new W(g, 3)), this.addAttribute("uv", new W(v, 2))
        }

        function tt() {
            Object.defineProperty(this, "id", {
                value: Dl++
            }), this.uuid = _l.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Aa, this.side = pa, this.flatShading = !1, this.vertexColors = ma, this.opacity = 1, this.transparent = !1, this.blendSrc = Ia, this.blendDst = Oa, this.blendEquation = Ma, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Ha, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
        }

        function et(t) {
            tt.call(this), this.type = "MeshBasicMaterial", this.color = new T(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Qa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
        }

        function it(t) {
            tt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function rt(t, e) {
            this.origin = void 0 !== t ? t : new o, this.direction = void 0 !== e ? e : new o
        }

        function nt(t, e) {
            this.start = void 0 !== t ? t : new o, this.end = void 0 !== e ? e : new o
        }

        function ot(t, e, i) {
            this.a = void 0 !== t ? t : new o, this.b = void 0 !== e ? e : new o, this.c = void 0 !== i ? i : new o
        }

        function at(t, e) {
            R.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new J, this.material = void 0 !== e ? e : new et({
                color: 16777215 * Math.random()
            }), this.drawMode = hl, this.updateMorphTargets()
        }

        function st(t, e, i, r) {
            function n(e, r, n, u) {
                var p = r.background;
                null === p ? o(h, c) : p && p.isColor && (o(p, 1), u = !0), (t.autoClear || u) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), p && p.isCubeTexture ? (void 0 === l && (l = new at(new Z(1, 1, 1), new it({
                    uniforms: El.cube.uniforms,
                    vertexShader: El.cube.vertexShader,
                    fragmentShader: El.cube.fragmentShader,
                    side: fa,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (t, e, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, i.update(l.geometry)), l.material.uniforms.tCube.value = p, e.push(l, l.geometry, l.material, 0, null)) : p && p.isTexture && (void 0 === a && (a = new O(-1, 1, 1, -1, 0, 1), s = new at(new $(2, 2), new et({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), i.update(s.geometry)), s.material.map = p, t.renderBufferDirect(a, null, s.geometry, s.material, s, null))
            }

            function o(t, i) {
                e.buffers.color.setClear(t.r, t.g, t.b, i, r)
            }
            var a, s, l, h = new T(0),
                c = 0;
            return {
                getClearColor: function () {
                    return h
                },
                setClearColor: function (t, e) {
                    h.set(t), c = void 0 !== e ? e : 1, o(h, c)
                },
                getClearAlpha: function () {
                    return c
                },
                setClearAlpha: function (t) {
                    c = t, o(h, c)
                },
                render: n
            }
        }

        function lt(t, e, i) {
            function r(t) {
                a = t
            }

            function n(e, r) {
                t.drawArrays(a, e, r), i.update(r, a)
            }

            function o(t, r, n) {
                var o = e.get("ANGLE_instanced_arrays");
                if (null === o) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                var s = t.attributes.position;
                s.isInterleavedBufferAttribute ? (n = s.data.count, o.drawArraysInstancedANGLE(a, 0, n, t.maxInstancedCount)) : o.drawArraysInstancedANGLE(a, r, n, t.maxInstancedCount), i.update(n, a, t.maxInstancedCount)
            }
            var a;
            this.setMode = r, this.render = n, this.renderInstances = o
        }

        function ht(t, e, i) {
            function r() {
                if (void 0 !== o) return o;
                var i = e.get("EXT_texture_filter_anisotropic");
                return o = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }

            function n(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            var o, a = void 0 !== i.precision ? i.precision : "highp",
                s = n(a);
            s !== a && (a = s);
            var l = !0 === i.logarithmicDepthBuffer,
                h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                u = t.getParameter(t.MAX_TEXTURE_SIZE),
                p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                m = t.getParameter(t.MAX_VARYING_VECTORS),
                g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                v = c > 0,
                y = !!e.get("OES_texture_float");
            return {
                getMaxAnisotropy: r,
                getMaxPrecision: n,
                precision: a,
                logarithmicDepthBuffer: l,
                maxTextures: h,
                maxVertexTextures: c,
                maxTextureSize: u,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: d,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y
            }
        }

        function ct() {
            function t() {
                c.value !== r && (c.value = r, c.needsUpdate = n > 0), i.numPlanes = n, i.numIntersection = 0
            }

            function e(t, e, r, n) {
                var o = null !== t ? t.length : 0,
                    a = null;
                if (0 !== o) {
                    if (a = c.value, !0 !== n || null === a) {
                        var s = r + 4 * o,
                            u = e.matrixWorldInverse;
                        h.getNormalMatrix(u), (null === a || a.length < s) && (a = new Float32Array(s));
                        for (var p = 0, f = r; p !== o; ++p, f += 4) l.copy(t[p]).applyMatrix4(u, h), l.normal.toArray(a, f), a[f + 3] = l.constant
                    }
                    c.value = a, c.needsUpdate = !0
                }
                return i.numPlanes = o, a
            }
            var i = this,
                r = null,
                n = 0,
                o = !1,
                s = !1,
                l = new _,
                h = new a,
                c = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, i, a) {
                var s = 0 !== t.length || i || 0 !== n || o;
                return o = i, r = e(t, a, 0), n = t.length, s
            }, this.beginShadows = function () {
                s = !0, e(null)
            }, this.endShadows = function () {
                s = !1, t()
            }, this.setState = function (i, a, l, h, u, p) {
                if (!o || null === i || 0 === i.length || s && !l) s ? e(null) : t();
                else {
                    var f = s ? 0 : n,
                        d = 4 * f,
                        m = u.clippingState || null;
                    c.value = m, m = e(i, h, d, p);
                    for (var g = 0; g !== d; ++g) m[g] = r[g];
                    u.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += f
                }
            }
        }

        function ut(t) {
            var e = {};
            return {
                get: function (i) {
                    if (void 0 !== e[i]) return e[i];
                    var r;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            r = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            r = t.getExtension(i)
                    }
                    return e[i] = r, r
                }
            }
        }

        function pt(t, e, i) {
            function r(t) {
                var n = t.target,
                    o = s[n.id];
                null !== o.index && e.remove(o.index);
                for (var a in o.attributes) e.remove(o.attributes[a]);
                n.removeEventListener("dispose", r), delete s[n.id];
                var h = l[n.id];
                h && (e.remove(h), delete l[n.id]), h = l[o.id], h && (e.remove(h), delete l[o.id]), i.memory.geometries--
            }

            function n(t, e) {
                var n = s[e.id];
                return n || (e.addEventListener("dispose", r), e.isBufferGeometry ? n = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new J).setFromObject(t)), n = e._bufferGeometry), s[e.id] = n, i.memory.geometries++, n)
            }

            function o(i) {
                var r = i.index,
                    n = i.attributes;
                null !== r && e.update(r, t.ELEMENT_ARRAY_BUFFER);
                for (var o in n) e.update(n[o], t.ARRAY_BUFFER);
                var a = i.morphAttributes;
                for (var o in a)
                    for (var s = a[o], l = 0, h = s.length; l < h; l++) e.update(s[l], t.ARRAY_BUFFER)
            }

            function a(i) {
                var r = l[i.id];
                if (r) return r;
                var n = [],
                    o = i.index,
                    a = i.attributes;
                if (null !== o)
                    for (var s = o.array, h = 0, c = s.length; h < c; h += 3) {
                        var u = s[h + 0],
                            p = s[h + 1],
                            f = s[h + 2];
                        n.push(u, p, p, f, f, u)
                    } else
                        for (var s = a.position.array, h = 0, c = s.length / 3 - 1; h < c; h += 3) {
                            var u = h + 0,
                                p = h + 1,
                                f = h + 2;
                            n.push(u, p, p, f, f, u)
                        }
                return r = new(Q(n) > 65535 ? j : V)(n, 1), e.update(r, t.ELEMENT_ARRAY_BUFFER), l[i.id] = r, r
            }
            var s = {},
                l = {};
            return {
                get: n,
                update: o,
                getWireframeAttribute: a
            }
        }

        function ft(t, e, i) {
            function r(t) {
                s = t
            }

            function n(t) {
                l = t.type, h = t.bytesPerElement
            }

            function o(e, r) {
                t.drawElements(s, r, l, e * h), i.update(r, s)
            }

            function a(t, r, n) {
                var o = e.get("ANGLE_instanced_arrays");
                if (null === o) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                o.drawElementsInstancedANGLE(s, n, l, r * h, t.maxInstancedCount), i.update(n, s, t.maxInstancedCount)
            }
            var s, l, h;
            this.setMode = r, this.setIndex = n, this.render = o, this.renderInstances = a
        }

        function dt(t) {
            function e(e, i, r) {
                switch (r = r || 1, n.calls++, i) {
                    case t.TRIANGLES:
                        n.triangles += r * (e / 3);
                        break;
                    case t.TRIANGLE_STRIP:
                    case t.TRIANGLE_FAN:
                        n.triangles += r * (e - 2);
                        break;
                    case t.LINES:
                        n.lines += r * (e / 2);
                        break;
                    case t.LINE_STRIP:
                        n.lines += r * (e - 1);
                        break;
                    case t.LINE_LOOP:
                        n.lines += r * e;
                        break;
                    case t.POINTS:
                        n.points += r * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }

            function i() {
                n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0
            }
            var r = {
                    geometries: 0,
                    textures: 0
                },
                n = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
            return {
                memory: r,
                render: n,
                programs: null,
                autoReset: !0,
                reset: i,
                update: e
            }
        }

        function mt(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function gt(t) {
            function e(e, n, o, a) {
                var s = e.morphTargetInfluences,
                    l = s.length,
                    h = i[n.id];
                if (void 0 === h) {
                    h = [];
                    for (var c = 0; c < l; c++) h[c] = [c, 0];
                    i[n.id] = h
                }
                for (var u = o.morphTargets && n.morphAttributes.position, p = o.morphNormals && n.morphAttributes.normal, c = 0; c < l; c++) {
                    var f = h[c];
                    0 !== f[1] && (u && n.removeAttribute("morphTarget" + c), p && n.removeAttribute("morphNormal" + c))
                }
                for (var c = 0; c < l; c++) {
                    var f = h[c];
                    f[0] = c, f[1] = s[c]
                }
                h.sort(mt);
                for (var c = 0; c < 8; c++) {
                    var f = h[c];
                    if (f) {
                        var d = f[0],
                            m = f[1];
                        if (m) {
                            u && n.addAttribute("morphTarget" + c, u[d]), p && n.addAttribute("morphNormal" + c, p[d]), r[c] = m;
                            continue
                        }
                    }
                    r[c] = 0
                }
                a.getUniforms().setValue(t, "morphTargetInfluences", r)
            }
            var i = {},
                r = new Float32Array(8);
            return {
                update: e
            }
        }

        function vt(t, e) {
            function i(i) {
                var r = e.render.frame,
                    o = i.geometry,
                    a = t.get(i, o);
                return n[a.id] !== r && (o.isGeometry && a.updateFromObject(i), t.update(a), n[a.id] = r), a
            }

            function r() {
                n = {}
            }
            var n = {};
            return {
                update: i,
                dispose: r
            }
        }

        function yt(t, e, i, r, n, o, a, l, h, c) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : is, s.call(this, t, e, i, r, n, o, a, l, h, c), this.flipY = !1
        }

        function At() {
            this.seq = [], this.map = {}
        }

        function xt(t, e, i) {
            var r = t[0];
            if (r <= 0 || r > 0) return t;
            var n = e * i,
                o = Ol[n];
            if (void 0 === o && (o = new Float32Array(n), Ol[n] = o), 0 !== e) {
                r.toArray(o, 0);
                for (var a = 1, s = 0; a !== e; ++a) s += i, t[a].toArray(o, s)
            }
            return o
        }

        function _t(t, e) {
            var i = Bl[e];
            void 0 === i && (i = new Int32Array(e), Bl[e] = i);
            for (var r = 0; r !== e; ++r) i[r] = t.allocTextureUnit();
            return i
        }

        function wt(t, e) {
            t.uniform1f(this.addr, e)
        }

        function bt(t, e) {
            t.uniform1i(this.addr, e)
        }

        function Mt(t, e) {
            void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
        }

        function Tt(t, e) {
            void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
        }

        function St(t, e) {
            void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
        }

        function Et(t, e) {
            t.uniformMatrix2fv(this.addr, !1, e.elements || e)
        }

        function Ct(t, e) {
            void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (kl.set(e.elements), t.uniformMatrix3fv(this.addr, !1, kl))
        }

        function Pt(t, e) {
            void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Nl.set(e.elements), t.uniformMatrix4fv(this.addr, !1, Nl))
        }

        function Lt(t, e, i) {
            var r = i.allocTextureUnit();
            t.uniform1i(this.addr, r), i.setTexture2D(e || Rl, r)
        }

        function Dt(t, e, i) {
            var r = i.allocTextureUnit();
            t.uniform1i(this.addr, r), i.setTextureCube(e || Il, r)
        }

        function Rt(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function It(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function Ot(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function Bt(t) {
            switch (t) {
                case 5126:
                    return wt;
                case 35664:
                    return Mt;
                case 35665:
                    return Tt;
                case 35666:
                    return St;
                case 35674:
                    return Et;
                case 35675:
                    return Ct;
                case 35676:
                    return Pt;
                case 35678:
                case 36198:
                    return Lt;
                case 35680:
                    return Dt;
                case 5124:
                case 35670:
                    return bt;
                case 35667:
                case 35671:
                    return Rt;
                case 35668:
                case 35672:
                    return It;
                case 35669:
                case 35673:
                    return Ot
            }
        }

        function Nt(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function kt(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Ft(t, e) {
            t.uniform2fv(this.addr, xt(e, this.size, 2))
        }

        function zt(t, e) {
            t.uniform3fv(this.addr, xt(e, this.size, 3))
        }

        function Ut(t, e) {
            t.uniform4fv(this.addr, xt(e, this.size, 4))
        }

        function Gt(t, e) {
            t.uniformMatrix2fv(this.addr, !1, xt(e, this.size, 4))
        }

        function Vt(t, e) {
            t.uniformMatrix3fv(this.addr, !1, xt(e, this.size, 9))
        }

        function Ht(t, e) {
            t.uniformMatrix4fv(this.addr, !1, xt(e, this.size, 16))
        }

        function jt(t, e, i) {
            var r = e.length,
                n = _t(i, r);
            t.uniform1iv(this.addr, n);
            for (var o = 0; o !== r; ++o) i.setTexture2D(e[o] || Rl, n[o])
        }

        function Wt(t, e, i) {
            var r = e.length,
                n = _t(i, r);
            t.uniform1iv(this.addr, n);
            for (var o = 0; o !== r; ++o) i.setTextureCube(e[o] || Il, n[o])
        }

        function Yt(t) {
            switch (t) {
                case 5126:
                    return Nt;
                case 35664:
                    return Ft;
                case 35665:
                    return zt;
                case 35666:
                    return Ut;
                case 35674:
                    return Gt;
                case 35675:
                    return Vt;
                case 35676:
                    return Ht;
                case 35678:
                    return jt;
                case 35680:
                    return Wt;
                case 5124:
                case 35670:
                    return kt;
                case 35667:
                case 35671:
                    return Rt;
                case 35668:
                case 35672:
                    return It;
                case 35669:
                case 35673:
                    return Ot
            }
        }

        function Xt(t, e, i) {
            this.id = t, this.addr = i, this.setValue = Bt(e.type)
        }

        function Qt(t, e, i) {
            this.id = t, this.addr = i, this.size = e.size, this.setValue = Yt(e.type)
        }

        function Jt(t) {
            this.id = t, At.call(this)
        }

        function qt(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function Zt(t, e, i) {
            var r = t.name,
                n = r.length;
            for (Fl.lastIndex = 0;;) {
                var o = Fl.exec(r),
                    a = Fl.lastIndex,
                    s = o[1],
                    l = "]" === o[2],
                    h = o[3];
                if (l && (s |= 0), void 0 === h || "[" === h && a + 2 === n) {
                    qt(i, void 0 === h ? new Xt(s, t, e) : new Qt(s, t, e));
                    break
                }
                var c = i.map,
                    u = c[s];
                void 0 === u && (u = new Jt(s), qt(i, u)), i = u
            }
        }

        function Kt(t, e, i) {
            At.call(this), this.renderer = i;
            for (var r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), n = 0; n < r; ++n) {
                var o = t.getActiveUniform(e, n);
                Zt(o, t.getUniformLocation(e, o.name), this)
            }
        }

        function $t(t, e, i) {
            var r = t.createShader(e);
            return t.shaderSource(r, i), t.compileShader(r), !1 === t.getShaderParameter(r, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), t.getShaderInfoLog(r), r
        }

        function te(t) {
            switch (t) {
                case pl:
                    return ["Linear", "( value )"];
                case fl:
                    return ["sRGB", "( value )"];
                case ml:
                    return ["RGBE", "( value )"];
                case gl:
                    return ["RGBM", "( value, 7.0 )"];
                case vl:
                    return ["RGBM", "( value, 16.0 )"];
                case yl:
                    return ["RGBD", "( value, 256.0 )"];
                case dl:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("unsupported encoding: " + t)
            }
        }

        function ee(t, e) {
            var i = te(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }

        function ie(t, e) {
            var i = te(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }

        function re(t, e) {
            var i;
            switch (e) {
                case Ka:
                    i = "Linear";
                    break;
                case $a:
                    i = "Reinhard";
                    break;
                case ts:
                    i = "Uncharted2";
                    break;
                case es:
                    i = "OptimizedCineon";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }

        function ne(t, e, i) {
            return t = t || {}, [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(se).join("\n")
        }

        function oe(t) {
            var e = [];
            for (var i in t) {
                var r = t[i];
                !1 !== r && e.push("#define " + i + " " + r)
            }
            return e.join("\n")
        }

        function ae(t, e) {
            for (var i = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), n = 0; n < r; n++) {
                var o = t.getActiveAttrib(e, n),
                    a = o.name;
                i[a] = t.getAttribLocation(e, a)
            }
            return i
        }

        function se(t) {
            return "" !== t
        }

        function le(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function he(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }

        function ce(t) {
            function e(t, e) {
                var i = bl[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return ce(i)
            }
            var i = /^[ \t]*#include +<([\w\d.]+)>/gm;
            return t.replace(i, e)
        }

        function ue(t) {
            function e(t, e, i, r) {
                for (var n = "", o = parseInt(e); o < parseInt(i); o++) n += r.replace(/\[ i \]/g, "[ " + o + " ]");
                return n
            }
            var i = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            return t.replace(i, e)
        }

        function pe(t, e, i, r, n, o) {
            var a = t.context,
                s = r.defines,
                l = n.vertexShader,
                h = n.fragmentShader,
                c = "SHADOWMAP_TYPE_BASIC";
            o.shadowMapType === ca ? c = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === ua && (c = "SHADOWMAP_TYPE_PCF_SOFT");
            var u = "ENVMAP_TYPE_CUBE",
                p = "ENVMAP_MODE_REFLECTION",
                f = "ENVMAP_BLENDING_MULTIPLY";
            if (o.envMap) {
                switch (r.envMap.mapping) {
                    case is:
                    case rs:
                        u = "ENVMAP_TYPE_CUBE";
                        break;
                    case ss:
                    case ls:
                        u = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case ns:
                    case os:
                        u = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case as:
                        u = "ENVMAP_TYPE_SPHERE"
                }
                switch (r.envMap.mapping) {
                    case rs:
                    case os:
                        p = "ENVMAP_MODE_REFRACTION"
                }
                switch (r.combine) {
                    case Qa:
                        f = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case Ja:
                        f = "ENVMAP_BLENDING_MIX";
                        break;
                    case qa:
                        f = "ENVMAP_BLENDING_ADD"
                }
            }
            var d, m, g = t.gammaFactor > 0 ? t.gammaFactor : 1,
                v = ne(r.extensions, o, e),
                y = oe(s),
                A = a.createProgram();
            r.isRawShaderMaterial ? (d = [y].filter(se).join("\n"), d.length > 0 && (d += "\n"), m = [v, y].filter(se).join("\n"), m.length > 0 && (m += "\n")) : (d = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + n.name, y, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(se).join("\n"), m = [v, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + n.name, y, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + g, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + u : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== Za ? "#define TONE_MAPPING" : "", o.toneMapping !== Za ? bl.tonemapping_pars_fragment : "", o.toneMapping !== Za ? re("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? bl.encodings_pars_fragment : "", o.mapEncoding ? ee("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? ee("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? ee("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? ie("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(se).join("\n")), l = ce(l), l = le(l, o), l = he(l, o), h = ce(h), h = le(h, o), h = he(h, o), l = ue(l), h = ue(h);
            var _ = d + l,
                w = m + h,
                b = $t(a, a.VERTEX_SHADER, _),
                M = $t(a, a.FRAGMENT_SHADER, w);
            a.attachShader(A, b), a.attachShader(A, M), void 0 !== r.index0AttributeName ? a.bindAttribLocation(A, 0, r.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(A, 0, "position"), a.linkProgram(A);
            var T = a.getProgramInfoLog(A).trim(),
                S = a.getShaderInfoLog(b).trim(),
                E = a.getShaderInfoLog(M).trim(),
                C = !0,
                P = !0;
            !1 === a.getProgramParameter(A, a.LINK_STATUS) ? (C = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(A, a.VALIDATE_STATUS), "gl.getProgramInfoLog", T, S, E)) : "" !== T || "" !== S && "" !== E || (P = !1), P && (this.diagnostics = {
                runnable: C,
                material: r,
                programLog: T,
                vertexShader: {
                    log: S,
                    prefix: d
                },
                fragmentShader: {
                    log: E,
                    prefix: m
                }
            }), a.deleteShader(b), a.deleteShader(M);
            var L;
            this.getUniforms = function () {
                return void 0 === L && (L = new Kt(a, A, t)), L
            };
            var D;
            return this.getAttributes = function () {
                return void 0 === D && (D = ae(a, A)), D
            }, this.destroy = function () {
                a.deleteProgram(A), this.program = void 0
            }, (0, x.default)(this, {
                uniforms: {
                    get: function () {
                        return this.getUniforms()
                    }
                },
                attributes: {
                    get: function () {
                        return this.getAttributes()
                    }
                }
            }), this.id = zl++, this.code = i, this.usedTimes = 1, this.program = A, this.vertexShader = b, this.fragmentShader = M, this
        }

        function fe(t, e, i) {
            function r(t) {
                var e = t.skeleton,
                    r = e.bones;
                if (i.floatVertexTextures) return 1024;
                var n = i.maxVertexUniforms,
                    o = Math.floor((n - 20) / 4),
                    a = Math.min(o, r.length);
                return a < r.length ? 0 : a
            }

            function n(t, e) {
                var i;
                return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (i = t.texture.encoding) : i = pl, i === pl && e && (i = dl), i
            }
            var o = [],
                a = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow"
                },
                s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
            this.getParameters = function (e, o, s, l, h, c, u) {
                var p = a[e.type],
                    f = u.isSkinnedMesh ? r(u) : 0,
                    d = i.precision;
                null !== e.precision && (d = i.getMaxPrecision(e.precision), e.precision);
                var m = t.getRenderTarget();
                return {
                    shaderID: p,
                    precision: d,
                    supportsVertexTextures: i.vertexTextures,
                    outputEncoding: n(m ? m.texture : null, t.gammaOutput),
                    map: !!e.map,
                    mapEncoding: n(e.map, t.gammaInput),
                    envMap: !!e.envMap,
                    envMapMode: e.envMap && e.envMap.mapping,
                    envMapEncoding: n(e.envMap, t.gammaInput),
                    envMapCubeUV: !!e.envMap && (e.envMap.mapping === ss || e.envMap.mapping === ls),
                    lightMap: !!e.lightMap,
                    aoMap: !!e.aoMap,
                    emissiveMap: !!e.emissiveMap,
                    emissiveMapEncoding: n(e.emissiveMap, t.gammaInput),
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    displacementMap: !!e.displacementMap,
                    roughnessMap: !!e.roughnessMap,
                    metalnessMap: !!e.metalnessMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    gradientMap: !!e.gradientMap,
                    combine: e.combine,
                    vertexColors: e.vertexColors,
                    fog: !!l,
                    useFog: e.fog,
                    fogExp: l && l.isFogExp2,
                    flatShading: e.flatShading,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                    skinning: e.skinning && f > 0,
                    maxBones: f,
                    useVertexTexture: i.floatVertexTextures,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: o.directional.length,
                    numPointLights: o.point.length,
                    numSpotLights: o.spot.length,
                    numRectAreaLights: o.rectArea.length,
                    numHemiLights: o.hemi.length,
                    numClippingPlanes: h,
                    numClipIntersection: c,
                    dithering: e.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && u.receiveShadow && s.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: t.toneMapping,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: e.premultipliedAlpha,
                    alphaTest: e.alphaTest,
                    doubleSided: e.side === da,
                    flipSided: e.side === fa,
                    depthPacking: void 0 !== e.depthPacking && e.depthPacking
                }
            }, this.getProgramCode = function (e, i) {
                var r = [];
                if (i.shaderID ? r.push(i.shaderID) : (r.push(e.fragmentShader), r.push(e.vertexShader)), void 0 !== e.defines)
                    for (var n in e.defines) r.push(n), r.push(e.defines[n]);
                for (var o = 0; o < s.length; o++) r.push(i[s[o]]);
                return r.push(e.onBeforeCompile.toString()), r.push(t.gammaOutput), r.join()
            }, this.acquireProgram = function (i, r, n, a) {
                for (var s, l = 0, h = o.length; l < h; l++) {
                    var c = o[l];
                    if (c.code === a) {
                        s = c, ++s.usedTimes;
                        break
                    }
                }
                return void 0 === s && (s = new pe(t, e, a, i, r, n), o.push(s)), s
            }, this.releaseProgram = function (t) {
                if (0 == --t.usedTimes) {
                    var e = o.indexOf(t);
                    o[e] = o[o.length - 1], o.pop(), t.destroy()
                }
            }, this.programs = o
        }

        function de() {
            function t(t) {
                var e = n.get(t);
                return void 0 === e && (e = {}, n.set(t, e)), e
            }

            function e(t) {
                n.delete(t)
            }

            function i(t, e, i) {
                n.get(t)[e] = i
            }

            function r() {
                n = new g.default
            }
            var n = new g.default;
            return {
                get: t,
                remove: e,
                update: i,
                dispose: r
            }
        }

        function me(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function ge(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function ve() {
            function t() {
                n = 0, o.length = 0, a.length = 0
            }

            function e(t, e, i, s, l) {
                var h = r[n];
                void 0 === h ? (h = {
                    id: t.id,
                    object: t,
                    geometry: e,
                    material: i,
                    program: i.program,
                    renderOrder: t.renderOrder,
                    z: s,
                    group: l
                }, r[n] = h) : (h.id = t.id, h.object = t, h.geometry = e, h.material = i, h.program = i.program, h.renderOrder = t.renderOrder, h.z = s, h.group = l), (!0 === i.transparent ? a : o).push(h), n++
            }

            function i() {
                o.length > 1 && o.sort(me), a.length > 1 && a.sort(ge)
            }
            var r = [],
                n = 0,
                o = [],
                a = [];
            return {
                opaque: o,
                transparent: a,
                init: t,
                push: e,
                sort: i
            }
        }

        function ye() {
            function t(t, e) {
                var r = t.id + "," + e.id,
                    n = i[r];
                return void 0 === n && (n = new ve, i[r] = n), n
            }

            function e() {
                i = {}
            }
            var i = {};
            return {
                get: t,
                dispose: e
            }
        }

        function Ae() {
            var t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var r;
                    switch (e.type) {
                        case "DirectionalLight":
                            r = {
                                direction: new o,
                                color: new T,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "SpotLight":
                            r = {
                                position: new o,
                                direction: new o,
                                color: new T,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "PointLight":
                            r = {
                                position: new o,
                                color: new T,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break;
                        case "HemisphereLight":
                            r = {
                                direction: new o,
                                skyColor: new T,
                                groundColor: new T
                            };
                            break;
                        case "RectAreaLight":
                            r = {
                                color: new T,
                                position: new o,
                                halfWidth: new o,
                                halfHeight: new o
                            }
                    }
                    return t[e.id] = r, r
                }
            }
        }

        function xe() {
            function t(t, r, o) {
                for (var l = 0, h = 0, c = 0, u = 0, p = 0, f = 0, d = 0, m = 0, g = o.matrixWorldInverse, v = 0, y = t.length; v < y; v++) {
                    var A = t[v],
                        x = A.color,
                        _ = A.intensity,
                        w = A.distance,
                        b = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
                    if (A.isAmbientLight) l += x.r * _, h += x.g * _, c += x.b * _;
                    else if (A.isDirectionalLight) {
                        var M = e.get(A);
                        if (M.color.copy(A.color).multiplyScalar(A.intensity), M.direction.setFromMatrixPosition(A.matrixWorld), n.setFromMatrixPosition(A.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(g), M.shadow = A.castShadow, A.castShadow) {
                            var T = A.shadow;
                            M.shadowBias = T.bias, M.shadowRadius = T.radius, M.shadowMapSize = T.mapSize
                        }
                        i.directionalShadowMap[u] = b, i.directionalShadowMatrix[u] = A.shadow.matrix, i.directional[u] = M, u++
                    } else if (A.isSpotLight) {
                        var M = e.get(A);
                        if (M.position.setFromMatrixPosition(A.matrixWorld), M.position.applyMatrix4(g), M.color.copy(x).multiplyScalar(_), M.distance = w, M.direction.setFromMatrixPosition(A.matrixWorld), n.setFromMatrixPosition(A.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(g), M.coneCos = Math.cos(A.angle), M.penumbraCos = Math.cos(A.angle * (1 - A.penumbra)), M.decay = 0 === A.distance ? 0 : A.decay, M.shadow = A.castShadow, A.castShadow) {
                            var T = A.shadow;
                            M.shadowBias = T.bias, M.shadowRadius = T.radius, M.shadowMapSize = T.mapSize
                        }
                        i.spotShadowMap[f] = b, i.spotShadowMatrix[f] = A.shadow.matrix, i.spot[f] = M, f++
                    } else if (A.isRectAreaLight) {
                        var M = e.get(A);
                        M.color.copy(x).multiplyScalar(_), M.position.setFromMatrixPosition(A.matrixWorld), M.position.applyMatrix4(g), s.identity(), a.copy(A.matrixWorld), a.premultiply(g), s.extractRotation(a), M.halfWidth.set(.5 * A.width, 0, 0), M.halfHeight.set(0, .5 * A.height, 0), M.halfWidth.applyMatrix4(s), M.halfHeight.applyMatrix4(s), i.rectArea[d] = M, d++
                    } else if (A.isPointLight) {
                        var M = e.get(A);
                        if (M.position.setFromMatrixPosition(A.matrixWorld), M.position.applyMatrix4(g), M.color.copy(A.color).multiplyScalar(A.intensity), M.distance = A.distance, M.decay = 0 === A.distance ? 0 : A.decay, M.shadow = A.castShadow, A.castShadow) {
                            var T = A.shadow;
                            M.shadowBias = T.bias, M.shadowRadius = T.radius, M.shadowMapSize = T.mapSize, M.shadowCameraNear = T.camera.near, M.shadowCameraFar = T.camera.far
                        }
                        i.pointShadowMap[p] = b, i.pointShadowMatrix[p] = A.shadow.matrix, i.point[p] = M, p++
                    } else if (A.isHemisphereLight) {
                        var M = e.get(A);
                        M.direction.setFromMatrixPosition(A.matrixWorld), M.direction.transformDirection(g), M.direction.normalize(), M.skyColor.copy(A.color).multiplyScalar(_), M.groundColor.copy(A.groundColor).multiplyScalar(_), i.hemi[m] = M, m++
                    }
                }
                i.ambient[0] = l, i.ambient[1] = h, i.ambient[2] = c, i.directional.length = u, i.spot.length = f, i.rectArea.length = d, i.point.length = p, i.hemi.length = m, i.hash = i.id + "," + u + "," + p + "," + f + "," + d + "," + m + "," + r.length
            }
            var e = new Ae,
                i = {
                    id: Ul++,
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                },
                n = new o,
                a = new r,
                s = new r;
            return {
                setup: t,
                state: i
            }
        }

        function _e() {
            function t() {
                a.length = 0, s.length = 0, l.length = 0
            }

            function e(t) {
                a.push(t)
            }

            function i(t) {
                s.push(t)
            }

            function r(t) {
                l.push(t)
            }

            function n(t) {
                o.setup(a, s, t)
            }
            var o = new xe,
                a = [],
                s = [],
                l = [];
            return {
                init: t,
                state: {
                    lightsArray: a,
                    shadowsArray: s,
                    spritesArray: l,
                    lights: o
                },
                setupLights: n,
                pushLight: e,
                pushShadow: i,
                pushSprite: r
            }
        }

        function we() {
            function t(t, e) {
                var r = t.id + "," + e.id,
                    n = i[r];
                return void 0 === n && (n = new _e, i[r] = n), n
            }

            function e() {
                i = {}
            }
            var i = {};
            return {
                get: t,
                dispose: e
            }
        }

        function be(t) {
            tt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Al, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function Me(t) {
            tt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new o, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function Te(t, e, n) {
            function a(e, i, r, n, o, a) {
                var s = e.geometry,
                    l = null,
                    h = A,
                    c = e.customDepthMaterial;
                if (r && (h = x, c = e.customDistanceMaterial), c) l = c;
                else {
                    var u = !1;
                    i.morphTargets && (s && s.isBufferGeometry ? u = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (u = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && i.skinning;
                    var p = e.isSkinnedMesh && i.skinning,
                        f = 0;
                    u && (f |= g), p && (f |= v), l = h[f]
                }
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    var d = l.uuid,
                        m = i.uuid,
                        y = _[d];
                    void 0 === y && (y = {}, _[d] = y);
                    var b = y[m];
                    void 0 === b && (b = l.clone(), y[m] = b), l = b
                }
                return l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : w[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, r && l.isMeshDistanceMaterial && (l.referencePosition.copy(n), l.nearDistance = o, l.farDistance = a), l
            }

            function s(i, r, n, o) {
                if (!1 !== i.visible) {
                    if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || l.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, i.matrixWorld);
                        var h = e.update(i),
                            c = i.material;
                        if (Array.isArray(c))
                            for (var u = h.groups, p = 0, f = u.length; p < f; p++) {
                                var d = u[p],
                                    g = c[d.materialIndex];
                                if (g && g.visible) {
                                    var v = a(i, g, o, m, n.near, n.far);
                                    t.renderBufferDirect(n, null, h, v, i, d)
                                }
                            } else if (c.visible) {
                                var v = a(i, c, o, m, n.near, n.far);
                                t.renderBufferDirect(n, null, h, v, i, null)
                            }
                    }
                    for (var y = i.children, A = 0, x = y.length; A < x; A++) s(y[A], r, n, o)
                }
            }
            for (var l = new b, c = new r, p = new i, f = new i(n, n), d = new o, m = new o, g = 1, v = 2, y = 1 + (g | v), A = new Array(y), x = new Array(y), _ = {}, w = {
                    0: fa,
                    1: pa,
                    2: da
                }, M = [new o(1, 0, 0), new o(-1, 0, 0), new o(0, 0, 1), new o(0, 0, -1), new o(0, 1, 0), new o(0, -1, 0)], T = [new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 0, 1), new o(0, 0, -1)], S = [new h, new h, new h, new h, new h, new h], E = 0; E !== y; ++E) {
                var C = 0 != (E & g),
                    P = 0 != (E & v),
                    L = new be({
                        depthPacking: xl,
                        morphTargets: C,
                        skinning: P
                    });
                A[E] = L;
                var D = new Me({
                    morphTargets: C,
                    skinning: P
                });
                x[E] = D
            }
            var R = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ca, this.render = function (e, i, r) {
                if (!1 !== R.enabled && (!1 !== R.autoUpdate || !1 !== R.needsUpdate) && 0 !== e.length) {
                    var n = t.context,
                        o = t.state;
                    o.disable(n.BLEND), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                    for (var a, h = 0, g = e.length; h < g; h++) {
                        var v = e[h],
                            y = v.shadow,
                            A = v && v.isPointLight;
                        if (void 0 !== y) {
                            var x = y.camera;
                            if (p.copy(y.mapSize), p.min(f), A) {
                                var _ = p.x,
                                    w = p.y;
                                S[0].set(2 * _, w, _, w), S[1].set(0, w, _, w), S[2].set(3 * _, w, _, w), S[3].set(_, w, _, w), S[4].set(3 * _, 0, _, w), S[5].set(_, 0, _, w), p.x *= 4, p.y *= 2
                            }
                            if (null === y.map) {
                                var b = {
                                    minFilter: ps,
                                    magFilter: ps,
                                    format: Rs
                                };
                                y.map = new u(p.x, p.y, b), y.map.texture.name = v.name + ".shadowMap", x.updateProjectionMatrix()
                            }
                            y.isSpotLightShadow && y.update(v);
                            var E = y.map,
                                C = y.matrix;
                            m.setFromMatrixPosition(v.matrixWorld), x.position.copy(m), A ? (a = 6, C.makeTranslation(-m.x, -m.y, -m.z)) : (a = 1, d.setFromMatrixPosition(v.target.matrixWorld), x.lookAt(d), x.updateMatrixWorld(), C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), C.multiply(x.projectionMatrix), C.multiply(x.matrixWorldInverse)), t.setRenderTarget(E), t.clear();
                            for (var P = 0; P < a; P++) {
                                if (A) {
                                    d.copy(x.position), d.add(M[P]), x.up.copy(T[P]), x.lookAt(d), x.updateMatrixWorld();
                                    var L = S[P];
                                    o.viewport(L)
                                }
                                c.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), l.setFromMatrix(c), s(i, r, x, A)
                            }
                        }
                    }
                    R.needsUpdate = !1
                }
            }
        }

        function Se(t, e, i, r, n, o, a, l, h) {
            s.call(this, t, e, i, r, n, o, a, l, h), this.needsUpdate = !0
        }

        function Ee(t, e, i, r, a) {
            function s() {
                var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                    i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                c = e.createBuffer(), u = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, c), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), p = l(), f = {
                    position: e.getAttribLocation(p, "position"),
                    uv: e.getAttribLocation(p, "uv")
                }, d = {
                    uvOffset: e.getUniformLocation(p, "uvOffset"),
                    uvScale: e.getUniformLocation(p, "uvScale"),
                    rotation: e.getUniformLocation(p, "rotation"),
                    center: e.getUniformLocation(p, "center"),
                    scale: e.getUniformLocation(p, "scale"),
                    color: e.getUniformLocation(p, "color"),
                    map: e.getUniformLocation(p, "map"),
                    opacity: e.getUniformLocation(p, "opacity"),
                    modelViewMatrix: e.getUniformLocation(p, "modelViewMatrix"),
                    projectionMatrix: e.getUniformLocation(p, "projectionMatrix"),
                    fogType: e.getUniformLocation(p, "fogType"),
                    fogDensity: e.getUniformLocation(p, "fogDensity"),
                    fogNear: e.getUniformLocation(p, "fogNear"),
                    fogFar: e.getUniformLocation(p, "fogFar"),
                    fogColor: e.getUniformLocation(p, "fogColor"),
                    fogDepth: e.getUniformLocation(p, "fogDepth"),
                    alphaTest: e.getUniformLocation(p, "alphaTest")
                };
                var r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                r.width = 8, r.height = 8;
                var n = r.getContext("2d");
                n.fillStyle = "white", n.fillRect(0, 0, 8, 8), m = new Se(r)
            }

            function l() {
                var t = e.createProgram(),
                    i = e.createShader(e.VERTEX_SHADER),
                    r = e.createShader(e.FRAGMENT_SHADER);
                return e.shaderSource(i, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 center;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = ( position - center ) * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), e.shaderSource(r, ["precision " + a.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), e.compileShader(i), e.compileShader(r), e.attachShader(t, i), e.attachShader(t, r), e.linkProgram(t), t
            }

            function h(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }
            var c, u, p, f, d, m, g = new o,
                v = new n,
                y = new o;
            this.render = function (n, o, a) {
                if (0 !== n.length) {
                    void 0 === p && s(), i.useProgram(p), i.initAttributes(), i.enableAttribute(f.position), i.enableAttribute(f.uv), i.disableUnusedAttributes(), i.disable(e.CULL_FACE), i.enable(e.BLEND), e.bindBuffer(e.ARRAY_BUFFER, c), e.vertexAttribPointer(f.position, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(f.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, u), e.uniformMatrix4fv(d.projectionMatrix, !1, a.projectionMatrix.elements), i.activeTexture(e.TEXTURE0), e.uniform1i(d.map, 0);
                    var l = 0,
                        A = 0,
                        x = o.fog;
                    x ? (e.uniform3f(d.fogColor, x.color.r, x.color.g, x.color.b), x.isFog ? (e.uniform1f(d.fogNear, x.near), e.uniform1f(d.fogFar, x.far), e.uniform1i(d.fogType, 1), l = 1, A = 1) : x.isFogExp2 && (e.uniform1f(d.fogDensity, x.density), e.uniform1i(d.fogType, 2), l = 2, A = 2)) : (e.uniform1i(d.fogType, 0), l = 0, A = 0);
                    for (var _ = 0, w = n.length; _ < w; _++) {
                        var b = n[_];
                        b.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, b.matrixWorld), b.z = -b.modelViewMatrix.elements[14]
                    }
                    n.sort(h);
                    for (var M = [], T = [], _ = 0, w = n.length; _ < w; _++) {
                        var b = n[_],
                            S = b.material;
                        if (!1 !== S.visible) {
                            b.onBeforeRender(t, o, a, void 0, S, void 0), e.uniform1f(d.alphaTest, S.alphaTest), e.uniformMatrix4fv(d.modelViewMatrix, !1, b.modelViewMatrix.elements), b.matrixWorld.decompose(g, v, y), M[0] = y.x, M[1] = y.y, T[0] = b.center.x - .5, T[1] = b.center.y - .5;
                            var E = 0;
                            o.fog && S.fog && (E = A), l !== E && (e.uniform1i(d.fogType, E), l = E), null !== S.map ? (e.uniform2f(d.uvOffset, S.map.offset.x, S.map.offset.y), e.uniform2f(d.uvScale, S.map.repeat.x, S.map.repeat.y)) : (e.uniform2f(d.uvOffset, 0, 0), e.uniform2f(d.uvScale, 1, 1)), e.uniform1f(d.opacity, S.opacity), e.uniform3f(d.color, S.color.r, S.color.g, S.color.b), e.uniform1f(d.rotation, S.rotation), e.uniform2fv(d.center, T), e.uniform2fv(d.scale, M), i.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst, S.blendEquationAlpha, S.blendSrcAlpha, S.blendDstAlpha, S.premultipliedAlpha), i.buffers.depth.setTest(S.depthTest), i.buffers.depth.setMask(S.depthWrite), i.buffers.color.setMask(S.colorWrite), r.setTexture2D(S.map || m, 0), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), b.onAfterRender(t, o, a, void 0, S, void 0)
                        }
                    }
                    i.enable(e.CULL_FACE), i.reset()
                }
            }
        }

        function Ce(t, e, i) {
            function r() {
                var e = !1,
                    i = new h,
                    r = null,
                    n = new h(0, 0, 0, 0);
                return {
                    setMask: function (i) {
                        r === i || e || (t.colorMask(i, i, i, i), r = i)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e, r, o, a, s) {
                        !0 === s && (e *= a, r *= a, o *= a), i.set(e, r, o, a), !1 === n.equals(i) && (t.clearColor(e, r, o, a), n.copy(i))
                    },
                    reset: function () {
                        e = !1, r = null, n.set(-1, 0, 0, 0)
                    }
                }
            }

            function n() {
                var e = !1,
                    i = null,
                    r = null,
                    n = null;
                return {
                    setTest: function (e) {
                        e ? p(t.DEPTH_TEST) : f(t.DEPTH_TEST)
                    },
                    setMask: function (r) {
                        i === r || e || (t.depthMask(r), i = r)
                    },
                    setFunc: function (e) {
                        if (r !== e) {
                            if (e) switch (e) {
                                case Ua:
                                    t.depthFunc(t.NEVER);
                                    break;
                                case Ga:
                                    t.depthFunc(t.ALWAYS);
                                    break;
                                case Va:
                                    t.depthFunc(t.LESS);
                                    break;
                                case Ha:
                                    t.depthFunc(t.LEQUAL);
                                    break;
                                case ja:
                                    t.depthFunc(t.EQUAL);
                                    break;
                                case Wa:
                                    t.depthFunc(t.GEQUAL);
                                    break;
                                case Ya:
                                    t.depthFunc(t.GREATER);
                                    break;
                                case Xa:
                                    t.depthFunc(t.NOTEQUAL);
                                    break;
                                default:
                                    t.depthFunc(t.LEQUAL)
                            } else t.depthFunc(t.LEQUAL);
                            r = e
                        }
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        n !== e && (t.clearDepth(e), n = e)
                    },
                    reset: function () {
                        e = !1, i = null, r = null, n = null
                    }
                }
            }

            function o() {
                var e = !1,
                    i = null,
                    r = null,
                    n = null,
                    o = null,
                    a = null,
                    s = null,
                    l = null,
                    h = null;
                return {
                    setTest: function (e) {
                        e ? p(t.STENCIL_TEST) : f(t.STENCIL_TEST)
                    },
                    setMask: function (r) {
                        i === r || e || (t.stencilMask(r), i = r)
                    },
                    setFunc: function (e, i, a) {
                        r === e && n === i && o === a || (t.stencilFunc(e, i, a), r = e, n = i, o = a)
                    },
                    setOp: function (e, i, r) {
                        a === e && s === i && l === r || (t.stencilOp(e, i, r), a = e, s = i, l = r)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        h !== e && (t.clearStencil(e), h = e)
                    },
                    reset: function () {
                        e = !1, i = null, r = null, n = null, o = null, a = null, s = null, l = null, h = null
                    }
                }
            }

            function a(e, i, r) {
                var n = new Uint8Array(4),
                    o = t.createTexture();
                t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (var a = 0; a < r; a++) t.texImage2D(i + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, n);
                return o
            }

            function s() {
                for (var t = 0, e = O.length; t < e; t++) O[t] = 0
            }

            function l(i) {
                if (O[i] = 1, 0 === B[i] && (t.enableVertexAttribArray(i), B[i] = 1), 0 !== N[i]) {
                    e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), N[i] = 0
                }
            }

            function c(i, r) {
                if (O[i] = 1, 0 === B[i] && (t.enableVertexAttribArray(i), B[i] = 1), N[i] !== r) {
                    e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, r), N[i] = r
                }
            }

            function u() {
                for (var e = 0, i = B.length; e !== i; ++e) B[e] !== O[e] && (t.disableVertexAttribArray(e), B[e] = 0)
            }

            function p(e) {
                !0 !== k[e] && (t.enable(e), k[e] = !0)
            }

            function f(e) {
                !1 !== k[e] && (t.disable(e), k[e] = !1)
            }

            function d() {
                if (null === F && (F = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                    for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), r = 0; r < i.length; r++) F.push(i[r]);
                return F
            }

            function m(e) {
                return z !== e && (t.useProgram(e), z = e, !0)
            }

            function g(e, r, n, o, a, s, l, h) {
                if (e !== ya ? p(t.BLEND) : f(t.BLEND), e !== ba) {
                    if (e !== U || h !== X) switch (e) {
                        case xa:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                            break;
                        case _a:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                            break;
                        case wa:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                            break;
                        default:
                            h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                    }
                    G = null, V = null, H = null, j = null, W = null, Y = null
                } else a = a || r, s = s || n, l = l || o, r === G && a === j || (t.blendEquationSeparate(i.convert(r), i.convert(a)), G = r, j = a), n === V && o === H && s === W && l === Y || (t.blendFuncSeparate(i.convert(n), i.convert(o), i.convert(s), i.convert(l)), V = n, H = o, W = s, Y = l);
                U = e, X = h
            }

            function v(e, i) {
                e.side === da ? f(t.CULL_FACE) : p(t.CULL_FACE);
                var r = e.side === fa;
                i && (r = !r), y(r), !0 === e.transparent ? g(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : g(ya), D.setFunc(e.depthFunc), D.setTest(e.depthTest), D.setMask(e.depthWrite), L.setMask(e.colorWrite), _(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            }

            function y(e) {
                Q !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), Q = e)
            }

            function A(e) {
                e !== sa ? (p(t.CULL_FACE), e !== J && (e === la ? t.cullFace(t.BACK) : e === ha ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : f(t.CULL_FACE), J = e
            }

            function x(e) {
                e !== q && (tt && t.lineWidth(e), q = e)
            }

            function _(e, i, r) {
                e ? (p(t.POLYGON_OFFSET_FILL), Z === i && K === r || (t.polygonOffset(i, r), Z = i, K = r)) : f(t.POLYGON_OFFSET_FILL)
            }

            function w(e) {
                e ? p(t.SCISSOR_TEST) : f(t.SCISSOR_TEST)
            }

            function b(e) {
                void 0 === e && (e = t.TEXTURE0 + $ - 1), rt !== e && (t.activeTexture(e), rt = e)
            }

            function M(e, i) {
                null === rt && b();
                var r = nt[rt];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                }, nt[rt] = r), r.type === e && r.texture === i || (t.bindTexture(e, i || st[e]), r.type = e, r.texture = i)
            }

            function T() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            }

            function S() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            }

            function E(e) {
                !1 === ot.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ot.copy(e))
            }

            function C(e) {
                !1 === at.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), at.copy(e))
            }

            function P() {
                for (var e = 0; e < B.length; e++) 1 === B[e] && (t.disableVertexAttribArray(e), B[e] = 0);
                k = {}, F = null, rt = null, nt = {}, z = null, U = null, Q = null, J = null, L.reset(), D.reset(), R.reset()
            }
            var L = new r,
                D = new n,
                R = new o,
                I = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                O = new Uint8Array(I),
                B = new Uint8Array(I),
                N = new Uint8Array(I),
                k = {},
                F = null,
                z = null,
                U = null,
                G = null,
                V = null,
                H = null,
                j = null,
                W = null,
                Y = null,
                X = !1,
                Q = null,
                J = null,
                q = null,
                Z = null,
                K = null,
                $ = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                tt = !1,
                et = 0,
                it = t.getParameter(t.VERSION); - 1 !== it.indexOf("WebGL") ? (et = parseFloat(/^WebGL\ ([0-9])/.exec(it)[1]), tt = et >= 1) : -1 !== it.indexOf("OpenGL ES") && (et = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(it)[1]), tt = et >= 2);
            var rt = null,
                nt = {},
                ot = new h,
                at = new h,
                st = {};
            return st[t.TEXTURE_2D] = a(t.TEXTURE_2D, t.TEXTURE_2D, 1), st[t.TEXTURE_CUBE_MAP] = a(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), L.setClear(0, 0, 0, 1), D.setClear(1), R.setClear(0), p(t.DEPTH_TEST), D.setFunc(Ha), y(!1), A(la), p(t.CULL_FACE), p(t.BLEND), g(Aa), {
                buffers: {
                    color: L,
                    depth: D,
                    stencil: R
                },
                initAttributes: s,
                enableAttribute: l,
                enableAttributeAndDivisor: c,
                disableUnusedAttributes: u,
                enable: p,
                disable: f,
                getCompressedTextureFormats: d,
                useProgram: m,
                setBlending: g,
                setMaterial: v,
                setFlipSided: y,
                setCullFace: A,
                setLineWidth: x,
                setPolygonOffset: _,
                setScissorTest: w,
                activeTexture: b,
                bindTexture: M,
                compressedTexImage2D: T,
                texImage2D: S,
                scissor: E,
                viewport: C,
                reset: P
            }
        }

        function Pe(t, e, i, r, n, o, a) {
            function s(t, e) {
                if (t.width > e || t.height > e) {
                    if ("data" in t) return;
                    var i = e / Math.max(t.width, t.height),
                        r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    r.width = Math.floor(t.width * i), r.height = Math.floor(t.height * i);
                    return r.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, r.width, r.height), r
                }
                return t
            }

            function l(t) {
                return _l.isPowerOfTwo(t.width) && _l.isPowerOfTwo(t.height)
            }

            function h(t) {
                if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) {
                    void 0 === D && (D = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), D.width = _l.floorPowerOfTwo(t.width), D.height = _l.floorPowerOfTwo(t.height);
                    return D.getContext("2d").drawImage(t, 0, 0, D.width, D.height), D
                }
                return t
            }

            function u(t) {
                return t.wrapS !== cs || t.wrapT !== cs || t.minFilter !== ps && t.minFilter !== ms
            }

            function p(t, e) {
                return t.generateMipmaps && e && t.minFilter !== ps && t.minFilter !== ms
            }

            function f(e, i, n, o) {
                t.generateMipmap(e), r.get(i).__maxMipLevel = (0, c.default)(Math.max(n, o))
            }

            function d(e) {
                return e === ps || e === fs || e === ds ? t.NEAREST : t.LINEAR
            }

            function m(t) {
                var e = t.target;
                e.removeEventListener("dispose", m), v(e), e.isVideoTexture && delete I[e.id], a.memory.textures--
            }

            function g(t) {
                var e = t.target;
                e.removeEventListener("dispose", g), y(e), a.memory.textures--
            }

            function v(e) {
                var i = r.get(e);
                if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                else {
                    if (void 0 === i.__webglInit) return;
                    t.deleteTexture(i.__webglTexture)
                }
                r.remove(e)
            }

            function y(e) {
                var i = r.get(e),
                    n = r.get(e.texture);
                if (e) {
                    if (void 0 !== n.__webglTexture && t.deleteTexture(n.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                        for (var o = 0; o < 6; o++) t.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                    else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                    r.remove(e.texture), r.remove(e)
                }
            }

            function A(e, n) {
                var o = r.get(e);
                if (e.isVideoTexture && L(e), e.version > 0 && o.__version !== e.version) {
                    var a = e.image;
                    if (void 0 === a);
                    else if (!1 !== a.complete) return void b(o, e, n)
                }
                i.activeTexture(t.TEXTURE0 + n), i.bindTexture(t.TEXTURE_2D, o.__webglTexture)
            }

            function x(e, h) {
                var c = r.get(e);
                if (6 === e.image.length)
                    if (e.version > 0 && c.__version !== e.version) {
                        c.__image__webglTextureCube || (e.addEventListener("dispose", m), c.__image__webglTextureCube = t.createTexture(), a.memory.textures++), i.activeTexture(t.TEXTURE0 + h), i.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                        for (var u = e && e.isCompressedTexture, d = e.image[0] && e.image[0].isDataTexture, g = [], v = 0; v < 6; v++) g[v] = u || d ? d ? e.image[v].image : e.image[v] : s(e.image[v], n.maxCubemapSize);
                        var y = g[0],
                            A = l(y),
                            x = o.convert(e.format),
                            _ = o.convert(e.type);
                        w(t.TEXTURE_CUBE_MAP, e, A);
                        for (var v = 0; v < 6; v++)
                            if (u)
                                for (var b, M = g[v].mipmaps, T = 0, S = M.length; T < S; T++) b = M[T], e.format !== Rs && e.format !== Ds ? i.getCompressedTextureFormats().indexOf(x) > -1 && i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, T, x, b.width, b.height, 0, b.data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, T, x, b.width, b.height, 0, x, _, b.data);
                            else d ? i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, x, g[v].width, g[v].height, 0, x, _, g[v].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, x, x, _, g[v]);
                        c.__maxMipLevel = u ? M.length - 1 : 0, p(e, A) && f(t.TEXTURE_CUBE_MAP, e, y.width, y.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else i.activeTexture(t.TEXTURE0 + h), i.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
            }

            function _(e, n) {
                i.activeTexture(t.TEXTURE0 + n), i.bindTexture(t.TEXTURE_CUBE_MAP, r.get(e).__webglTexture)
            }

            function w(i, a, s) {
                var l;
                if (s ? (t.texParameteri(i, t.TEXTURE_WRAP_S, o.convert(a.wrapS)), t.texParameteri(i, t.TEXTURE_WRAP_T, o.convert(a.wrapT)), t.texParameteri(i, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS !== cs || a.wrapT, t.texParameteri(i, t.TEXTURE_MAG_FILTER, d(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, d(a.minFilter)), a.minFilter !== ps && a.minFilter), l = e.get("EXT_texture_filter_anisotropic")) {
                    if (a.type === Ms && null === e.get("OES_texture_float_linear")) return;
                    if (a.type === Ts && null === e.get("OES_texture_half_float_linear")) return;
                    (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(i, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, n.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                }
            }

            function b(e, r, c) {
                void 0 === e.__webglInit && (e.__webglInit = !0, r.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), a.memory.textures++), i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment);
                var d = s(r.image, n.maxTextureSize);
                u(r) && !1 === l(d) && (d = h(d));
                var g = l(d),
                    v = o.convert(r.format),
                    y = o.convert(r.type);
                w(t.TEXTURE_2D, r, g);
                var A, x = r.mipmaps;
                if (r.isDepthTexture) {
                    var _ = t.DEPTH_COMPONENT;
                    if (r.type === Ms) {
                        if (!R) throw new Error("Float Depth Texture only supported in WebGL2.0");
                        _ = t.DEPTH_COMPONENT32F
                    } else R && (_ = t.DEPTH_COMPONENT16);
                    r.format === Ns && _ === t.DEPTH_COMPONENT && r.type !== _s && r.type !== bs && (r.type = _s, y = o.convert(r.type)), r.format === ks && (_ = t.DEPTH_STENCIL, r.type !== Ps && (r.type = Ps, y = o.convert(r.type))), i.texImage2D(t.TEXTURE_2D, 0, _, d.width, d.height, 0, v, y, null)
                } else if (r.isDataTexture)
                    if (x.length > 0 && g) {
                        for (var b = 0, M = x.length; b < M; b++) A = x[b], i.texImage2D(t.TEXTURE_2D, b, v, A.width, A.height, 0, v, y, A.data);
                        r.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                    } else i.texImage2D(t.TEXTURE_2D, 0, v, d.width, d.height, 0, v, y, d.data), e.__maxMipLevel = 0;
                else if (r.isCompressedTexture) {
                    for (var b = 0, M = x.length; b < M; b++) A = x[b], r.format !== Rs && r.format !== Ds ? i.getCompressedTextureFormats().indexOf(v) > -1 && i.compressedTexImage2D(t.TEXTURE_2D, b, v, A.width, A.height, 0, A.data) : i.texImage2D(t.TEXTURE_2D, b, v, A.width, A.height, 0, v, y, A.data);
                    e.__maxMipLevel = x.length - 1
                } else if (x.length > 0 && g) {
                    for (var b = 0, M = x.length; b < M; b++) A = x[b], i.texImage2D(t.TEXTURE_2D, b, v, v, y, A);
                    r.generateMipmaps = !1, e.__maxMipLevel = x.length - 1
                } else i.texImage2D(t.TEXTURE_2D, 0, v, v, y, d), e.__maxMipLevel = 0;
                p(r, g) && f(t.TEXTURE_2D, r, d.width, d.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
            }

            function M(e, n, a, s) {
                var l = o.convert(n.texture.format),
                    h = o.convert(n.texture.type);
                i.texImage2D(s, 0, l, n.width, n.height, 0, l, h, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, r.get(n.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function T(e, i) {
                t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function S(e, i) {
                if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                if (t.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), A(i.depthTexture, 0);
                var n = r.get(i.depthTexture).__webglTexture;
                if (i.depthTexture.format === Ns) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, n, 0);
                else {
                    if (i.depthTexture.format !== ks) throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, n, 0)
                }
            }

            function E(e) {
                var i = r.get(e),
                    n = !0 === e.isWebGLRenderTargetCube;
                if (e.depthTexture) {
                    if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                    S(i.__webglFramebuffer, e)
                } else if (n) {
                    i.__webglDepthbuffer = [];
                    for (var o = 0; o < 6; o++) t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = t.createRenderbuffer(), T(i.__webglDepthbuffer[o], e)
                } else t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), T(i.__webglDepthbuffer, e);
                t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function C(e) {
                var n = r.get(e),
                    o = r.get(e.texture);
                e.addEventListener("dispose", g), o.__webglTexture = t.createTexture(), a.memory.textures++;
                var s = !0 === e.isWebGLRenderTargetCube,
                    h = l(e);
                if (s) {
                    n.__webglFramebuffer = [];
                    for (var c = 0; c < 6; c++) n.__webglFramebuffer[c] = t.createFramebuffer()
                } else n.__webglFramebuffer = t.createFramebuffer();
                if (s) {
                    i.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), w(t.TEXTURE_CUBE_MAP, e.texture, h);
                    for (var c = 0; c < 6; c++) M(n.__webglFramebuffer[c], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + c);
                    p(e.texture, h) && f(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), i.bindTexture(t.TEXTURE_CUBE_MAP, null)
                } else i.bindTexture(t.TEXTURE_2D, o.__webglTexture), w(t.TEXTURE_2D, e.texture, h), M(n.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), p(e.texture, h) && f(t.TEXTURE_2D, e.texture, e.width, e.height), i.bindTexture(t.TEXTURE_2D, null);
                e.depthBuffer && E(e)
            }

            function P(e) {
                var n = e.texture;
                if (p(n, l(e))) {
                    var o = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                        a = r.get(n).__webglTexture;
                    i.bindTexture(o, a), f(o, n, e.width, e.height), i.bindTexture(o, null)
                }
            }

            function L(t) {
                var e = t.id,
                    i = a.render.frame;
                I[e] !== i && (I[e] = i, t.update())
            }
            var D, R = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                I = {};
            this.setTexture2D = A, this.setTextureCube = x, this.setTextureCubeDynamic = _, this.setupRenderTarget = C, this.updateRenderTargetMipmap = P
        }

        function Le(t, e) {
            function i(i) {
                var r;
                if (i === hs) return t.REPEAT;
                if (i === cs) return t.CLAMP_TO_EDGE;
                if (i === us) return t.MIRRORED_REPEAT;
                if (i === ps) return t.NEAREST;
                if (i === fs) return t.NEAREST_MIPMAP_NEAREST;
                if (i === ds) return t.NEAREST_MIPMAP_LINEAR;
                if (i === ms) return t.LINEAR;
                if (i === gs) return t.LINEAR_MIPMAP_NEAREST;
                if (i === vs) return t.LINEAR_MIPMAP_LINEAR;
                if (i === ys) return t.UNSIGNED_BYTE;
                if (i === Ss) return t.UNSIGNED_SHORT_4_4_4_4;
                if (i === Es) return t.UNSIGNED_SHORT_5_5_5_1;
                if (i === Cs) return t.UNSIGNED_SHORT_5_6_5;
                if (i === As) return t.BYTE;
                if (i === xs) return t.SHORT;
                if (i === _s) return t.UNSIGNED_SHORT;
                if (i === ws) return t.INT;
                if (i === bs) return t.UNSIGNED_INT;
                if (i === Ms) return t.FLOAT;
                if (i === Ts && null !== (r = e.get("OES_texture_half_float"))) return r.HALF_FLOAT_OES;
                if (i === Ls) return t.ALPHA;
                if (i === Ds) return t.RGB;
                if (i === Rs) return t.RGBA;
                if (i === Is) return t.LUMINANCE;
                if (i === Os) return t.LUMINANCE_ALPHA;
                if (i === Ns) return t.DEPTH_COMPONENT;
                if (i === ks) return t.DEPTH_STENCIL;
                if (i === Ma) return t.FUNC_ADD;
                if (i === Ta) return t.FUNC_SUBTRACT;
                if (i === Sa) return t.FUNC_REVERSE_SUBTRACT;
                if (i === Pa) return t.ZERO;
                if (i === La) return t.ONE;
                if (i === Da) return t.SRC_COLOR;
                if (i === Ra) return t.ONE_MINUS_SRC_COLOR;
                if (i === Ia) return t.SRC_ALPHA;
                if (i === Oa) return t.ONE_MINUS_SRC_ALPHA;
                if (i === Ba) return t.DST_ALPHA;
                if (i === Na) return t.ONE_MINUS_DST_ALPHA;
                if (i === ka) return t.DST_COLOR;
                if (i === Fa) return t.ONE_MINUS_DST_COLOR;
                if (i === za) return t.SRC_ALPHA_SATURATE;
                if ((i === Fs || i === zs || i === Us || i === Gs) && null !== (r = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (i === Fs) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (i === zs) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (i === Us) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (i === Gs) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((i === Vs || i === Hs || i === js || i === Ws) && null !== (r = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (i === Vs) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (i === Hs) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (i === js) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (i === Ws) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (i === Ys && null !== (r = e.get("WEBGL_compressed_texture_etc1"))) return r.COMPRESSED_RGB_ETC1_WEBGL;
                if ((i === Xs || i === Qs || i === Js || i === qs || i === Zs || i === Ks || i === $s || i === tl || i === el || i === il || i === rl || i === nl || i === ol || i === al) && null !== (r = e.get("WEBGL_compressed_texture_astc"))) return i;
                if ((i === Ea || i === Ca) && null !== (r = e.get("EXT_blend_minmax"))) {
                    if (i === Ea) return r.MIN_EXT;
                    if (i === Ca) return r.MAX_EXT
                }
                return i === Ps && null !== (r = e.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : 0
            }
            return {
                convert: i
            }
        }

        function De(t, e, i, r) {
            I.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function Re(t) {
            De.call(this), this.cameras = t || []
        }

        function Ie(t) {
            function e() {
                if (null !== a && a.isPresenting) {
                    var e = a.getEyeParameters("left"),
                        r = e.renderWidth,
                        n = e.renderHeight;
                    A = t.getPixelRatio(), y = t.getSize(), t.setDrawingBufferSize(2 * r, n, 1)
                } else i.enabled && t.setDrawingBufferSize(y.width, y.height, A)
            }
            var i = this,
                a = null,
                s = null,
                l = null,
                c = new r,
                u = new r;
            "undefined" != typeof window && "VRFrameData" in window && (s = new window.VRFrameData);
            var p = new r,
                f = new n,
                d = new o,
                m = new De;
            m.bounds = new h(0, 0, .5, 1), m.layers.enable(1);
            var g = new De;
            g.bounds = new h(.5, 0, .5, 1), g.layers.enable(2);
            var v = new Re([m, g]);
            v.layers.enable(1), v.layers.enable(2);
            var y, A;
            "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", e, !1), this.enabled = !1, this.userHeight = 1.6, this.getDevice = function () {
                return a
            }, this.setDevice = function (t) {
                void 0 !== t && (a = t)
            }, this.setPoseTarget = function (t) {
                void 0 !== t && (l = t)
            }, this.getCamera = function (t) {
                if (null === a) return t;
                a.depthNear = t.near, a.depthFar = t.far, a.getFrameData(s);
                var e = a.stageParameters;
                e ? c.fromArray(e.sittingToStandingTransform) : c.makeTranslation(0, i.userHeight, 0);
                var r = s.pose,
                    n = null !== l ? l : t;
                if (n.matrix.copy(c), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== r.orientation && (f.fromArray(r.orientation), n.quaternion.multiply(f)), null !== r.position && (f.setFromRotationMatrix(c), d.fromArray(r.position), d.applyQuaternion(f), n.position.add(d)), n.updateMatrixWorld(), !1 === a.isPresenting) return t;
                m.near = t.near, g.near = t.near, m.far = t.far, g.far = t.far, v.matrixWorld.copy(t.matrixWorld), v.matrixWorldInverse.copy(t.matrixWorldInverse), m.matrixWorldInverse.fromArray(s.leftViewMatrix), g.matrixWorldInverse.fromArray(s.rightViewMatrix), u.getInverse(c), m.matrixWorldInverse.multiply(u), g.matrixWorldInverse.multiply(u);
                var o = n.parent;
                null !== o && (p.getInverse(o.matrixWorld), m.matrixWorldInverse.multiply(p), g.matrixWorldInverse.multiply(p)), m.matrixWorld.getInverse(m.matrixWorldInverse), g.matrixWorld.getInverse(g.matrixWorldInverse), m.projectionMatrix.fromArray(s.leftProjectionMatrix), g.projectionMatrix.fromArray(s.rightProjectionMatrix), v.projectionMatrix.copy(m.projectionMatrix);
                var h = a.getLayers();
                if (h.length) {
                    var y = h[0];
                    null !== y.leftBounds && 4 === y.leftBounds.length && m.bounds.fromArray(y.leftBounds), null !== y.rightBounds && 4 === y.rightBounds.length && g.bounds.fromArray(y.rightBounds)
                }
                return v
            }, this.getStandingMatrix = function () {
                return c
            }, this.submitFrame = function () {
                a && a.isPresenting && a.submitFrame()
            }, this.dispose = function () {
                "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e)
            }
        }

        function Oe(t) {
            function e() {
                return null === tt ? wt : 1
            }

            function i() {
                It = new ut(Z), It.get("WEBGL_depth_texture"), It.get("OES_texture_float"), It.get("OES_texture_float_linear"), It.get("OES_texture_half_float"), It.get("OES_texture_half_float_linear"), It.get("OES_standard_derivatives"), It.get("OES_element_index_uint"), It.get("ANGLE_instanced_arrays"), qt = new Le(Z, It), Ot = new ht(Z, It, t), Bt = new Ce(Z, It, qt), Bt.scissor(mt.copy(Mt).multiplyScalar(wt)), Bt.viewport(at.copy(bt).multiplyScalar(wt)), Nt = new dt(Z), kt = new de, Ft = new Pe(Z, It, Bt, kt, Ot, qt, Nt), zt = new E(Z), Ut = new pt(Z, zt, Nt), Gt = new vt(Ut, Nt), Yt = new gt(Z), Vt = new fe(K, It, Ot), Ht = new ye, jt = new we, Wt = new st(K, Bt, Ut, Y), Xt = new lt(Z, It, Nt), Qt = new ft(Z, It, Nt), Jt = new Ee(K, Z, Bt, Ft, Ot), Nt.programs = Vt.programs, K.context = Z, K.capabilities = Ot, K.extensions = It, K.properties = kt, K.renderLists = Ht, K.state = Bt, K.info = Nt
            }

            function n(t) {
                t.preventDefault(), $ = !0
            }

            function a() {
                $ = !1, i()
            }

            function s(t) {
                var e = t.target;
                e.removeEventListener("dispose", s), l(e)
            }

            function l(t) {
                c(t), kt.remove(t)
            }

            function c(t) {
                var e = kt.get(t).program;
                t.program = void 0, void 0 !== e && Vt.releaseProgram(e)
            }

            function u(t, e, i) {
                t.render(function (t) {
                    K.renderBufferImmediate(t, e, i)
                })
            }

            function p(t, e, i) {
                if (i && i.isInstancedBufferGeometry && null === It.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                Bt.initAttributes();
                var r = i.attributes,
                    n = e.getAttributes(),
                    o = t.defaultAttributeValues;
                for (var a in n) {
                    var s = n[a];
                    if (s >= 0) {
                        var l = r[a];
                        if (void 0 !== l) {
                            var h = l.normalized,
                                c = l.itemSize,
                                u = zt.get(l);
                            if (void 0 === u) continue;
                            var p = u.buffer,
                                f = u.type,
                                d = u.bytesPerElement;
                            if (l.isInterleavedBufferAttribute) {
                                var m = l.data,
                                    g = m.stride,
                                    v = l.offset;
                                m && m.isInstancedInterleavedBuffer ? (Bt.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : Bt.enableAttribute(s), Z.bindBuffer(Z.ARRAY_BUFFER, p), Z.vertexAttribPointer(s, c, f, h, g * d, v * d)
                            } else l.isInstancedBufferAttribute ? (Bt.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : Bt.enableAttribute(s), Z.bindBuffer(Z.ARRAY_BUFFER, p), Z.vertexAttribPointer(s, c, f, h, 0, 0)
                        } else if (void 0 !== o) {
                            var y = o[a];
                            if (void 0 !== y) switch (y.length) {
                                case 2:
                                    Z.vertexAttrib2fv(s, y);
                                    break;
                                case 3:
                                    Z.vertexAttrib3fv(s, y);
                                    break;
                                case 4:
                                    Z.vertexAttrib4fv(s, y);
                                    break;
                                default:
                                    Z.vertexAttrib1fv(s, y)
                            }
                        }
                    }
                }
                Bt.disableUnusedAttributes()
            }

            function f() {
                te || (g(), te = !0)
            }

            function d() {
                te = !1
            }

            function g() {
                var t = Zt.getDevice();
                t && t.isPresenting ? t.requestAnimationFrame(v) : window.requestAnimationFrame(v)
            }

            function v(t) {
                !1 !== te && (ee(t), g())
            }

            function y(t, e, i) {
                if (!1 !== t.visible) {
                    if (t.layers.test(e.layers))
                        if (t.isLight) q.pushLight(t), t.castShadow && q.pushShadow(t);
                        else if (t.isSprite) t.frustumCulled && !St.intersectsSprite(t) || q.pushSprite(t);
                    else if (t.isImmediateRenderObject) i && Dt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Lt), J.push(t, null, t.material, Dt.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || St.intersectsObject(t))) {
                        i && Dt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Lt);
                        var r = Gt.update(t),
                            n = t.material;
                        if (Array.isArray(n))
                            for (var o = r.groups, a = 0, s = o.length; a < s; a++) {
                                var l = o[a],
                                    h = n[l.materialIndex];
                                h && h.visible && J.push(t, r, h, Dt.z, l)
                            } else n.visible && J.push(t, r, n, Dt.z, null)
                    }
                    for (var c = t.children, a = 0, s = c.length; a < s; a++) y(c[a], e, i)
                }
            }

            function A(t, e, i, r) {
                for (var n = 0, o = t.length; n < o; n++) {
                    var a = t[n],
                        s = a.object,
                        l = a.geometry,
                        h = void 0 === r ? a.material : r,
                        c = a.group;
                    if (i.isArrayCamera) {
                        ot = i;
                        for (var u = i.cameras, p = 0, f = u.length; p < f; p++) {
                            var d = u[p];
                            if (s.layers.test(d.layers)) {
                                var m = d.bounds,
                                    g = m.x * xt,
                                    v = m.y * _t,
                                    y = m.z * xt,
                                    A = m.w * _t;
                                Bt.viewport(at.set(g, v, y, A).multiplyScalar(wt)), x(s, e, d, l, h, c)
                            }
                        }
                    } else ot = null, x(s, e, i, l, h, c)
                }
            }

            function x(t, e, i, r, n, o) {
                if (t.onBeforeRender(K, e, i, r, n, o), q = jt.get(e, ot || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    var a = t.isMesh && t.matrixWorld.determinant() < 0;
                    Bt.setMaterial(n, a);
                    var s = w(i, e.fog, n, t);
                    rt = "", u(t, s, n)
                } else K.renderBufferDirect(i, e.fog, r, n, t, o);
                t.onAfterRender(K, e, i, r, n, o), q = jt.get(e, ot || i)
            }

            function _(t, e, i) {
                var r = kt.get(t),
                    n = q.state.lights,
                    o = q.state.shadowsArray,
                    a = Vt.getParameters(t, n.state, o, e, Et.numPlanes, Et.numIntersection, i),
                    l = Vt.getProgramCode(t, a),
                    h = r.program,
                    u = !0;
                if (void 0 === h) t.addEventListener("dispose", s);
                else if (h.code !== l) c(t);
                else if (r.lightsHash !== n.state.hash) kt.update(t, "lightsHash", n.state.hash), u = !1;
                else {
                    if (void 0 !== a.shaderID) return;
                    u = !1
                }
                if (u) {
                    if (a.shaderID) {
                        var p = El[a.shaderID];
                        r.shader = {
                            name: t.type,
                            uniforms: Ml.clone(p.uniforms),
                            vertexShader: p.vertexShader,
                            fragmentShader: p.fragmentShader
                        }
                    } else r.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    t.onBeforeCompile(r.shader, K), h = Vt.acquireProgram(t, r.shader, a, l), r.program = h, t.program = h
                }
                var f = h.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (var d = 0; d < K.maxMorphTargets; d++) f["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (var d = 0; d < K.maxMorphNormals; d++) f["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
                }
                var m = r.shader.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = Et.numPlanes, r.numIntersection = Et.numIntersection, m.clippingPlanes = Et.uniform), r.fog = e, r.lightsHash = n.state.hash, t.lights && (m.ambientLightColor.value = n.state.ambient, m.directionalLights.value = n.state.directional, m.spotLights.value = n.state.spot, m.rectAreaLights.value = n.state.rectArea, m.pointLights.value = n.state.point, m.hemisphereLights.value = n.state.hemi, m.directionalShadowMap.value = n.state.directionalShadowMap, m.directionalShadowMatrix.value = n.state.directionalShadowMatrix, m.spotShadowMap.value = n.state.spotShadowMap, m.spotShadowMatrix.value = n.state.spotShadowMatrix, m.pointShadowMap.value = n.state.pointShadowMap, m.pointShadowMatrix.value = n.state.pointShadowMatrix);
                var g = r.program.getUniforms(),
                    v = Kt.seqWithValue(g.seq, m);
                r.uniformsList = v
            }

            function w(t, e, i, r) {
                At = 0;
                var n = kt.get(i),
                    o = q.state.lights;
                if (Ct && (Pt || t !== nt)) {
                    var a = t === nt && i.id === it;
                    Et.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, n, a)
                }!1 === i.needsUpdate && (void 0 === n.program ? i.needsUpdate = !0 : i.fog && n.fog !== e ? i.needsUpdate = !0 : i.lights && n.lightsHash !== o.state.hash ? i.needsUpdate = !0 : void 0 === n.numClippingPlanes || n.numClippingPlanes === Et.numPlanes && n.numIntersection === Et.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (_(i, e, r), i.needsUpdate = !1);
                var s = !1,
                    l = !1,
                    h = !1,
                    c = n.program,
                    u = c.getUniforms(),
                    p = n.shader.uniforms;
                if (Bt.useProgram(c.program) && (s = !0, l = !0, h = !0), i.id !== it && (it = i.id, l = !0), s || t !== nt) {
                    if (u.setValue(Z, "projectionMatrix", t.projectionMatrix), Ot.logarithmicDepthBuffer && u.setValue(Z, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), nt !== (ot || t) && (nt = ot || t, l = !0, h = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                        var f = u.map.cameraPosition;
                        void 0 !== f && f.setValue(Z, Dt.setFromMatrixPosition(t.matrixWorld))
                    }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && u.setValue(Z, "viewMatrix", t.matrixWorldInverse)
                }
                if (i.skinning) {
                    u.setOptional(Z, r, "bindMatrix"), u.setOptional(Z, r, "bindMatrixInverse");
                    var d = r.skeleton;
                    if (d) {
                        var g = d.bones;
                        if (Ot.floatVertexTextures) {
                            if (void 0 === d.boneTexture) {
                                var v = Math.sqrt(4 * g.length);
                                v = _l.ceilPowerOfTwo(v), v = Math.max(v, 4);
                                var y = new Float32Array(v * v * 4);
                                y.set(d.boneMatrices);
                                var A = new m(y, v, v, Rs, Ms);
                                A.needsUpdate = !0, d.boneMatrices = y, d.boneTexture = A, d.boneTextureSize = v
                            }
                            u.setValue(Z, "boneTexture", d.boneTexture), u.setValue(Z, "boneTextureSize", d.boneTextureSize)
                        } else u.setOptional(Z, d, "boneMatrices")
                    }
                }
                return l && (u.setValue(Z, "toneMappingExposure", K.toneMappingExposure), u.setValue(Z, "toneMappingWhitePoint", K.toneMappingWhitePoint), i.lights && F(p, h), e && i.fog && P(p, e), i.isMeshBasicMaterial ? M(p, i) : i.isMeshLambertMaterial ? (M(p, i), L(p, i)) : i.isMeshPhongMaterial ? (M(p, i), i.isMeshToonMaterial ? R(p, i) : D(p, i)) : i.isMeshStandardMaterial ? (M(p, i), i.isMeshPhysicalMaterial ? O(p, i) : I(p, i)) : i.isMeshDepthMaterial ? (M(p, i), B(p, i)) : i.isMeshDistanceMaterial ? (M(p, i), N(p, i)) : i.isMeshNormalMaterial ? (M(p, i), k(p, i)) : i.isLineBasicMaterial ? (T(p, i), i.isLineDashedMaterial && S(p, i)) : i.isPointsMaterial ? C(p, i) : i.isShadowMaterial && (p.color.value = i.color, p.opacity.value = i.opacity), void 0 !== p.ltc_1 && (p.ltc_1.value = Sl.LTC_1), void 0 !== p.ltc_2 && (p.ltc_2.value = Sl.LTC_2), Kt.upload(Z, n.uniformsList, p, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Kt.upload(Z, n.uniformsList, p, K), i.uniformsNeedUpdate = !1), u.setValue(Z, "modelViewMatrix", r.modelViewMatrix), u.setValue(Z, "normalMatrix", r.normalMatrix), u.setValue(Z, "modelMatrix", r.matrixWorld), c
            }

            function M(t, e) {
                t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = kt.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity);
                var i;
                if (e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i) {
                    if (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate) {
                        var r = i.offset,
                            n = i.repeat,
                            o = i.rotation,
                            a = i.center;
                        i.matrix.setUvTransform(r.x, r.y, n.x, n.y, o, a.x, a.y)
                    }
                    t.uvTransform.value.copy(i.matrix)
                }
            }

            function T(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity
            }

            function S(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }

            function C(t, e) {
                if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * wt, t.scale.value = .5 * _t, t.map.value = e.map, null !== e.map) {
                    if (!0 === e.map.matrixAutoUpdate) {
                        var i = e.map.offset,
                            r = e.map.repeat,
                            n = e.map.rotation,
                            o = e.map.center;
                        e.map.matrix.setUvTransform(i.x, i.y, r.x, r.y, n, o.x, o.y)
                    }
                    t.uvTransform.value.copy(e.map.matrix)
                }
            }

            function P(t, e) {
                t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }

            function L(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }

            function D(t, e) {
                t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function R(t, e) {
                D(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }

            function I(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }

            function O(t, e) {
                t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, I(t, e)
            }

            function B(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function N(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }

            function k(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function F(t, e) {
                t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
            }

            function z() {
                var t = At;
                return Ot.maxTextures, At += 1, t
            }
            t = t || {};
            var U = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                G = void 0 !== t.context ? t.context : null,
                V = void 0 !== t.alpha && t.alpha,
                H = void 0 === t.depth || t.depth,
                j = void 0 === t.stencil || t.stencil,
                W = void 0 !== t.antialias && t.antialias,
                Y = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                X = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                Q = void 0 !== t.powerPreference ? t.powerPreference : "default",
                J = null,
                q = null;
            this.domElement = U, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Ka, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var Z, K = this,
                $ = !1,
                tt = null,
                et = null,
                it = -1,
                rt = "",
                nt = null,
                ot = null,
                at = new h,
                mt = new h,
                yt = null,
                At = 0,
                xt = U.width,
                _t = U.height,
                wt = 1,
                bt = new h(0, 0, xt, _t),
                Mt = new h(0, 0, xt, _t),
                Tt = !1,
                St = new b,
                Et = new ct,
                Ct = !1,
                Pt = !1,
                Lt = new r,
                Dt = new o;
            try {
                var Rt = {
                    alpha: V,
                    depth: H,
                    stencil: j,
                    antialias: W,
                    premultipliedAlpha: Y,
                    preserveDrawingBuffer: X,
                    powerPreference: Q
                };
                if (U.addEventListener("webglcontextlost", n, !1), U.addEventListener("webglcontextrestored", a, !1), null === (Z = G || U.getContext("webgl", Rt) || U.getContext("experimental-webgl", Rt))) throw null !== U.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === Z.getShaderPrecisionFormat && (Z.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t.message)
            }
            var It, Ot, Bt, Nt, kt, Ft, zt, Ut, Gt, Vt, Ht, jt, Wt, Yt, Xt, Qt, Jt, qt;
            i();
            var Zt = new Ie(K);
            this.vr = Zt;
            var $t = new Te(K, Gt, Ot.maxTextureSize);
            this.shadowMap = $t, this.getContext = function () {
                return Z
            }, this.getContextAttributes = function () {
                return Z.getContextAttributes()
            }, this.forceContextLoss = function () {
                var t = It.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                var t = It.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return wt
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (wt = t, this.setSize(xt, _t, !1))
            }, this.getSize = function () {
                return {
                    width: xt,
                    height: _t
                }
            }, this.setSize = function (t, e, i) {
                var r = Zt.getDevice();
                r && r.isPresenting || (xt = t, _t = e, U.width = t * wt, U.height = e * wt, !1 !== i && (U.style.width = t + "px", U.style.height = e + "px"), this.setViewport(0, 0, t, e))
            }, this.getDrawingBufferSize = function () {
                return {
                    width: xt * wt,
                    height: _t * wt
                }
            }, this.setDrawingBufferSize = function (t, e, i) {
                xt = t, _t = e, wt = i, U.width = t * i, U.height = e * i, this.setViewport(0, 0, t, e)
            }, this.getCurrentViewport = function () {
                return at
            }, this.setViewport = function (t, e, i, r) {
                bt.set(t, _t - e - r, i, r), Bt.viewport(at.copy(bt).multiplyScalar(wt))
            }, this.setScissor = function (t, e, i, r) {
                Mt.set(t, _t - e - r, i, r), Bt.scissor(mt.copy(Mt).multiplyScalar(wt))
            }, this.setScissorTest = function (t) {
                Bt.setScissorTest(Tt = t)
            }, this.getClearColor = function () {
                return Wt.getClearColor()
            }, this.setClearColor = function () {
                Wt.setClearColor.apply(Wt, arguments)
            }, this.getClearAlpha = function () {
                return Wt.getClearAlpha()
            }, this.setClearAlpha = function () {
                Wt.setClearAlpha.apply(Wt, arguments)
            }, this.clear = function (t, e, i) {
                var r = 0;
                (void 0 === t || t) && (r |= Z.COLOR_BUFFER_BIT), (void 0 === e || e) && (r |= Z.DEPTH_BUFFER_BIT), (void 0 === i || i) && (r |= Z.STENCIL_BUFFER_BIT), Z.clear(r)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function (t, e, i, r) {
                this.setRenderTarget(t), this.clear(e, i, r)
            }, this.dispose = function () {
                U.removeEventListener("webglcontextlost", n, !1), U.removeEventListener("webglcontextrestored", a, !1), Ht.dispose(), jt.dispose(), kt.dispose(), Gt.dispose(), Zt.dispose(), d()
            }, this.renderBufferImmediate = function (t, e, i) {
                Bt.initAttributes();
                var r = kt.get(t);
                t.hasPositions && !r.position && (r.position = Z.createBuffer()), t.hasNormals && !r.normal && (r.normal = Z.createBuffer()), t.hasUvs && !r.uv && (r.uv = Z.createBuffer()), t.hasColors && !r.color && (r.color = Z.createBuffer());
                var n = e.getAttributes();
                if (t.hasPositions && (Z.bindBuffer(Z.ARRAY_BUFFER, r.position), Z.bufferData(Z.ARRAY_BUFFER, t.positionArray, Z.DYNAMIC_DRAW), Bt.enableAttribute(n.position), Z.vertexAttribPointer(n.position, 3, Z.FLOAT, !1, 0, 0)), t.hasNormals) {
                    if (Z.bindBuffer(Z.ARRAY_BUFFER, r.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
                        for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                            var s = t.normalArray,
                                l = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                                h = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                                c = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                            s[o + 0] = l, s[o + 1] = h, s[o + 2] = c, s[o + 3] = l, s[o + 4] = h, s[o + 5] = c, s[o + 6] = l, s[o + 7] = h, s[o + 8] = c
                        }
                    Z.bufferData(Z.ARRAY_BUFFER, t.normalArray, Z.DYNAMIC_DRAW), Bt.enableAttribute(n.normal), Z.vertexAttribPointer(n.normal, 3, Z.FLOAT, !1, 0, 0)
                }
                t.hasUvs && i.map && (Z.bindBuffer(Z.ARRAY_BUFFER, r.uv), Z.bufferData(Z.ARRAY_BUFFER, t.uvArray, Z.DYNAMIC_DRAW), Bt.enableAttribute(n.uv), Z.vertexAttribPointer(n.uv, 2, Z.FLOAT, !1, 0, 0)), t.hasColors && i.vertexColors !== ma && (Z.bindBuffer(Z.ARRAY_BUFFER, r.color), Z.bufferData(Z.ARRAY_BUFFER, t.colorArray, Z.DYNAMIC_DRAW), Bt.enableAttribute(n.color), Z.vertexAttribPointer(n.color, 3, Z.FLOAT, !1, 0, 0)), Bt.disableUnusedAttributes(), Z.drawArrays(Z.TRIANGLES, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function (t, i, r, n, o, a) {
                var s = o.isMesh && o.matrixWorld.determinant() < 0;
                Bt.setMaterial(n, s);
                var l = w(t, i, n, o),
                    h = r.id + "_" + l.id + "_" + (!0 === n.wireframe),
                    c = !1;
                h !== rt && (rt = h, c = !0), o.morphTargetInfluences && (Yt.update(o, r, n, l), c = !0);
                var u = r.index,
                    f = r.attributes.position,
                    d = 1;
                !0 === n.wireframe && (u = Ut.getWireframeAttribute(r), d = 2);
                var m, g = Xt;
                null !== u && (m = zt.get(u), g = Qt, g.setIndex(m)), c && (p(n, l, r), null !== u && Z.bindBuffer(Z.ELEMENT_ARRAY_BUFFER, m.buffer));
                var v = 1 / 0;
                null !== u ? v = u.count : void 0 !== f && (v = f.count);
                var y = r.drawRange.start * d,
                    A = r.drawRange.count * d,
                    x = null !== a ? a.start * d : 0,
                    _ = null !== a ? a.count * d : 1 / 0,
                    b = Math.max(y, x),
                    M = Math.min(v, y + A, x + _) - 1,
                    T = Math.max(0, M - b + 1);
                if (0 !== T) {
                    if (o.isMesh)
                        if (!0 === n.wireframe) Bt.setLineWidth(n.wireframeLinewidth * e()), g.setMode(Z.LINES);
                        else switch (o.drawMode) {
                            case hl:
                                g.setMode(Z.TRIANGLES);
                                break;
                            case cl:
                                g.setMode(Z.TRIANGLE_STRIP);
                                break;
                            case ul:
                                g.setMode(Z.TRIANGLE_FAN)
                        } else if (o.isLine) {
                            var S = n.linewidth;
                            void 0 === S && (S = 1), Bt.setLineWidth(S * e()), o.isLineSegments ? g.setMode(Z.LINES) : o.isLineLoop ? g.setMode(Z.LINE_LOOP) : g.setMode(Z.LINE_STRIP)
                        } else o.isPoints && g.setMode(Z.POINTS);
                    r && r.isInstancedBufferGeometry ? r.maxInstancedCount > 0 && g.renderInstances(r, b, T) : g.render(b, T)
                }
            }, this.compile = function (t, e) {
                q = jt.get(t, e), q.init(), t.traverse(function (t) {
                    t.isLight && (q.pushLight(t), t.castShadow && q.pushShadow(t))
                }), q.setupLights(e), t.traverse(function (e) {
                    if (e.material)
                        if (Array.isArray(e.material))
                            for (var i = 0; i < e.material.length; i++) _(e.material[i], t.fog, e);
                        else _(e.material, t.fog, e)
                })
            };
            var te = !1,
                ee = null;
            this.animate = function (t) {
                ee = t, null !== ee ? f() : d()
            }, this.render = function (t, e, i, r) {
                if (!e || !e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!$) {
                    rt = "", it = -1, nt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Zt.enabled && (e = Zt.getCamera(e)), q = jt.get(t, e), q.init(), t.onBeforeRender(K, t, e, i), Lt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), St.setFromMatrix(Lt), Pt = this.localClippingEnabled, Ct = Et.init(this.clippingPlanes, Pt, e), J = Ht.get(t, e), J.init(), y(t, e, K.sortObjects), !0 === K.sortObjects && J.sort(), Ct && Et.beginShadows();
                    var n = q.state.shadowsArray;
                    $t.render(n, t, e), q.setupLights(e), Ct && Et.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), Wt.render(J, t, e, r);
                    var o = J.opaque,
                        a = J.transparent;
                    if (t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        o.length && A(o, t, e, s), a.length && A(a, t, e, s)
                    } else o.length && A(o, t, e), a.length && A(a, t, e);
                    var l = q.state.spritesArray;
                    Jt.render(l, t, e), i && Ft.updateRenderTargetMipmap(i), Bt.buffers.depth.setTest(!0), Bt.buffers.depth.setMask(!0), Bt.buffers.color.setMask(!0), Bt.setPolygonOffset(!1), t.onAfterRender(K, t, e), Zt.enabled && Zt.submitFrame(), J = null, q = null
                }
            }, this.allocTextureUnit = z, this.setTexture2D = function () {
                var t = !1;
                return function (e, i) {
                    e && e.isWebGLRenderTarget && (t || (t = !0), e = e.texture), Ft.setTexture2D(e, i)
                }
            }(), this.setTexture = function () {
                var t = !1;
                return function (e, i) {
                    t || (t = !0), Ft.setTexture2D(e, i)
                }
            }(), this.setTextureCube = function () {
                var t = !1;
                return function (e, i) {
                    e && e.isWebGLRenderTargetCube && (t || (t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Ft.setTextureCube(e, i) : Ft.setTextureCubeDynamic(e, i)
                }
            }(), this.getRenderTarget = function () {
                return tt
            }, this.setRenderTarget = function (t) {
                tt = t, t && void 0 === kt.get(t).__webglFramebuffer && Ft.setupRenderTarget(t);
                var e = null,
                    i = !1;
                if (t) {
                    var r = kt.get(t).__webglFramebuffer;
                    t.isWebGLRenderTargetCube ? (e = r[t.activeCubeFace], i = !0) : e = r, at.copy(t.viewport), mt.copy(t.scissor), yt = t.scissorTest
                } else at.copy(bt).multiplyScalar(wt), mt.copy(Mt).multiplyScalar(wt), yt = Tt;
                if (et !== e && (Z.bindFramebuffer(Z.FRAMEBUFFER, e), et = e), Bt.viewport(at), Bt.scissor(mt), Bt.setScissorTest(yt), i) {
                    var n = kt.get(t.texture);
                    Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, n.__webglTexture, t.activeMipMapLevel)
                }
            }, this.readRenderTargetPixels = function (t, e, i, r, n, o) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                var a = kt.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== et && (Z.bindFramebuffer(Z.FRAMEBUFFER, a), s = !0);
                    try {
                        var l = t.texture,
                            h = l.format,
                            c = l.type;
                        if (h !== Rs && qt.convert(h) !== Z.getParameter(Z.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(c === ys || qt.convert(c) === Z.getParameter(Z.IMPLEMENTATION_COLOR_READ_TYPE) || c === Ms && (It.get("OES_texture_float") || It.get("WEBGL_color_buffer_float")) || c === Ts && It.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        Z.checkFramebufferStatus(Z.FRAMEBUFFER) === Z.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - r && i >= 0 && i <= t.height - n && Z.readPixels(e, i, r, n, qt.convert(h), qt.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && Z.bindFramebuffer(Z.FRAMEBUFFER, et)
                    }
                }
            }, this.copyFramebufferToTexture = function (t, e, i) {
                var r = e.image.width,
                    n = e.image.height,
                    o = qt.convert(e.format);
                this.setTexture2D(e, 0), Z.copyTexImage2D(Z.TEXTURE_2D, i || 0, o, t.x, t.y, r, n, 0)
            }, this.copyTextureToTexture = function (t, e, i, r) {
                var n = e.image.width,
                    o = e.image.height,
                    a = qt.convert(i.format),
                    s = qt.convert(i.type),
                    l = e.isDataTexture ? e.image.data : e.image;
                this.setTexture2D(i, 0), Z.texSubImage2D(Z.TEXTURE_2D, r || 0, t.x, t.y, n, o, a, s, l)
            }
        }

        function Be(t, e) {
            this.name = "", this.color = new T(t), this.density = void 0 !== e ? e : 25e-5
        }

        function Ne(t, e, i) {
            this.name = "", this.color = new T(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function ke() {
            R.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
        }

        function Fe(t) {
            tt.call(this), this.type = "SpriteMaterial", this.color = new T(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function ze(t) {
            R.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new Fe, this.center = new i(.5, .5)
        }

        function Ue() {
            R.call(this), this.type = "LOD", (0, x.default)(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            })
        }

        function Ge(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else {
                this.boneInverses = [];
                for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new r)
            }
        }

        function Ve() {
            R.call(this), this.type = "Bone"
        }

        function He(t, e) {
            at.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new r, this.bindMatrixInverse = new r;
            var i = this.initBones(),
                n = new Ge(i);
            this.bind(n, this.matrixWorld), this.normalizeSkinWeights()
        }

        function je(t) {
            tt.call(this), this.type = "LineBasicMaterial", this.color = new T(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
        }

        function We(t, e, i) {
            if (1 === i) return new Ye(t, e);
            R.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new J, this.material = void 0 !== e ? e : new je({
                color: 16777215 * Math.random()
            })
        }

        function Ye(t, e) {
            We.call(this, t, e), this.type = "LineSegments"
        }

        function Xe(t, e) {
            We.call(this, t, e), this.type = "LineLoop"
        }

        function Qe(t) {
            tt.call(this), this.type = "PointsMaterial", this.color = new T(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
        }

        function Je(t, e) {
            R.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new J, this.material = void 0 !== e ? e : new Qe({
                color: 16777215 * Math.random()
            })
        }

        function qe() {
            R.call(this), this.type = "Group"
        }

        function Ze(t, e, i, r, n, o, a, l, h) {
            s.call(this, t, e, i, r, n, o, a, l, h), this.generateMipmaps = !1
        }

        function Ke(t, e, i, r, n, o, a, l, h, c, u, p) {
            s.call(this, null, o, a, l, h, c, r, n, u, p), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function $e(t, e, i, r, n, o, a, l, h, c) {
            if ((c = void 0 !== c ? c : Ns) !== Ns && c !== ks) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && c === Ns && (i = _s), void 0 === i && c === ks && (i = Ps), s.call(this, null, r, n, o, a, l, c, i, h), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : ps, this.minFilter = void 0 !== l ? l : ps, this.flipY = !1, this.generateMipmaps = !1
        }

        function ti(t) {
            J.call(this), this.type = "WireframeGeometry";
            var e, i, r, n, a, s, l, h, c, u, p = [],
                f = [0, 0],
                d = {},
                m = ["a", "b", "c"];
            if (t && t.isGeometry) {
                var g = t.faces;
                for (e = 0, r = g.length; e < r; e++) {
                    var v = g[e];
                    for (i = 0; i < 3; i++) l = v[m[i]], h = v[m[(i + 1) % 3]], f[0] = Math.min(l, h), f[1] = Math.max(l, h), c = f[0] + "," + f[1], void 0 === d[c] && (d[c] = {
                        index1: f[0],
                        index2: f[1]
                    })
                }
                for (c in d) s = d[c], u = t.vertices[s.index1], p.push(u.x, u.y, u.z), u = t.vertices[s.index2], p.push(u.x, u.y, u.z)
            } else if (t && t.isBufferGeometry) {
                var y, A, x, _, w, b, M, T;
                if (u = new o, null !== t.index) {
                    for (y = t.attributes.position, A = t.index, x = t.groups, 0 === x.length && (x = [{
                            start: 0,
                            count: A.count,
                            materialIndex: 0
                        }]), n = 0, a = x.length; n < a; ++n)
                        for (_ = x[n], w = _.start, b = _.count, e = w, r = w + b; e < r; e += 3)
                            for (i = 0; i < 3; i++) l = A.getX(e + i), h = A.getX(e + (i + 1) % 3), f[0] = Math.min(l, h), f[1] = Math.max(l, h), c = f[0] + "," + f[1], void 0 === d[c] && (d[c] = {
                                index1: f[0],
                                index2: f[1]
                            });
                    for (c in d) s = d[c], u.fromBufferAttribute(y, s.index1), p.push(u.x, u.y, u.z), u.fromBufferAttribute(y, s.index2), p.push(u.x, u.y, u.z)
                } else
                    for (y = t.attributes.position, e = 0, r = y.count / 3; e < r; e++)
                        for (i = 0; i < 3; i++) M = 3 * e + i, u.fromBufferAttribute(y, M), p.push(u.x, u.y, u.z), T = 3 * e + (i + 1) % 3, u.fromBufferAttribute(y, T), p.push(u.x, u.y, u.z)
            }
            this.addAttribute("position", new W(p, 3))
        }

        function ei(t, e, i) {
            N.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new ii(t, e, i)), this.mergeVertices()
        }

        function ii(t, e, i) {
            J.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            var r, n, a = [],
                s = [],
                l = [],
                h = [],
                c = new o,
                u = new o,
                p = new o,
                f = new o,
                d = new o,
                m = e + 1;
            for (r = 0; r <= i; r++) {
                var g = r / i;
                for (n = 0; n <= e; n++) {
                    var v = n / e;
                    t(v, g, u), s.push(u.x, u.y, u.z), v - 1e-5 >= 0 ? (t(v - 1e-5, g, p), f.subVectors(u, p)) : (t(v + 1e-5, g, p), f.subVectors(p, u)), g - 1e-5 >= 0 ? (t(v, g - 1e-5, p), d.subVectors(u, p)) : (t(v, g + 1e-5, p), d.subVectors(p, u)), c.crossVectors(f, d).normalize(), l.push(c.x, c.y, c.z), h.push(v, g)
                }
            }
            for (r = 0; r < i; r++)
                for (n = 0; n < e; n++) {
                    var y = r * m + n,
                        A = r * m + n + 1,
                        x = (r + 1) * m + n + 1,
                        _ = (r + 1) * m + n;
                    a.push(y, A, _), a.push(A, x, _)
                }
            this.setIndex(a), this.addAttribute("position", new W(s, 3)), this.addAttribute("normal", new W(l, 3)), this.addAttribute("uv", new W(h, 2))
        }

        function ri(t, e, i, r) {
            N.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: r
            }, this.fromBufferGeometry(new ni(t, e, i, r)), this.mergeVertices()
        }

        function ni(t, e, r, n) {
            function a(t, e, i, r) {
                var n, o, a = Math.pow(2, r),
                    s = [];
                for (n = 0; n <= a; n++) {
                    s[n] = [];
                    var h = t.clone().lerp(i, n / a),
                        c = e.clone().lerp(i, n / a),
                        u = a - n;
                    for (o = 0; o <= u; o++) s[n][o] = 0 === o && n === a ? h : h.clone().lerp(c, o / u)
                }
                for (n = 0; n < a; n++)
                    for (o = 0; o < 2 * (a - n) - 1; o++) {
                        var p = Math.floor(o / 2);
                        o % 2 == 0 ? (l(s[n][p + 1]), l(s[n + 1][p]), l(s[n][p])) : (l(s[n][p + 1]), l(s[n + 1][p + 1]), l(s[n + 1][p]))
                    }
            }

            function s() {
                for (var t = 0; t < m.length; t += 6) {
                    var e = m[t + 0],
                        i = m[t + 2],
                        r = m[t + 4],
                        n = Math.max(e, i, r),
                        o = Math.min(e, i, r);
                    n > .9 && o < .1 && (e < .2 && (m[t + 0] += 1), i < .2 && (m[t + 2] += 1), r < .2 && (m[t + 4] += 1))
                }
            }

            function l(t) {
                d.push(t.x, t.y, t.z)
            }

            function h(e, i) {
                var r = 3 * e;
                i.x = t[r + 0], i.y = t[r + 1], i.z = t[r + 2]
            }

            function c() {
                for (var t = new o, e = new o, r = new o, n = new o, a = new i, s = new i, l = new i, h = 0, c = 0; h < d.length; h += 9, c += 6) {
                    t.set(d[h + 0], d[h + 1], d[h + 2]), e.set(d[h + 3], d[h + 4], d[h + 5]), r.set(d[h + 6], d[h + 7], d[h + 8]), a.set(m[c + 0], m[c + 1]), s.set(m[c + 2], m[c + 3]), l.set(m[c + 4], m[c + 5]), n.copy(t).add(e).add(r).divideScalar(3);
                    var f = p(n);
                    u(a, c + 0, t, f), u(s, c + 2, e, f), u(l, c + 4, r, f)
                }
            }

            function u(t, e, i, r) {
                r < 0 && 1 === t.x && (m[e] = t.x - 1), 0 === i.x && 0 === i.z && (m[e] = r / 2 / Math.PI + .5)
            }

            function p(t) {
                return Math.atan2(t.z, -t.x)
            }

            function f(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }
            J.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: r,
                detail: n
            }, r = r || 1, n = n || 0;
            var d = [],
                m = [];
            ! function (t) {
                for (var i = new o, r = new o, n = new o, s = 0; s < e.length; s += 3) h(e[s + 0], i), h(e[s + 1], r), h(e[s + 2], n), a(i, r, n, t)
            }(n),
            function (t) {
                for (var e = new o, i = 0; i < d.length; i += 3) e.x = d[i + 0], e.y = d[i + 1], e.z = d[i + 2], e.normalize().multiplyScalar(t), d[i + 0] = e.x, d[i + 1] = e.y, d[i + 2] = e.z
            }(r),
            function () {
                for (var t = new o, e = 0; e < d.length; e += 3) {
                    t.x = d[e + 0], t.y = d[e + 1], t.z = d[e + 2];
                    var i = p(t) / 2 / Math.PI + .5,
                        r = f(t) / Math.PI + .5;
                    m.push(i, 1 - r)
                }
                c(), s()
            }(), this.addAttribute("position", new W(d, 3)), this.addAttribute("normal", new W(d.slice(), 3)), this.addAttribute("uv", new W(m, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function oi(t, e) {
            N.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new ai(t, e)), this.mergeVertices()
        }

        function ai(t, e) {
            var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            ni.call(this, i, r, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function si(t, e) {
            N.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new li(t, e)), this.mergeVertices()
        }

        function li(t, e) {
            var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            ni.call(this, i, r, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function hi(t, e) {
            N.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new ci(t, e)), this.mergeVertices()
        }

        function ci(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
                n = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            ni.call(this, r, n, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function ui(t, e) {
            N.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new pi(t, e)), this.mergeVertices()
        }

        function pi(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                r = 1 / i,
                n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r],
                o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            ni.call(this, n, o, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function fi(t, e, i, r, n, o) {
            N.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: r,
                closed: n
            }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
            var a = new di(t, e, i, r, n);
            this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
        }

        function di(t, e, r, n, a) {
            function s(i) {
                g = t.getPointAt(i / e, g);
                var o = c.normals[i],
                    a = c.binormals[i];
                for (p = 0; p <= n; p++) {
                    var s = p / n * Math.PI * 2,
                        l = Math.sin(s),
                        h = -Math.cos(s);
                    d.x = h * o.x + l * a.x, d.y = h * o.y + l * a.y, d.z = h * o.z + l * a.z, d.normalize(), y.push(d.x, d.y, d.z), f.x = g.x + r * d.x, f.y = g.y + r * d.y, f.z = g.z + r * d.z, v.push(f.x, f.y, f.z)
                }
            }

            function l() {
                for (p = 1; p <= e; p++)
                    for (u = 1; u <= n; u++) {
                        var t = (n + 1) * (p - 1) + (u - 1),
                            i = (n + 1) * p + (u - 1),
                            r = (n + 1) * p + u,
                            o = (n + 1) * (p - 1) + u;
                        x.push(t, i, o), x.push(i, r, o)
                    }
            }

            function h() {
                for (u = 0; u <= e; u++)
                    for (p = 0; p <= n; p++) m.x = u / e, m.y = p / n, A.push(m.x, m.y)
            }
            J.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: r,
                radialSegments: n,
                closed: a
            }, e = e || 64, r = r || 1, n = n || 8, a = a || !1;
            var c = t.computeFrenetFrames(e, a);
            this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
            var u, p, f = new o,
                d = new o,
                m = new i,
                g = new o,
                v = [],
                y = [],
                A = [],
                x = [];
            ! function () {
                for (u = 0; u < e; u++) s(u);
                s(!1 === a ? e : 0), h(), l()
            }(), this.setIndex(x), this.addAttribute("position", new W(v, 3)), this.addAttribute("normal", new W(y, 3)), this.addAttribute("uv", new W(A, 2))
        }

        function mi(t, e, i, r, n, o, a) {
            N.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: r,
                p: n,
                q: o
            }, void 0 !== a && this.fromBufferGeometry(new gi(t, e, i, r, n, o)), this.mergeVertices()
        }

        function gi(t, e, i, r, n, a) {
            function s(t, e, i, r, n) {
                var o = Math.cos(t),
                    a = Math.sin(t),
                    s = i / e * t,
                    l = Math.cos(s);
                n.x = r * (2 + l) * .5 * o, n.y = r * (2 + l) * a * .5, n.z = r * Math.sin(s) * .5
            }
            J.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: r,
                p: n,
                q: a
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, r = Math.floor(r) || 8, n = n || 2, a = a || 3;
            var l, h, c = [],
                u = [],
                p = [],
                f = [],
                d = new o,
                m = new o,
                g = new o,
                v = new o,
                y = new o,
                A = new o,
                x = new o;
            for (l = 0; l <= i; ++l) {
                var _ = l / i * n * Math.PI * 2;
                for (s(_, n, a, t, g), s(_ + .01, n, a, t, v), A.subVectors(v, g), x.addVectors(v, g), y.crossVectors(A, x), x.crossVectors(y, A), y.normalize(), x.normalize(), h = 0; h <= r; ++h) {
                    var w = h / r * Math.PI * 2,
                        b = -e * Math.cos(w),
                        M = e * Math.sin(w);
                    d.x = g.x + (b * x.x + M * y.x), d.y = g.y + (b * x.y + M * y.y), d.z = g.z + (b * x.z + M * y.z), u.push(d.x, d.y, d.z), m.subVectors(d, g).normalize(), p.push(m.x, m.y, m.z), f.push(l / i), f.push(h / r)
                }
            }
            for (h = 1; h <= i; h++)
                for (l = 1; l <= r; l++) {
                    var T = (r + 1) * (h - 1) + (l - 1),
                        S = (r + 1) * h + (l - 1),
                        E = (r + 1) * h + l,
                        C = (r + 1) * (h - 1) + l;
                    c.push(T, S, C), c.push(S, E, C)
                }
            this.setIndex(c), this.addAttribute("position", new W(u, 3)), this.addAttribute("normal", new W(p, 3)), this.addAttribute("uv", new W(f, 2))
        }

        function vi(t, e, i, r, n) {
            N.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: r,
                arc: n
            }, this.fromBufferGeometry(new yi(t, e, i, r, n)), this.mergeVertices()
        }

        function yi(t, e, i, r, n) {
            J.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: r,
                arc: n
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, r = Math.floor(r) || 6, n = n || 2 * Math.PI;
            var a, s, l = [],
                h = [],
                c = [],
                u = [],
                p = new o,
                f = new o,
                d = new o;
            for (a = 0; a <= i; a++)
                for (s = 0; s <= r; s++) {
                    var m = s / r * n,
                        g = a / i * Math.PI * 2;
                    f.x = (t + e * Math.cos(g)) * Math.cos(m), f.y = (t + e * Math.cos(g)) * Math.sin(m), f.z = e * Math.sin(g), h.push(f.x, f.y, f.z), p.x = t * Math.cos(m), p.y = t * Math.sin(m), d.subVectors(f, p).normalize(), c.push(d.x, d.y, d.z), u.push(s / r), u.push(a / i)
                }
            for (a = 1; a <= i; a++)
                for (s = 1; s <= r; s++) {
                    var v = (r + 1) * a + s - 1,
                        y = (r + 1) * (a - 1) + s - 1,
                        A = (r + 1) * (a - 1) + s,
                        x = (r + 1) * a + s;
                    l.push(v, y, x), l.push(y, A, x)
                }
            this.setIndex(l), this.addAttribute("position", new W(h, 3)), this.addAttribute("normal", new W(c, 3)), this.addAttribute("uv", new W(u, 2))
        }

        function Ai(t, e, i, r, n) {
            var o, a;
            if (n === Yi(t, e, i, r) > 0)
                for (o = e; o < i; o += r) a = Hi(o, t[o], t[o + 1], a);
            else
                for (o = i - r; o >= e; o -= r) a = Hi(o, t[o], t[o + 1], a);
            return a && ki(a, a.next) && (ji(a), a = a.next), a
        }

        function xi(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, r = t;
            do {
                if (i = !1, r.steiner || !ki(r, r.next) && 0 !== Ni(r.prev, r, r.next)) r = r.next;
                else {
                    if (ji(r), (r = e = r.prev) === r.next) break;
                    i = !0
                }
            } while (i || r !== e);
            return e
        }

        function _i(t, e, i, r, n, o, a) {
            if (t) {
                !a && o && Li(t, r, n, o);
                for (var s, l, h = t; t.prev !== t.next;)
                    if (s = t.prev, l = t.next, o ? bi(t, r, n, o) : wi(t)) e.push(s.i / i), e.push(t.i / i), e.push(l.i / i), ji(t), t = l.next, h = l.next;
                    else if ((t = l) === h) {
                    a ? 1 === a ? (t = Mi(t, e, i), _i(t, e, i, r, n, o, 2)) : 2 === a && Ti(t, e, i, r, n, o) : _i(xi(t), e, i, r, n, o, 1);
                    break
                }
            }
        }

        function wi(t) {
            var e = t.prev,
                i = t,
                r = t.next;
            if (Ni(e, i, r) >= 0) return !1;
            for (var n = t.next.next; n !== t.prev;) {
                if (Oi(e.x, e.y, i.x, i.y, r.x, r.y, n.x, n.y) && Ni(n.prev, n, n.next) >= 0) return !1;
                n = n.next
            }
            return !0
        }

        function bi(t, e, i, r) {
            var n = t.prev,
                o = t,
                a = t.next;
            if (Ni(n, o, a) >= 0) return !1;
            for (var s = n.x < o.x ? n.x < a.x ? n.x : a.x : o.x < a.x ? o.x : a.x, l = n.y < o.y ? n.y < a.y ? n.y : a.y : o.y < a.y ? o.y : a.y, h = n.x > o.x ? n.x > a.x ? n.x : a.x : o.x > a.x ? o.x : a.x, c = n.y > o.y ? n.y > a.y ? n.y : a.y : o.y > a.y ? o.y : a.y, u = Ri(s, l, e, i, r), p = Ri(h, c, e, i, r), f = t.nextZ; f && f.z <= p;) {
                if (f !== t.prev && f !== t.next && Oi(n.x, n.y, o.x, o.y, a.x, a.y, f.x, f.y) && Ni(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (f = t.prevZ; f && f.z >= u;) {
                if (f !== t.prev && f !== t.next && Oi(n.x, n.y, o.x, o.y, a.x, a.y, f.x, f.y) && Ni(f.prev, f, f.next) >= 0) return !1;
                f = f.prevZ
            }
            return !0
        }

        function Mi(t, e, i) {
            var r = t;
            do {
                var n = r.prev,
                    o = r.next.next;
                !ki(n, o) && Fi(n, r, r.next, o) && Ui(n, o) && Ui(o, n) && (e.push(n.i / i), e.push(r.i / i), e.push(o.i / i), ji(r), ji(r.next), r = t = o), r = r.next
            } while (r !== t);
            return r
        }

        function Ti(t, e, i, r, n, o) {
            var a = t;
            do {
                for (var s = a.next.next; s !== a.prev;) {
                    if (a.i !== s.i && Bi(a, s)) {
                        var l = Vi(a, s);
                        return a = xi(a, a.next), l = xi(l, l.next), _i(a, e, i, r, n, o), void _i(l, e, i, r, n, o)
                    }
                    s = s.next
                }
                a = a.next
            } while (a !== t)
        }

        function Si(t, e, i, r) {
            var n, o, a, s, l, h = [];
            for (n = 0, o = e.length; n < o; n++) a = e[n] * r, s = n < o - 1 ? e[n + 1] * r : t.length, l = Ai(t, a, s, r, !1), l === l.next && (l.steiner = !0), h.push(Ii(l));
            for (h.sort(Ei), n = 0; n < h.length; n++) Ci(h[n], i), i = xi(i, i.next);
            return i
        }

        function Ei(t, e) {
            return t.x - e.x
        }

        function Ci(t, e) {
            if (e = Pi(t, e)) {
                var i = Vi(e, t);
                xi(i, i.next)
            }
        }

        function Pi(t, e) {
            var i, r = e,
                n = t.x,
                o = t.y,
                a = -1 / 0;
            do {
                if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                    var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                    if (s <= n && s > a) {
                        if (a = s, s === n) {
                            if (o === r.y) return r;
                            if (o === r.next.y) return r.next
                        }
                        i = r.x < r.next.x ? r : r.next
                    }
                }
                r = r.next
            } while (r !== e);
            if (!i) return null;
            if (n === a) return i.prev;
            var l, h = i,
                c = i.x,
                u = i.y,
                p = 1 / 0;
            for (r = i.next; r !== h;) n >= r.x && r.x >= c && n !== r.x && Oi(o < u ? n : a, o, c, u, o < u ? a : n, o, r.x, r.y) && ((l = Math.abs(o - r.y) / (n - r.x)) < p || l === p && r.x > i.x) && Ui(r, t) && (i = r, p = l), r = r.next;
            return i
        }

        function Li(t, e, i, r) {
            var n = t;
            do {
                null === n.z && (n.z = Ri(n.x, n.y, e, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next
            } while (n !== t);
            n.prevZ.nextZ = null, n.prevZ = null, Di(n)
        }

        function Di(t) {
            var e, i, r, n, o, a, s, l, h = 1;
            do {
                for (i = t, t = null, o = null, a = 0; i;) {
                    for (a++, r = i, s = 0, e = 0; e < h && (s++, r = r.nextZ); e++);
                    for (l = h; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || i.z <= r.z) ? (n = i, i = i.nextZ, s--) : (n = r, r = r.nextZ, l--), o ? o.nextZ = n : t = n, n.prevZ = o, o = n;
                    i = r
                }
                o.nextZ = null, h *= 2
            } while (a > 1);
            return t
        }

        function Ri(t, e, i, r, n) {
            return t = 32767 * (t - i) * n, e = 32767 * (e - r) * n, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
        }

        function Ii(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }

        function Oi(t, e, i, r, n, o, a, s) {
            return (n - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (i - a) * (e - s) >= 0 && (i - a) * (o - s) - (n - a) * (r - s) >= 0
        }

        function Bi(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !zi(t, e) && Ui(t, e) && Ui(e, t) && Gi(t, e)
        }

        function Ni(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }

        function ki(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function Fi(t, e, i, r) {
            return !!(ki(t, e) && ki(i, r) || ki(t, r) && ki(i, e)) || Ni(t, e, i) > 0 != Ni(t, e, r) > 0 && Ni(i, r, t) > 0 != Ni(i, r, e) > 0
        }

        function zi(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && Fi(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }

        function Ui(t, e) {
            return Ni(t.prev, t, t.next) < 0 ? Ni(t, e, t.next) >= 0 && Ni(t, t.prev, e) >= 0 : Ni(t, e, t.prev) < 0 || Ni(t, t.next, e) < 0
        }

        function Gi(t, e) {
            var i = t,
                r = !1,
                n = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
            do {
                i.y > o != i.next.y > o && i.next.y !== i.y && n < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next
            } while (i !== t);
            return r
        }

        function Vi(t, e) {
            var i = new Wi(t.i, t.x, t.y),
                r = new Wi(e.i, e.x, e.y),
                n = t.next,
                o = e.prev;
            return t.next = e, e.prev = t, i.next = n, n.prev = i, r.next = i, i.prev = r, o.next = r, r.prev = o, r
        }

        function Hi(t, e, i, r) {
            var n = new Wi(t, e, i);
            return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n
        }

        function ji(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function Wi(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        function Yi(t, e, i, r) {
            for (var n = 0, o = e, a = i - r; o < i; o += r) n += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
            return n
        }

        function Xi(t) {
            var e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }

        function Qi(t, e) {
            for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }

        function Ji(t, e) {
            N.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new qi(t, e)), this.mergeVertices()
        }

        function qi(t, e) {
            void 0 !== t && (J.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
        }

        function Zi(t, e) {
            N.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new Ki(t, e)), this.mergeVertices()
        }

        function Ki(t, e) {
            e = e || {};
            var i = e.font;
            if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new N;
            var r = i.generateShapes(t, e.size, e.curveSegments);
            e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), qi.call(this, r, e), this.type = "TextBufferGeometry"
        }

        function $i(t, e, i, r, n, o, a) {
            N.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: r,
                phiLength: n,
                thetaStart: o,
                thetaLength: a
            }, this.fromBufferGeometry(new tr(t, e, i, r, n, o, a)), this.mergeVertices()
        }

        function tr(t, e, i, r, n, a, s) {
            J.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: r,
                phiLength: n,
                thetaStart: a,
                thetaLength: s
            }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
            var l, h, c = a + s,
                u = 0,
                p = [],
                f = new o,
                d = new o,
                m = [],
                g = [],
                v = [],
                y = [];
            for (h = 0; h <= i; h++) {
                var A = [],
                    x = h / i;
                for (l = 0; l <= e; l++) {
                    var _ = l / e;
                    f.x = -t * Math.cos(r + _ * n) * Math.sin(a + x * s), f.y = t * Math.cos(a + x * s), f.z = t * Math.sin(r + _ * n) * Math.sin(a + x * s), g.push(f.x, f.y, f.z), d.set(f.x, f.y, f.z).normalize(), v.push(d.x, d.y, d.z), y.push(_, 1 - x), A.push(u++)
                }
                p.push(A)
            }
            for (h = 0; h < i; h++)
                for (l = 0; l < e; l++) {
                    var w = p[h][l + 1],
                        b = p[h][l],
                        M = p[h + 1][l],
                        T = p[h + 1][l + 1];
                    (0 !== h || a > 0) && m.push(w, b, T), (h !== i - 1 || c < Math.PI) && m.push(b, M, T)
                }
            this.setIndex(m), this.addAttribute("position", new W(g, 3)), this.addAttribute("normal", new W(v, 3)), this.addAttribute("uv", new W(y, 2))
        }

        function er(t, e, i, r, n, o) {
            N.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: r,
                thetaStart: n,
                thetaLength: o
            }, this.fromBufferGeometry(new ir(t, e, i, r, n, o)), this.mergeVertices()
        }

        function ir(t, e, r, n, a, s) {
            J.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: r,
                phiSegments: n,
                thetaStart: a,
                thetaLength: s
            }, t = t || .5, e = e || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, r = void 0 !== r ? Math.max(3, r) : 8, n = void 0 !== n ? Math.max(1, n) : 1;
            var l, h, c, u = [],
                p = [],
                f = [],
                d = [],
                m = t,
                g = (e - t) / n,
                v = new o,
                y = new i;
            for (h = 0; h <= n; h++) {
                for (c = 0; c <= r; c++) l = a + c / r * s, v.x = m * Math.cos(l), v.y = m * Math.sin(l), p.push(v.x, v.y, v.z), f.push(0, 0, 1), y.x = (v.x / e + 1) / 2, y.y = (v.y / e + 1) / 2, d.push(y.x, y.y);
                m += g
            }
            for (h = 0; h < n; h++) {
                var A = h * (r + 1);
                for (c = 0; c < r; c++) {
                    l = c + A;
                    var x = l,
                        _ = l + r + 1,
                        w = l + r + 2,
                        b = l + 1;
                    u.push(x, _, b), u.push(_, w, b)
                }
            }
            this.setIndex(u), this.addAttribute("position", new W(p, 3)), this.addAttribute("normal", new W(f, 3)), this.addAttribute("uv", new W(d, 2))
        }

        function rr(t, e, i, r) {
            N.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: r
            }, this.fromBufferGeometry(new nr(t, e, i, r)), this.mergeVertices()
        }

        function nr(t, e, r, n) {
            J.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: r,
                phiLength: n
            }, e = Math.floor(e) || 12, r = r || 0, n = n || 2 * Math.PI, n = _l.clamp(n, 0, 2 * Math.PI);
            var a, s, l, h = [],
                c = [],
                u = [],
                p = 1 / e,
                f = new o,
                d = new i;
            for (s = 0; s <= e; s++) {
                var m = r + s * p * n,
                    g = Math.sin(m),
                    v = Math.cos(m);
                for (l = 0; l <= t.length - 1; l++) f.x = t[l].x * g, f.y = t[l].y, f.z = t[l].x * v, c.push(f.x, f.y, f.z), d.x = s / e, d.y = l / (t.length - 1), u.push(d.x, d.y)
            }
            for (s = 0; s < e; s++)
                for (l = 0; l < t.length - 1; l++) {
                    a = l + s * t.length;
                    var y = a,
                        A = a + t.length,
                        x = a + t.length + 1,
                        _ = a + 1;
                    h.push(y, A, _), h.push(A, x, _)
                }
            if (this.setIndex(h), this.addAttribute("position", new W(c, 3)), this.addAttribute("uv", new W(u, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
                var w = this.attributes.normal.array,
                    b = new o,
                    M = new o,
                    T = new o;
                for (a = e * t.length * 3, s = 0, l = 0; s < t.length; s++, l += 3) b.x = w[l + 0], b.y = w[l + 1], b.z = w[l + 2], M.x = w[a + l + 0], M.y = w[a + l + 1], M.z = w[a + l + 2], T.addVectors(b, M).normalize(), w[l + 0] = w[a + l + 0] = T.x, w[l + 1] = w[a + l + 1] = T.y, w[l + 2] = w[a + l + 2] = T.z
            }
        }

        function or(t, e) {
            N.call(this), this.type = "ShapeGeometry", "object" === (void 0 === e ? "undefined" : (0, L.default)(e)) && (e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new ar(t, e)), this.mergeVertices()
        }

        function ar(t, e) {
            function i(t) {
                var i, s, h, c = n.length / 3,
                    u = t.extractPoints(e),
                    p = u.shape,
                    f = u.holes;
                if (!1 === Vl.isClockWise(p))
                    for (p = p.reverse(), i = 0, s = f.length; i < s; i++) h = f[i], !0 === Vl.isClockWise(h) && (f[i] = h.reverse());
                var d = Vl.triangulateShape(p, f);
                for (i = 0, s = f.length; i < s; i++) h = f[i], p = p.concat(h);
                for (i = 0, s = p.length; i < s; i++) {
                    var m = p[i];
                    n.push(m.x, m.y, 0), o.push(0, 0, 1), a.push(m.x, m.y)
                }
                for (i = 0, s = d.length; i < s; i++) {
                    var g = d[i],
                        v = g[0] + c,
                        y = g[1] + c,
                        A = g[2] + c;
                    r.push(v, y, A), l += 3
                }
            }
            J.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var r = [],
                n = [],
                o = [],
                a = [],
                s = 0,
                l = 0;
            if (!1 === Array.isArray(t)) i(t);
            else
                for (var h = 0; h < t.length; h++) i(t[h]), this.addGroup(s, l, h), s += l, l = 0;
            this.setIndex(r), this.addAttribute("position", new W(n, 3)), this.addAttribute("normal", new W(o, 3)), this.addAttribute("uv", new W(a, 2))
        }

        function sr(t, e) {
            if (e.shapes = [], Array.isArray(t))
                for (var i = 0, r = t.length; i < r; i++) {
                    var n = t[i];
                    e.shapes.push(n.uuid)
                } else e.shapes.push(t.uuid);
            return e
        }

        function lr(t, e) {
            J.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: e
            }, e = void 0 !== e ? e : 1;
            var i, r, n, o, a = [],
                s = Math.cos(_l.DEG2RAD * e),
                l = [0, 0],
                h = {},
                c = ["a", "b", "c"];
            t.isBufferGeometry ? (o = new N, o.fromBufferGeometry(t)) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
            for (var u = o.vertices, p = o.faces, f = 0, d = p.length; f < d; f++)
                for (var m = p[f], g = 0; g < 3; g++) i = m[c[g]], r = m[c[(g + 1) % 3]], l[0] = Math.min(i, r), l[1] = Math.max(i, r), n = l[0] + "," + l[1], void 0 === h[n] ? h[n] = {
                    index1: l[0],
                    index2: l[1],
                    face1: f,
                    face2: void 0
                } : h[n].face2 = f;
            for (n in h) {
                var v = h[n];
                if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
                    var y = u[v.index1];
                    a.push(y.x, y.y, y.z), y = u[v.index2], a.push(y.x, y.y, y.z)
                }
            }
            this.addAttribute("position", new W(a, 3))
        }

        function hr(t, e, i, r, n, o, a, s) {
            N.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: r,
                heightSegments: n,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            }, this.fromBufferGeometry(new cr(t, e, i, r, n, o, a, s)), this.mergeVertices()
        }

        function cr(t, e, r, n, a, s, l, h) {
            function c(r) {
                var a, s, c, v = new i,
                    x = new o,
                    _ = 0,
                    w = !0 === r ? t : e,
                    b = !0 === r ? 1 : -1;
                for (s = g, a = 1; a <= n; a++) f.push(0, y * b, 0), d.push(0, b, 0), m.push(.5, .5), g++;
                for (c = g, a = 0; a <= n; a++) {
                    var M = a / n,
                        T = M * h + l,
                        S = Math.cos(T),
                        E = Math.sin(T);
                    x.x = w * E, x.y = y * b, x.z = w * S, f.push(x.x, x.y, x.z), d.push(0, b, 0), v.x = .5 * S + .5, v.y = .5 * E * b + .5, m.push(v.x, v.y), g++
                }
                for (a = 0; a < n; a++) {
                    var C = s + a,
                        P = c + a;
                    !0 === r ? p.push(P, P + 1, C) : p.push(P + 1, P, C), _ += 3
                }
                u.addGroup(A, _, !0 === r ? 1 : 2), A += _
            }
            J.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: r,
                radialSegments: n,
                heightSegments: a,
                openEnded: s,
                thetaStart: l,
                thetaLength: h
            };
            var u = this;
            t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, r = r || 1, n = Math.floor(n) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, h = void 0 !== h ? h : 2 * Math.PI;
            var p = [],
                f = [],
                d = [],
                m = [],
                g = 0,
                v = [],
                y = r / 2,
                A = 0;
            ! function () {
                var i, s, c = new o,
                    x = new o,
                    _ = 0,
                    w = (e - t) / r;
                for (s = 0; s <= a; s++) {
                    var b = [],
                        M = s / a,
                        T = M * (e - t) + t;
                    for (i = 0; i <= n; i++) {
                        var S = i / n,
                            E = S * h + l,
                            C = Math.sin(E),
                            P = Math.cos(E);
                        x.x = T * C, x.y = -M * r + y, x.z = T * P, f.push(x.x, x.y, x.z), c.set(C, w, P).normalize(), d.push(c.x, c.y, c.z), m.push(S, 1 - M), b.push(g++)
                    }
                    v.push(b)
                }
                for (i = 0; i < n; i++)
                    for (s = 0; s < a; s++) {
                        var L = v[s][i],
                            D = v[s + 1][i],
                            R = v[s + 1][i + 1],
                            I = v[s][i + 1];
                        p.push(L, D, I), p.push(D, R, I), _ += 6
                    }
                u.addGroup(A, _, 0), A += _
            }(), !1 === s && (t > 0 && c(!0), e > 0 && c(!1)), this.setIndex(p), this.addAttribute("position", new W(f, 3)), this.addAttribute("normal", new W(d, 3)), this.addAttribute("uv", new W(m, 2))
        }

        function ur(t, e, i, r, n, o, a) {
            hr.call(this, 0, t, e, i, r, n, o, a), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: r,
                openEnded: n,
                thetaStart: o,
                thetaLength: a
            }
        }

        function pr(t, e, i, r, n, o, a) {
            cr.call(this, 0, t, e, i, r, n, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: r,
                openEnded: n,
                thetaStart: o,
                thetaLength: a
            }
        }

        function fr(t, e, i, r) {
            N.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: r
            }, this.fromBufferGeometry(new dr(t, e, i, r)), this.mergeVertices()
        }

        function dr(t, e, r, n) {
            J.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: r,
                thetaLength: n
            }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI;
            var a, s, l = [],
                h = [],
                c = [],
                u = [],
                p = new o,
                f = new i;
            for (h.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), s = 0, a = 3; s <= e; s++, a += 3) {
                var d = r + s / e * n;
                p.x = t * Math.cos(d), p.y = t * Math.sin(d), h.push(p.x, p.y, p.z), c.push(0, 0, 1), f.x = (h[a] / t + 1) / 2, f.y = (h[a + 1] / t + 1) / 2, u.push(f.x, f.y)
            }
            for (a = 1; a <= e; a++) l.push(a, a + 1, 0);
            this.setIndex(l), this.addAttribute("position", new W(h, 3)), this.addAttribute("normal", new W(c, 3)), this.addAttribute("uv", new W(u, 2))
        }

        function mr(t) {
            tt.call(this), this.type = "ShadowMaterial", this.color = new T(0), this.transparent = !0, this.setValues(t)
        }

        function gr(t) {
            it.call(this, t), this.type = "RawShaderMaterial"
        }

        function vr(t) {
            tt.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new T(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new T(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function yr(t) {
            vr.call(this), this.defines = {
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
        }

        function Ar(t) {
            tt.call(this), this.type = "MeshPhongMaterial", this.color = new T(16777215), this.specular = new T(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new T(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Qa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function xr(t) {
            Ar.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function _r(t) {
            tt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function wr(t) {
            tt.call(this), this.type = "MeshLambertMaterial", this.color = new T(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new T(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Qa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function br(t) {
            je.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }

        function Mr(t, e, i) {
            var r = this,
                n = !1,
                o = 0,
                a = 0,
                s = void 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
                a++, !1 === n && void 0 !== r.onStart && r.onStart(t, o, a), n = !0
            }, this.itemEnd = function (t) {
                o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (n = !1, void 0 !== r.onLoad && r.onLoad())
            }, this.itemError = function (t) {
                void 0 !== r.onError && r.onError(t)
            }, this.resolveURL = function (t) {
                return s ? s(t) : t
            }, this.setURLModifier = function (t) {
                return s = t, this
            }
        }

        function Tr(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Sr(t) {
            this.manager = void 0 !== t ? t : Yl, this._parser = null
        }

        function Er(t) {
            this.manager = void 0 !== t ? t : Yl, this._parser = null
        }

        function Cr(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Pr(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Lr(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Dr() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function Rr(t, e, i, r, n, o, a, s) {
            Dr.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = r || 1, this.aStartAngle = n || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
        }

        function Ir(t, e, i, r, n, o) {
            Rr.call(this, t, e, i, i, r, n, o), this.type = "ArcCurve"
        }

        function Or() {
            function t(t, o, a, s) {
                e = t, i = a, r = -3 * t + 3 * o - 2 * a - s, n = 2 * t - 2 * o + a + s
            }
            var e = 0,
                i = 0,
                r = 0,
                n = 0;
            return {
                initCatmullRom: function (e, i, r, n, o) {
                    t(i, r, o * (r - e), o * (n - i))
                },
                initNonuniformCatmullRom: function (e, i, r, n, o, a, s) {
                    var l = (i - e) / o - (r - e) / (o + a) + (r - i) / a,
                        h = (r - i) / a - (n - i) / (a + s) + (n - r) / s;
                    l *= a, h *= a, t(i, r, l, h)
                },
                calc: function (t) {
                    var o = t * t;
                    return e + i * t + r * o + n * (o * t)
                }
            }
        }

        function Br(t, e, i, r) {
            Dr.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = r || .5
        }

        function Nr(t, e, i, r, n) {
            var o = .5 * (r - e),
                a = .5 * (n - i),
                s = t * t;
            return (2 * i - 2 * r + o + a) * (t * s) + (-3 * i + 3 * r - 2 * o - a) * s + o * t + i
        }

        function kr(t, e) {
            var i = 1 - t;
            return i * i * e
        }

        function Fr(t, e) {
            return 2 * (1 - t) * t * e
        }

        function zr(t, e) {
            return t * t * e
        }

        function Ur(t, e, i, r) {
            return kr(t, e) + Fr(t, i) + zr(t, r)
        }

        function Gr(t, e) {
            var i = 1 - t;
            return i * i * i * e
        }

        function Vr(t, e) {
            var i = 1 - t;
            return 3 * i * i * t * e
        }

        function Hr(t, e) {
            return 3 * (1 - t) * t * t * e
        }

        function jr(t, e) {
            return t * t * t * e
        }

        function Wr(t, e, i, r, n) {
            return Gr(t, e) + Vr(t, i) + Hr(t, r) + jr(t, n)
        }

        function Yr(t, e, r, n) {
            Dr.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = r || new i, this.v3 = n || new i
        }

        function Xr(t, e, i, r) {
            Dr.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new o, this.v1 = e || new o, this.v2 = i || new o, this.v3 = r || new o
        }

        function Qr(t, e) {
            Dr.call(this), this.type = "LineCurve", this.v1 = t || new i, this.v2 = e || new i
        }

        function Jr(t, e) {
            Dr.call(this), this.type = "LineCurve3", this.v1 = t || new o, this.v2 = e || new o
        }

        function qr(t, e, r) {
            Dr.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = r || new i
        }

        function Zr(t, e, i) {
            Dr.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new o, this.v1 = e || new o, this.v2 = i || new o
        }

        function Kr(t) {
            Dr.call(this), this.type = "SplineCurve", this.points = t || []
        }

        function $r() {
            Dr.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function tn(t) {
            $r.call(this), this.type = "Path", this.currentPoint = new i, t && this.setFromPoints(t)
        }

        function en(t) {
            tn.call(this, t), this.uuid = _l.generateUUID(), this.type = "Shape", this.holes = []
        }

        function rn(t, e) {
            R.call(this), this.type = "Light", this.color = new T(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function nn(t, e, i) {
            rn.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(R.DefaultUp), this.updateMatrix(), this.groundColor = new T(e)
        }

        function on(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new r
        }

        function an() {
            on.call(this, new De(50, 1, .5, 500))
        }

        function sn(t, e, i, r, n, o) {
            rn.call(this, t, e), this.type = "SpotLight", this.position.copy(R.DefaultUp), this.updateMatrix(), this.target = new R, Object.defineProperty(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                },
                set: function (t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== n ? n : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new an
        }

        function ln(t, e, i, r) {
            rn.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                },
                set: function (t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new on(new De(90, 1, .5, 500))
        }

        function hn() {
            on.call(this, new O(-5, 5, 5, -5, .5, 500))
        }

        function cn(t, e) {
            rn.call(this, t, e), this.type = "DirectionalLight", this.position.copy(R.DefaultUp), this.updateMatrix(), this.target = new R, this.shadow = new hn
        }

        function un(t, e) {
            rn.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function pn(t, e, i, r) {
            rn.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== r ? r : 10
        }

        function fn(t, e, i, r) {
            bn.call(this, t, e, i, r)
        }

        function dn(t, e, i) {
            bn.call(this, t, e, i)
        }

        function mn(t, e, i, r) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function gn(t, e, i, r) {
            mn.call(this, t, e, i, r)
        }

        function vn(t, e, i, r) {
            bn.call(this, t, e, i, r)
        }

        function yn(t, e, i, r) {
            bn.call(this, t, e, i, r)
        }

        function An(t, e, i, r) {
            bn.call(this, t, e, i, r)
        }

        function xn(t, e, i, r) {
            mn.call(this, t, e, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function _n(t, e, i, r) {
            mn.call(this, t, e, i, r)
        }

        function wn(t, e, i, r) {
            mn.call(this, t, e, i, r)
        }

        function bn(t, e, i, r) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = $l.convertArray(e, this.TimeBufferType), this.values = $l.convertArray(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function Mn(t, e, i, r) {
            bn.call(this, t, e, i, r)
        }

        function Tn(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = _l.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
        }

        function Sn(t) {
            this.manager = void 0 !== t ? t : Yl, this.textures = {}
        }

        function En(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Cn() {}

        function Pn(t) {
            "boolean" == typeof t && (t = void 0), this.manager = void 0 !== t ? t : Yl, this.withCredentials = !1
        }

        function Ln(t) {
            this.manager = void 0 !== t ? t : Yl, this.texturePath = ""
        }

        function Dn(t) {
            this.manager = void 0 !== t ? t : Yl, this.options = void 0
        }

        function Rn() {
            this.type = "ShapePath", this.subPaths = [], this.currentPath = null
        }

        function In(t) {
            this.type = "Font", this.data = t
        }

        function On(t, e, i, r) {
            for (var n = String(t).split(""), o = e / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * o, s = [], l = 0, h = 0, c = 0; c < n.length; c++) {
                var u = n[c];
                if ("\n" === u) l = 0, h -= a;
                else {
                    var p = Bn(u, i, o, l, h, r);
                    l += p.offsetX, s.push(p.path)
                }
            }
            return s
        }

        function Bn(t, e, i, r, n, o) {
            var a = o.glyphs[t] || o.glyphs["?"];
            if (a) {
                var s, l, h, c, u, p, f, d, m = new Rn;
                if (a.o)
                    for (var g = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, y = g.length; v < y;) {
                        var A = g[v++];
                        switch (A) {
                            case "m":
                                s = g[v++] * i + r, l = g[v++] * i + n, m.moveTo(s, l);
                                break;
                            case "l":
                                s = g[v++] * i + r, l = g[v++] * i + n, m.lineTo(s, l);
                                break;
                            case "q":
                                h = g[v++] * i + r, c = g[v++] * i + n, u = g[v++] * i + r, p = g[v++] * i + n, m.quadraticCurveTo(u, p, h, c);
                                break;
                            case "b":
                                h = g[v++] * i + r, c = g[v++] * i + n, u = g[v++] * i + r, p = g[v++] * i + n, f = g[v++] * i + r, d = g[v++] * i + n, m.bezierCurveTo(u, p, f, d, h, c)
                        }
                    }
                return {
                    offsetX: a.ha * i,
                    path: m
                }
            }
        }

        function Nn(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function kn(t) {
            this.manager = void 0 !== t ? t : Yl
        }

        function Fn() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new De, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new De, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function zn(t, e, i) {
            R.call(this), this.type = "CubeCamera";
            var r = new De(90, 1, t, e);
            r.up.set(0, -1, 0), r.lookAt(new o(1, 0, 0)), this.add(r);
            var n = new De(90, 1, t, e);
            n.up.set(0, -1, 0), n.lookAt(new o(-1, 0, 0)), this.add(n);
            var a = new De(90, 1, t, e);
            a.up.set(0, 0, 1), a.lookAt(new o(0, 1, 0)), this.add(a);
            var s = new De(90, 1, t, e);
            s.up.set(0, 0, -1), s.lookAt(new o(0, -1, 0)), this.add(s);
            var l = new De(90, 1, t, e);
            l.up.set(0, -1, 0), l.lookAt(new o(0, 0, 1)), this.add(l);
            var h = new De(90, 1, t, e);
            h.up.set(0, -1, 0), h.lookAt(new o(0, 0, -1)), this.add(h);
            var c = {
                format: Ds,
                magFilter: ms,
                minFilter: ms
            };
            this.renderTarget = new f(i, i, c), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = this.renderTarget,
                    o = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, n, i), i.activeCubeFace = 2, t.render(e, a, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, l, i), i.texture.generateMipmaps = o, i.activeCubeFace = 5, t.render(e, h, i), t.setRenderTarget(null)
            }, this.clear = function (t, e, i, r) {
                for (var n = this.renderTarget, o = 0; o < 6; o++) n.activeCubeFace = o, t.setRenderTarget(n), t.clear(e, i, r);
                t.setRenderTarget(null)
            }
        }

        function Un() {
            R.call(this), this.type = "AudioListener", this.context = ah.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function Gn(t) {
            R.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function Vn(t) {
            Gn.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function Hn(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function jn(t, e, i) {
            this.binding = t, this.valueSize = i;
            var r, n = Float64Array;
            switch (e) {
                case "quaternion":
                    r = this._slerp;
                    break;
                case "string":
                case "bool":
                    n = Array, r = this._select;
                    break;
                default:
                    r = this._lerp
            }
            this.buffer = new n(4 * i), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }

        function Wn(t, e, i) {
            var r = i || Yn.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, r)
        }

        function Yn(t, e, i) {
            this.path = e, this.parsedPath = i || Yn.parseTrackName(e), this.node = Yn.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Xn() {
            this.uuid = _l.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var r = this;
            this.stats = {
                objects: {
                    get total() {
                        return r._objects.length
                    },
                    get inUse() {
                        return this.total - r.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return r._bindings.length
                }
            }
        }

        function Qn(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null;
            for (var r = e.tracks, n = r.length, o = new Array(n), a = {
                    endingStart: ll,
                    endingEnd: ll
                }, s = 0; s !== n; ++s) {
                var l = r[s].createInterpolant(null);
                o[s] = l, l.settings = a
            }
            this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(n), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = sl, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function Jn(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function qn(t) {
            "string" == typeof t && (t = arguments[1]), this.value = t
        }

        function Zn() {
            J.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function Kn(t, e, i, r) {
            this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === r
        }

        function $n(t, e) {
            this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function to(t, e, i) {
            $n.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function eo(t, e, i) {
            k.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function io(t, e, i, r) {
            this.ray = new rt(t, e), this.near = i || 0, this.far = r || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, (0, x.default)(this.params, {
                PointCloud: {
                    get: function () {
                        return this.Points
                    }
                }
            })
        }

        function ro(t, e) {
            return t.distance - e.distance
        }

        function no(t, e, i, r) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === r))
                for (var n = t.children, o = 0, a = n.length; o < a; o++) no(n[o], e, i, !0)
        }

        function oo(t) {
            this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }

        function ao(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }

        function so(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }

        function lo(t, e) {
            this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0)
        }

        function ho(t) {
            R.call(this), this.material = t, this.render = function () {}
        }

        function co(t, e, i, r) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var n = void 0 !== i ? i : 16711680,
                o = void 0 !== r ? r : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
            var l = new J,
                h = new W(2 * a * 3, 3);
            l.addAttribute("position", h), Ye.call(this, l, new je({
                color: n,
                linewidth: o
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function uo(t, e) {
            R.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
            for (var i = new J, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, o = 1; n < 32; n++, o++) {
                var a = n / 32 * Math.PI * 2,
                    s = o / 32 * Math.PI * 2;
                r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
            }
            i.addAttribute("position", new W(r, 3));
            var l = new je({
                fog: !1
            });
            this.cone = new Ye(i, l), this.add(this.cone), this.update()
        }

        function po(t) {
            var e = [];
            t && t.isBone && e.push(t);
            for (var i = 0; i < t.children.length; i++) e.push.apply(e, po(t.children[i]));
            return e
        }

        function fo(t) {
            for (var e = po(t), i = new J, r = [], n = [], o = new T(0, 0, 1), a = new T(0, 1, 0), s = 0; s < e.length; s++) {
                var l = e[s];
                l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(o.r, o.g, o.b), n.push(a.r, a.g, a.b))
            }
            i.addAttribute("position", new W(r, 3)), i.addAttribute("color", new W(n, 3));
            var h = new je({
                vertexColors: va,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            });
            Ye.call(this, i, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
        }

        function mo(t, e, i) {
            this.light = t, this.light.updateMatrixWorld(), this.color = i;
            var r = new tr(e, 4, 2),
                n = new et({
                    wireframe: !0,
                    fog: !1
                });
            at.call(this, r, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function go(t, e) {
            R.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
            var i = new je({
                    fog: !1
                }),
                r = new J;
            r.addAttribute("position", new k(new Float32Array(15), 3)), this.line = new We(r, i), this.add(this.line), this.update()
        }

        function vo(t, e, i) {
            R.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
            var r = new li(e);
            r.rotateY(.5 * Math.PI), this.material = new et({
                wireframe: !0,
                fog: !1
            }), void 0 === this.color && (this.material.vertexColors = va);
            var n = r.getAttribute("position"),
                o = new Float32Array(3 * n.count);
            r.addAttribute("color", new k(o, 3)), this.add(new at(r, this.material)), this.update()
        }

        function yo(t, e, i, r) {
            t = t || 10, e = e || 10, i = new T(void 0 !== i ? i : 4473924), r = new T(void 0 !== r ? r : 8947848);
            for (var n = e / 2, o = t / e, a = t / 2, s = [], l = [], h = 0, c = 0, u = -a; h <= e; h++, u += o) {
                s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
                var p = h === n ? i : r;
                p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3
            }
            var f = new J;
            f.addAttribute("position", new W(s, 3)), f.addAttribute("color", new W(l, 3));
            var d = new je({
                vertexColors: va
            });
            Ye.call(this, f, d)
        }

        function Ao(t, e, i, r, n, o) {
            t = t || 10, e = e || 16, i = i || 8, r = r || 64, n = new T(void 0 !== n ? n : 4473924), o = new T(void 0 !== o ? o : 8947848);
            var a, s, l, h, c, u, p, f = [],
                d = [];
            for (h = 0; h <= e; h++) l = h / e * (2 * Math.PI), a = Math.sin(l) * t, s = Math.cos(l) * t, f.push(0, 0, 0), f.push(a, 0, s), p = 1 & h ? n : o, d.push(p.r, p.g, p.b), d.push(p.r, p.g, p.b);
            for (h = 0; h <= i; h++)
                for (p = 1 & h ? n : o, u = t - t / i * h, c = 0; c < r; c++) l = c / r * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, f.push(a, 0, s), d.push(p.r, p.g, p.b), l = (c + 1) / r * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, f.push(a, 0, s), d.push(p.r, p.g, p.b);
            var m = new J;
            m.addAttribute("position", new W(f, 3)), m.addAttribute("color", new W(d, 3));
            var g = new je({
                vertexColors: va
            });
            Ye.call(this, m, g)
        }

        function xo(t, e, i, r) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var n = void 0 !== i ? i : 16776960,
                o = void 0 !== r ? r : 1,
                a = 0,
                s = this.object.geometry;
            s && s.isGeometry && (a = s.faces.length);
            var l = new J,
                h = new W(2 * a * 3, 3);
            l.addAttribute("position", h), Ye.call(this, l, new je({
                color: n,
                linewidth: o
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function _o(t, e, i) {
            R.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
            var r = new J;
            r.addAttribute("position", new W([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
            var n = new je({
                fog: !1
            });
            this.lightPlane = new We(r, n), this.add(this.lightPlane), r = new J, r.addAttribute("position", new W([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new We(r, n), this.add(this.targetLine), this.update()
        }

        function wo(t) {
            function e(t, e, r) {
                i(t, r), i(e, r)
            }

            function i(t, e) {
                o.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(o.length / 3 - 1)
            }
            var r = new J,
                n = new je({
                    color: 16777215,
                    vertexColors: ga
                }),
                o = [],
                a = [],
                s = {},
                l = new T(16755200),
                h = new T(16711680),
                c = new T(43775),
                u = new T(16777215),
                p = new T(3355443);
            e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", h), e("p", "n2", h), e("p", "n3", h), e("p", "n4", h), e("u1", "u2", c), e("u2", "u3", c), e("u3", "u1", c), e("c", "t", u), e("p", "c", p), e("cn1", "cn2", p), e("cn3", "cn4", p), e("cf1", "cf2", p), e("cf3", "cf4", p), r.addAttribute("position", new W(o, 3)), r.addAttribute("color", new W(a, 3)), Ye.call(this, r, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
        }

        function bo(t, e) {
            this.object = t, void 0 === e && (e = 16776960);
            var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                r = new Float32Array(24),
                n = new J;
            n.setIndex(new k(i, 1)), n.addAttribute("position", new k(r, 3)), Ye.call(this, n, new je({
                color: e
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Mo(t, e) {
            this.type = "Box3Helper", this.box = t;
            var i = void 0 !== e ? e : 16776960,
                r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                o = new J;
            o.setIndex(new k(r, 1)), o.addAttribute("position", new W(n, 3)), Ye.call(this, o, new je({
                color: i
            })), this.geometry.computeBoundingSphere()
        }

        function To(t, e, i) {
            this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
            var r = void 0 !== i ? i : 16776960,
                n = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                o = new J;
            o.addAttribute("position", new W(n, 3)), o.computeBoundingSphere(), We.call(this, o, new je({
                color: r
            }));
            var a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                s = new J;
            s.addAttribute("position", new W(a, 3)), s.computeBoundingSphere(), this.add(new at(s, new et({
                color: r,
                opacity: .2,
                transparent: !0,
                depthWrite: !1
            })))
        }

        function So(t, e, i, r, n, o) {
            R.call(this), void 0 === r && (r = 16776960), void 0 === i && (i = 1), void 0 === n && (n = .2 * i), void 0 === o && (o = .2 * n), void 0 === lh && (lh = new J, lh.addAttribute("position", new W([0, 0, 0, 0, 1, 0], 3)), hh = new cr(0, .5, 1, 5, 1), hh.translate(0, -.5, 0)), this.position.copy(e), this.line = new We(lh, new je({
                color: r
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new at(hh, new et({
                color: r
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, n, o)
        }

        function Eo(t) {
            t = t || 1;
            var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
                r = new J;
            r.addAttribute("position", new W(e, 3)), r.addAttribute("color", new W(i, 3));
            var n = new je({
                vertexColors: va
            });
            Ye.call(this, r, n)
        }

        function Co(t, e, i, r, n, o, a) {
            return new B(t, e, i, n, o, a)
        }

        function Po(t) {
            return t
        }

        function Lo(t) {
            return void 0 === t && (t = []), t.isMultiMaterial = !0, t.materials = t, t.clone = function () {
                return t.slice()
            }, t
        }

        function Do(t, e) {
            return new Je(t, e)
        }

        function Ro(t) {
            return new ze(t)
        }

        function Io(t, e) {
            return new Je(t, e)
        }

        function Oo(t) {
            return new Qe(t)
        }

        function Bo(t) {
            return new Qe(t)
        }

        function No(t) {
            return new Qe(t)
        }

        function ko(t, e, i) {
            return new o(t, e, i)
        }

        function Fo(t, e) {
            return new k(t, e).setDynamic(!0)
        }

        function zo(t, e) {
            return new F(t, e)
        }

        function Uo(t, e) {
            return new z(t, e)
        }

        function Go(t, e) {
            return new U(t, e)
        }

        function Vo(t, e) {
            return new G(t, e)
        }

        function Ho(t, e) {
            return new V(t, e)
        }

        function jo(t, e) {
            return new H(t, e)
        }

        function Wo(t, e) {
            return new j(t, e)
        }

        function Yo(t, e) {
            return new W(t, e)
        }

        function Xo(t, e) {
            return new Y(t, e)
        }

        function Qo(t) {
            Br.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function Jo(t) {
            Br.call(this, t), this.type = "catmullrom"
        }

        function qo(t) {
            Br.call(this, t), this.type = "catmullrom"
        }

        function Zo(t) {
            return new Eo(t)
        }

        function Ko(t, e) {
            return new bo(t, e)
        }

        function $o(t, e) {
            return new Ye(new lr(t.geometry), new je({
                color: void 0 !== e ? e : 16777215
            }))
        }

        function ta(t, e) {
            return new Ye(new ti(t.geometry), new je({
                color: void 0 !== e ? e : 16777215
            }))
        }

        function ea(t) {
            return new Tr(t)
        }

        function ia(t) {
            return new Er(t)
        }

        function ra() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) {
                t.project(e)
            }, this.unprojectVector = function (t, e) {
                t.unproject(e)
            }, this.pickingRay = function () {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }

        function na() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function () {}, this.render = function () {}, this.setClearColor = function () {}, this.setSize = function () {}
        }

        function oa() {
            console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
        }
        void 0 === C.default && (Number.EPSILON = Math.pow(2, -52)), void 0 === S.default && (Number.isInteger = function (t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === M.default && (Math.sign = function (t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t
        }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === w.default && function () {
            Object.assign = function (t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                    var r = arguments[i];
                    if (void 0 !== r && null !== r)
                        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
                }
                return e
            }
        }(), (0, w.default)(e.prototype, {
            addEventListener: function (t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function (t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function (t, e) {
                if (void 0 !== this._listeners) {
                    var i = this._listeners,
                        r = i[t];
                    if (void 0 !== r) {
                        var n = r.indexOf(e); - 1 !== n && r.splice(n, 1)
                    }
                }
            },
            dispatchEvent: function (t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners,
                        i = e[t.type];
                    if (void 0 !== i) {
                        t.target = this;
                        for (var r = i.slice(0), n = 0, o = r.length; n < o; n++) r[n].call(this, t)
                    }
                }
            }
        });
        var aa = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            },
            sa = 0,
            la = 1,
            ha = 2,
            ca = 1,
            ua = 2,
            pa = 0,
            fa = 1,
            da = 2,
            ma = 0,
            ga = 1,
            va = 2,
            ya = 0,
            Aa = 1,
            xa = 2,
            _a = 3,
            wa = 4,
            ba = 5,
            Ma = 100,
            Ta = 101,
            Sa = 102,
            Ea = 103,
            Ca = 104,
            Pa = 200,
            La = 201,
            Da = 202,
            Ra = 203,
            Ia = 204,
            Oa = 205,
            Ba = 206,
            Na = 207,
            ka = 208,
            Fa = 209,
            za = 210,
            Ua = 0,
            Ga = 1,
            Va = 2,
            Ha = 3,
            ja = 4,
            Wa = 5,
            Ya = 6,
            Xa = 7,
            Qa = 0,
            Ja = 1,
            qa = 2,
            Za = 0,
            Ka = 1,
            $a = 2,
            ts = 3,
            es = 4,
            is = 301,
            rs = 302,
            ns = 303,
            os = 304,
            as = 305,
            ss = 306,
            ls = 307,
            hs = 1e3,
            cs = 1001,
            us = 1002,
            ps = 1003,
            fs = 1004,
            ds = 1005,
            ms = 1006,
            gs = 1007,
            vs = 1008,
            ys = 1009,
            As = 1010,
            xs = 1011,
            _s = 1012,
            ws = 1013,
            bs = 1014,
            Ms = 1015,
            Ts = 1016,
            Ss = 1017,
            Es = 1018,
            Cs = 1019,
            Ps = 1020,
            Ls = 1021,
            Ds = 1022,
            Rs = 1023,
            Is = 1024,
            Os = 1025,
            Bs = Rs,
            Ns = 1026,
            ks = 1027,
            Fs = 33776,
            zs = 33777,
            Us = 33778,
            Gs = 33779,
            Vs = 35840,
            Hs = 35841,
            js = 35842,
            Ws = 35843,
            Ys = 36196,
            Xs = 37808,
            Qs = 37809,
            Js = 37810,
            qs = 37811,
            Zs = 37812,
            Ks = 37813,
            $s = 37814,
            tl = 37815,
            el = 37816,
            il = 37817,
            rl = 37818,
            nl = 37819,
            ol = 37820,
            al = 37821,
            sl = 2201,
            ll = 2400,
            hl = 0,
            cl = 1,
            ul = 2,
            pl = 3e3,
            fl = 3001,
            dl = 3007,
            ml = 3002,
            gl = 3004,
            vl = 3005,
            yl = 3006,
            Al = 3200,
            xl = 3201,
            _l = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function () {
                    for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                    return function () {
                        var e = 4294967295 * Math.random() | 0,
                            i = 4294967295 * Math.random() | 0,
                            r = 4294967295 * Math.random() | 0,
                            n = 4294967295 * Math.random() | 0;
                        return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & r | 128] + t[r >> 8 & 255] + "-" + t[r >> 16 & 255] + t[r >> 24 & 255] + t[255 & n] + t[n >> 8 & 255] + t[n >> 16 & 255] + t[n >> 24 & 255]).toUpperCase()
                    }
                }(),
                clamp: function (t, e, i) {
                    return Math.max(e, Math.min(i, t))
                },
                euclideanModulo: function (t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function (t, e, i, r, n) {
                    return r + (t - e) * (n - r) / (i - e)
                },
                lerp: function (t, e, i) {
                    return (1 - i) * t + i * e
                },
                smoothstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                },
                smootherstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function (t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function (t) {
                    return t * (.5 - Math.random())
                },
                degToRad: function (t) {
                    return t * _l.DEG2RAD
                },
                radToDeg: function (t) {
                    return t * _l.RAD2DEG
                },
                isPowerOfTwo: function (t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function (t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function (t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
            };
        (0, x.default)(i.prototype, {
            width: {
                get: function () {
                    return this.x
                },
                set: function (t) {
                    this.x = t
                }
            },
            height: {
                get: function () {
                    return this.y
                },
                set: function (t) {
                    this.y = t
                }
            }
        }), (0, w.default)(i.prototype, {
            isVector2: !0,
            set: function (t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function (t) {
                return this.x = t, this.y = t, this
            },
            setX: function (t) {
                return this.x = t, this
            },
            setY: function (t) {
                return this.y = t, this
            },
            setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y)
            },
            copy: function (t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function (t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function (t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function (t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function (t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function (t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            },
            applyMatrix3: function (t) {
                var e = this.x,
                    i = this.y,
                    r = t.elements;
                return this.x = r[0] * e + r[3] * i + r[6], this.y = r[1] * e + r[4] * i + r[7], this
            },
            min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: function () {
                var t = new i,
                    e = new i;
                return function (i, r) {
                    return t.set(i, i), e.set(r, r), this.clamp(t, e)
                }
            }(),
            clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function (t) {
                return this.x * t.x + this.y * t.y
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            angle: function () {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI), t
            },
            distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function (t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return e * e + i * i
            },
            manhattanDistanceTo: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function (t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function (t, e, i) {
                return this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function (t, e) {
                var i = Math.cos(e),
                    r = Math.sin(e),
                    n = this.x - t.x,
                    o = this.y - t.y;
                return this.x = n * i - o * r + t.x, this.y = n * r + o * i + t.y, this
            }
        }), (0, w.default)(r.prototype, {
            isMatrix4: !0,
            set: function (t, e, i, r, n, o, a, s, l, h, c, u, p, f, d, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = r, g[1] = n, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new r).fromArray(this.elements)
            },
            copy: function (t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
            },
            copyPosition: function (t) {
                var e = this.elements,
                    i = t.elements;
                return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
            },
            extractBasis: function (t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function (t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function () {
                var t = new o;
                return function (e) {
                    var i = this.elements,
                        r = e.elements,
                        n = 1 / t.setFromMatrixColumn(e, 0).length(),
                        o = 1 / t.setFromMatrixColumn(e, 1).length(),
                        a = 1 / t.setFromMatrixColumn(e, 2).length();
                    return i[0] = r[0] * n, i[1] = r[1] * n, i[2] = r[2] * n, i[4] = r[4] * o, i[5] = r[5] * o, i[6] = r[6] * o, i[8] = r[8] * a, i[9] = r[9] * a, i[10] = r[10] * a, this
                }
            }(),
            makeRotationFromEuler: function (t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                    i = t.x,
                    r = t.y,
                    n = t.z,
                    o = Math.cos(i),
                    a = Math.sin(i),
                    s = Math.cos(r),
                    l = Math.sin(r),
                    h = Math.cos(n),
                    c = Math.sin(n);
                if ("XYZ" === t.order) {
                    var u = o * h,
                        p = o * c,
                        f = a * h,
                        d = a * c;
                    e[0] = s * h, e[4] = -s * c, e[8] = l, e[1] = p + f * l, e[5] = u - d * l, e[9] = -a * s, e[2] = d - u * l, e[6] = f + p * l, e[10] = o * s
                } else if ("YXZ" === t.order) {
                    var m = s * h,
                        g = s * c,
                        v = l * h,
                        y = l * c;
                    e[0] = m + y * a, e[4] = v * a - g, e[8] = o * l, e[1] = o * c, e[5] = o * h, e[9] = -a, e[2] = g * a - v, e[6] = y + m * a, e[10] = o * s
                } else if ("ZXY" === t.order) {
                    var m = s * h,
                        g = s * c,
                        v = l * h,
                        y = l * c;
                    e[0] = m - y * a, e[4] = -o * c, e[8] = v + g * a, e[1] = g + v * a, e[5] = o * h, e[9] = y - m * a, e[2] = -o * l, e[6] = a, e[10] = o * s
                } else if ("ZYX" === t.order) {
                    var u = o * h,
                        p = o * c,
                        f = a * h,
                        d = a * c;
                    e[0] = s * h, e[4] = f * l - p, e[8] = u * l + d, e[1] = s * c, e[5] = d * l + u, e[9] = p * l - f, e[2] = -l, e[6] = a * s, e[10] = o * s
                } else if ("YZX" === t.order) {
                    var A = o * s,
                        x = o * l,
                        _ = a * s,
                        w = a * l;
                    e[0] = s * h, e[4] = w - A * c, e[8] = _ * c + x, e[1] = c, e[5] = o * h, e[9] = -a * h, e[2] = -l * h, e[6] = x * c + _, e[10] = A - w * c
                } else if ("XZY" === t.order) {
                    var A = o * s,
                        x = o * l,
                        _ = a * s,
                        w = a * l;
                    e[0] = s * h, e[4] = -c, e[8] = l * h, e[1] = A * c + w, e[5] = o * h, e[9] = x * c - _, e[2] = _ * c - x, e[6] = a * h, e[10] = w * c + A
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function (t) {
                var e = this.elements,
                    i = t._x,
                    r = t._y,
                    n = t._z,
                    o = t._w,
                    a = i + i,
                    s = r + r,
                    l = n + n,
                    h = i * a,
                    c = i * s,
                    u = i * l,
                    p = r * s,
                    f = r * l,
                    d = n * l,
                    m = o * a,
                    g = o * s,
                    v = o * l;
                return e[0] = 1 - (p + d), e[4] = c - v, e[8] = u + g, e[1] = c + v, e[5] = 1 - (h + d), e[9] = f - m, e[2] = u - g, e[6] = f + m, e[10] = 1 - (h + p), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            lookAt: function () {
                var t = new o,
                    e = new o,
                    i = new o;
                return function (r, n, o) {
                    var a = this.elements;
                    return i.subVectors(r, n), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
                }
            }(),
            multiply: function (t, e) {
                return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t)
            },
            premultiply: function (t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function (t, e) {
                var i = t.elements,
                    r = e.elements,
                    n = this.elements,
                    o = i[0],
                    a = i[4],
                    s = i[8],
                    l = i[12],
                    h = i[1],
                    c = i[5],
                    u = i[9],
                    p = i[13],
                    f = i[2],
                    d = i[6],
                    m = i[10],
                    g = i[14],
                    v = i[3],
                    y = i[7],
                    A = i[11],
                    x = i[15],
                    _ = r[0],
                    w = r[4],
                    b = r[8],
                    M = r[12],
                    T = r[1],
                    S = r[5],
                    E = r[9],
                    C = r[13],
                    P = r[2],
                    L = r[6],
                    D = r[10],
                    R = r[14],
                    I = r[3],
                    O = r[7],
                    B = r[11],
                    N = r[15];
                return n[0] = o * _ + a * T + s * P + l * I, n[4] = o * w + a * S + s * L + l * O, n[8] = o * b + a * E + s * D + l * B, n[12] = o * M + a * C + s * R + l * N, n[1] = h * _ + c * T + u * P + p * I, n[5] = h * w + c * S + u * L + p * O, n[9] = h * b + c * E + u * D + p * B, n[13] = h * M + c * C + u * R + p * N, n[2] = f * _ + d * T + m * P + g * I, n[6] = f * w + d * S + m * L + g * O, n[10] = f * b + d * E + m * D + g * B, n[14] = f * M + d * C + m * R + g * N, n[3] = v * _ + y * T + A * P + x * I, n[7] = v * w + y * S + A * L + x * O, n[11] = v * b + y * E + A * D + x * B, n[15] = v * M + y * C + A * R + x * N, this
            },
            multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToBufferAttribute: function () {
                var t = new o;
                return function (e) {
                    for (var i = 0, r = e.count; i < r; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            determinant: function () {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    r = t[8],
                    n = t[12],
                    o = t[1],
                    a = t[5],
                    s = t[9],
                    l = t[13],
                    h = t[2],
                    c = t[6],
                    u = t[10],
                    p = t[14];
                return t[3] * (+n * s * c - r * l * c - n * a * u + i * l * u + r * a * p - i * s * p) + t[7] * (+e * s * p - e * l * u + n * o * u - r * o * p + r * l * h - n * s * h) + t[11] * (+e * l * c - e * a * p - n * o * c + i * o * p + n * a * h - i * l * h) + t[15] * (-r * a * h - e * s * c + e * a * u + r * o * c - i * o * u + i * s * h)
            },
            transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            },
            setPosition: function (t) {
                var e = this.elements;
                return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
            },
            getInverse: function (t, e) {
                var i = this.elements,
                    r = t.elements,
                    n = r[0],
                    o = r[1],
                    a = r[2],
                    s = r[3],
                    l = r[4],
                    h = r[5],
                    c = r[6],
                    u = r[7],
                    p = r[8],
                    f = r[9],
                    d = r[10],
                    m = r[11],
                    g = r[12],
                    v = r[13],
                    y = r[14],
                    A = r[15],
                    x = f * y * u - v * d * u + v * c * m - h * y * m - f * c * A + h * d * A,
                    _ = g * d * u - p * y * u - g * c * m + l * y * m + p * c * A - l * d * A,
                    w = p * v * u - g * f * u + g * h * m - l * v * m - p * h * A + l * f * A,
                    b = g * f * c - p * v * c - g * h * d + l * v * d + p * h * y - l * f * y,
                    M = n * x + o * _ + a * w + s * b;
                if (0 === M) {
                    if (!0 === e) throw new Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                    return this.identity()
                }
                var T = 1 / M;
                return i[0] = x * T, i[1] = (v * d * s - f * y * s - v * a * m + o * y * m + f * a * A - o * d * A) * T, i[2] = (h * y * s - v * c * s + v * a * u - o * y * u - h * a * A + o * c * A) * T, i[3] = (f * c * s - h * d * s - f * a * u + o * d * u + h * a * m - o * c * m) * T, i[4] = _ * T, i[5] = (p * y * s - g * d * s + g * a * m - n * y * m - p * a * A + n * d * A) * T, i[6] = (g * c * s - l * y * s - g * a * u + n * y * u + l * a * A - n * c * A) * T, i[7] = (l * d * s - p * c * s + p * a * u - n * d * u - l * a * m + n * c * m) * T, i[8] = w * T, i[9] = (g * f * s - p * v * s - g * o * m + n * v * m + p * o * A - n * f * A) * T, i[10] = (l * v * s - g * h * s + g * o * u - n * v * u - l * o * A + n * h * A) * T, i[11] = (p * h * s - l * f * s - p * o * u + n * f * u + l * o * m - n * h * m) * T, i[12] = b * T, i[13] = (p * v * a - g * f * a + g * o * d - n * v * d - p * o * y + n * f * y) * T, i[14] = (g * h * a - l * v * a - g * o * c + n * v * c + l * o * y - n * h * y) * T, i[15] = (l * f * a - p * h * a + p * o * c - n * f * c - l * o * d + n * h * d) * T, this
            },
            scale: function (t) {
                var e = this.elements,
                    i = t.x,
                    r = t.y,
                    n = t.z;
                return e[0] *= i, e[4] *= r, e[8] *= n, e[1] *= i, e[5] *= r, e[9] *= n, e[2] *= i, e[6] *= r, e[10] *= n, e[3] *= i, e[7] *= r, e[11] *= n, this
            },
            getMaxScaleOnAxis: function () {
                var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, i, r))
            },
            makeTranslation: function (t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            },
            makeRotationX: function (t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function (t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function (t) {
                var e = Math.cos(t),
                    i = Math.sin(t);
                return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function (t, e) {
                var i = Math.cos(e),
                    r = Math.sin(e),
                    n = 1 - i,
                    o = t.x,
                    a = t.y,
                    s = t.z,
                    l = n * o,
                    h = n * a;
                return this.set(l * o + i, l * a - r * s, l * s + r * a, 0, l * a + r * s, h * a + i, h * s - r * o, 0, l * s - r * a, h * s + r * o, n * s * s + i, 0, 0, 0, 0, 1), this
            },
            makeScale: function (t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            },
            makeShear: function (t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function (t, e, i) {
                return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
            },
            decompose: function () {
                var t = new o,
                    e = new r;
                return function (i, r, n) {
                    var o = this.elements,
                        a = t.set(o[0], o[1], o[2]).length(),
                        s = t.set(o[4], o[5], o[6]).length(),
                        l = t.set(o[8], o[9], o[10]).length();
                    this.determinant() < 0 && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this);
                    var h = 1 / a,
                        c = 1 / s,
                        u = 1 / l;
                    return e.elements[0] *= h, e.elements[1] *= h, e.elements[2] *= h, e.elements[4] *= c, e.elements[5] *= c, e.elements[6] *= c, e.elements[8] *= u, e.elements[9] *= u, e.elements[10] *= u, r.setFromRotationMatrix(e), n.x = a, n.y = s, n.z = l, this
                }
            }(),
            makePerspective: function (t, e, i, r, n, o) {
                var a = this.elements,
                    s = 2 * n / (e - t),
                    l = 2 * n / (i - r),
                    h = (e + t) / (e - t),
                    c = (i + r) / (i - r),
                    u = -(o + n) / (o - n),
                    p = -2 * o * n / (o - n);
                return a[0] = s, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = l, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            },
            makeOrthographic: function (t, e, i, r, n, o) {
                var a = this.elements,
                    s = 1 / (e - t),
                    l = 1 / (i - r),
                    h = 1 / (o - n),
                    c = (e + t) * s,
                    u = (i + r) * l,
                    p = (o + n) * h;
                return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            },
            equals: function (t) {
                for (var e = this.elements, i = t.elements, r = 0; r < 16; r++)
                    if (e[r] !== i[r]) return !1;
                return !0
            },
            fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        }), (0, w.default)(n, {
            slerp: function (t, e, i, r) {
                return i.copy(t).slerp(e, r)
            },
            slerpFlat: function (t, e, i, r, n, o, a) {
                var s = i[r + 0],
                    l = i[r + 1],
                    h = i[r + 2],
                    c = i[r + 3],
                    u = n[o + 0],
                    p = n[o + 1],
                    f = n[o + 2],
                    d = n[o + 3];
                if (c !== d || s !== u || l !== p || h !== f) {
                    var m = 1 - a,
                        g = s * u + l * p + h * f + c * d,
                        v = g >= 0 ? 1 : -1,
                        y = 1 - g * g;
                    if (y > C.default) {
                        var A = Math.sqrt(y),
                            x = Math.atan2(A, g * v);
                        m = Math.sin(m * x) / A, a = Math.sin(a * x) / A
                    }
                    var _ = a * v;
                    if (s = s * m + u * _, l = l * m + p * _, h = h * m + f * _, c = c * m + d * _, m === 1 - a) {
                        var w = 1 / Math.sqrt(s * s + l * l + h * h + c * c);
                        s *= w, l *= w, h *= w, c *= w
                    }
                }
                t[e] = s, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
            }
        }), (0, x.default)(n.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            w: {
                get: function () {
                    return this._w
                },
                set: function (t) {
                    this._w = t, this.onChangeCallback()
                }
            }
        }), (0, w.default)(n.prototype, {
            set: function (t, e, i, r) {
                return this._x = t, this._y = e, this._z = i, this._w = r, this.onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function (t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            },
            setFromEuler: function (t, e) {
                if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    r = t._y,
                    n = t._z,
                    o = t.order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(i / 2),
                    h = a(r / 2),
                    c = a(n / 2),
                    u = s(i / 2),
                    p = s(r / 2),
                    f = s(n / 2);
                return "XYZ" === o ? (this._x = u * h * c + l * p * f, this._y = l * p * c - u * h * f, this._z = l * h * f + u * p * c, this._w = l * h * c - u * p * f) : "YXZ" === o ? (this._x = u * h * c + l * p * f, this._y = l * p * c - u * h * f, this._z = l * h * f - u * p * c, this._w = l * h * c + u * p * f) : "ZXY" === o ? (this._x = u * h * c - l * p * f, this._y = l * p * c + u * h * f, this._z = l * h * f + u * p * c, this._w = l * h * c - u * p * f) : "ZYX" === o ? (this._x = u * h * c - l * p * f, this._y = l * p * c + u * h * f, this._z = l * h * f - u * p * c, this._w = l * h * c + u * p * f) : "YZX" === o ? (this._x = u * h * c + l * p * f, this._y = l * p * c + u * h * f, this._z = l * h * f - u * p * c, this._w = l * h * c - u * p * f) : "XZY" === o && (this._x = u * h * c - l * p * f, this._y = l * p * c - u * h * f, this._z = l * h * f + u * p * c, this._w = l * h * c + u * p * f), !1 !== e && this.onChangeCallback(), this
            },
            setFromAxisAngle: function (t, e) {
                var i = e / 2,
                    r = Math.sin(i);
                return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(i), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function (t) {
                var e, i = t.elements,
                    r = i[0],
                    n = i[4],
                    o = i[8],
                    a = i[1],
                    s = i[5],
                    l = i[9],
                    h = i[2],
                    c = i[6],
                    u = i[10],
                    p = r + s + u;
                return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (c - l) * e, this._y = (o - h) * e, this._z = (a - n) * e) : r > s && r > u ? (e = 2 * Math.sqrt(1 + r - s - u), this._w = (c - l) / e, this._x = .25 * e, this._y = (n + a) / e, this._z = (o + h) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - r - u), this._w = (o - h) / e, this._x = (n + a) / e, this._y = .25 * e, this._z = (l + c) / e) : (e = 2 * Math.sqrt(1 + u - r - s), this._w = (a - n) / e, this._x = (o + h) / e, this._y = (l + c) / e, this._z = .25 * e), this.onChangeCallback(), this
            },
            setFromUnitVectors: function () {
                var t, e = new o;
                return function (i, r) {
                    return void 0 === e && (e = new o), t = i.dot(r) + 1, t < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, r), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                }
            }(),
            inverse: function () {
                return this.conjugate()
            },
            conjugate: function () {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function (t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function () {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
            },
            multiply: function (t, e) {
                return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t)
            },
            premultiply: function (t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function (t, e) {
                var i = t._x,
                    r = t._y,
                    n = t._z,
                    o = t._w,
                    a = e._x,
                    s = e._y,
                    l = e._z,
                    h = e._w;
                return this._x = i * h + o * a + r * l - n * s, this._y = r * h + o * s + n * a - i * l, this._z = n * h + o * l + i * s - r * a, this._w = o * h - i * a - r * s - n * l, this.onChangeCallback(), this
            },
            slerp: function (t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    r = this._y,
                    n = this._z,
                    o = this._w,
                    a = o * t._w + i * t._x + r * t._y + n * t._z;
                if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = n, this;
                var s = Math.sqrt(1 - a * a);
                if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (r + this._y), this._z = .5 * (n + this._z), this;
                var l = Math.atan2(s, a),
                    h = Math.sin((1 - e) * l) / s,
                    c = Math.sin(e * l) / s;
                return this._w = o * h + this._w * c, this._x = i * h + this._x * c, this._y = r * h + this._y * c, this._z = n * h + this._z * c, this.onChangeCallback(), this
            },
            equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            onChange: function (t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function () {}
        }), (0, w.default)(o.prototype, {
            isVector3: !0,
            set: function (t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            },
            setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this
            },
            setX: function (t) {
                return this.x = t, this
            },
            setY: function (t) {
                return this.y = t, this
            },
            setZ: function (t) {
                return this.z = t, this
            },
            setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function (t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function (t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function (t, e) {
                return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function (t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: function () {
                var t = new n;
                return function (e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                }
            }(),
            applyAxisAngle: function () {
                var t = new n;
                return function (e, i) {
                    return this.applyQuaternion(t.setFromAxisAngle(e, i))
                }
            }(),
            applyMatrix3: function (t) {
                var e = this.x,
                    i = this.y,
                    r = this.z,
                    n = t.elements;
                return this.x = n[0] * e + n[3] * i + n[6] * r, this.y = n[1] * e + n[4] * i + n[7] * r, this.z = n[2] * e + n[5] * i + n[8] * r, this
            },
            applyMatrix4: function (t) {
                var e = this.x,
                    i = this.y,
                    r = this.z,
                    n = t.elements,
                    o = 1 / (n[3] * e + n[7] * i + n[11] * r + n[15]);
                return this.x = (n[0] * e + n[4] * i + n[8] * r + n[12]) * o, this.y = (n[1] * e + n[5] * i + n[9] * r + n[13]) * o, this.z = (n[2] * e + n[6] * i + n[10] * r + n[14]) * o, this
            },
            applyQuaternion: function (t) {
                var e = this.x,
                    i = this.y,
                    r = this.z,
                    n = t.x,
                    o = t.y,
                    a = t.z,
                    s = t.w,
                    l = s * e + o * r - a * i,
                    h = s * i + a * e - n * r,
                    c = s * r + n * i - o * e,
                    u = -n * e - o * i - a * r;
                return this.x = l * s + u * -n + h * -a - c * -o, this.y = h * s + u * -o + c * -n - l * -a, this.z = c * s + u * -a + l * -o - h * -n, this
            },
            project: function () {
                var t = new r;
                return function (e) {
                    return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t)
                }
            }(),
            unproject: function () {
                var t = new r;
                return function (e) {
                    return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t)
                }
            }(),
            transformDirection: function (t) {
                var e = this.x,
                    i = this.y,
                    r = this.z,
                    n = t.elements;
                return this.x = n[0] * e + n[4] * i + n[8] * r, this.y = n[1] * e + n[5] * i + n[9] * r, this.z = n[2] * e + n[6] * i + n[10] * r, this.normalize()
            },
            divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            },
            min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: function () {
                var t = new o,
                    e = new o;
                return function (i, r) {
                    return t.set(i, i, i), e.set(r, r, r), this.clamp(t, e)
                }
            }(),
            clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            cross: function (t, e) {
                return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t)
            },
            crossVectors: function (t, e) {
                var i = t.x,
                    r = t.y,
                    n = t.z,
                    o = e.x,
                    a = e.y,
                    s = e.z;
                return this.x = r * s - n * a, this.y = n * o - i * s, this.z = i * a - r * o, this
            },
            projectOnVector: function (t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            },
            projectOnPlane: function () {
                var t = new o;
                return function (e) {
                    return t.copy(this).projectOnVector(e), this.sub(t)
                }
            }(),
            reflect: function () {
                var t = new o;
                return function (e) {
                    return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(),
            angleTo: function (t) {
                var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                return Math.acos(_l.clamp(e, -1, 1))
            },
            distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function (t) {
                var e = this.x - t.x,
                    i = this.y - t.y,
                    r = this.z - t.z;
                return e * e + i * i + r * r
            },
            manhattanDistanceTo: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function (t) {
                var e = Math.sin(t.phi) * t.radius;
                return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
            },
            setFromCylindrical: function (t) {
                return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
            },
            setFromMatrixPosition: function (t) {
                var e = t.elements;
                return this.x = e[12], this.y = e[13], this.z = e[14], this
            },
            setFromMatrixScale: function (t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = i, this.z = r, this
            },
            setFromMatrixColumn: function (t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function (t, e, i) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }), (0, w.default)(a.prototype, {
            isMatrix3: !0,
            set: function (t, e, i, r, n, o, a, s, l) {
                var h = this.elements;
                return h[0] = t, h[1] = r, h[2] = a, h[3] = e, h[4] = n, h[5] = s, h[6] = i, h[7] = o, h[8] = l, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function (t) {
                var e = this.elements,
                    i = t.elements;
                return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
            },
            setFromMatrix4: function (t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            },
            applyToBufferAttribute: function () {
                var t = new o;
                return function (e) {
                    for (var i = 0, r = e.count; i < r; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            multiply: function (t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function (t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function (t, e) {
                var i = t.elements,
                    r = e.elements,
                    n = this.elements,
                    o = i[0],
                    a = i[3],
                    s = i[6],
                    l = i[1],
                    h = i[4],
                    c = i[7],
                    u = i[2],
                    p = i[5],
                    f = i[8],
                    d = r[0],
                    m = r[3],
                    g = r[6],
                    v = r[1],
                    y = r[4],
                    A = r[7],
                    x = r[2],
                    _ = r[5],
                    w = r[8];
                return n[0] = o * d + a * v + s * x, n[3] = o * m + a * y + s * _, n[6] = o * g + a * A + s * w, n[1] = l * d + h * v + c * x, n[4] = l * m + h * y + c * _, n[7] = l * g + h * A + c * w, n[2] = u * d + p * v + f * x, n[5] = u * m + p * y + f * _, n[8] = u * g + p * A + f * w, this
            },
            multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function () {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    r = t[2],
                    n = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    h = t[8];
                return e * o * h - e * a * l - i * n * h + i * a * s + r * n * l - r * o * s
            },
            getInverse: function (t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var i = t.elements,
                    r = this.elements,
                    n = i[0],
                    o = i[1],
                    a = i[2],
                    s = i[3],
                    l = i[4],
                    h = i[5],
                    c = i[6],
                    u = i[7],
                    p = i[8],
                    f = p * l - h * u,
                    d = h * c - p * s,
                    m = u * s - l * c,
                    g = n * f + o * d + a * m;
                if (0 === g) {
                    if (!0 === e) throw new Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                    return this.identity()
                }
                var v = 1 / g;
                return r[0] = f * v, r[1] = (a * u - p * o) * v, r[2] = (h * o - a * l) * v, r[3] = d * v, r[4] = (p * n - a * c) * v, r[5] = (a * s - h * n) * v, r[6] = m * v, r[7] = (o * c - u * n) * v, r[8] = (l * n - o * s) * v, this
            },
            transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            },
            getNormalMatrix: function (t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function (t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            setUvTransform: function (t, e, i, r, n, o, a) {
                var s = Math.cos(n),
                    l = Math.sin(n);
                this.set(i * s, i * l, -i * (s * o + l * a) + o + t, -r * l, r * s, -r * (-l * o + s * a) + a + e, 0, 0, 1)
            },
            scale: function (t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            },
            rotate: function (t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    r = this.elements,
                    n = r[0],
                    o = r[3],
                    a = r[6],
                    s = r[1],
                    l = r[4],
                    h = r[7];
                return r[0] = e * n + i * s, r[3] = e * o + i * l, r[6] = e * a + i * h, r[1] = -i * n + e * s, r[4] = -i * o + e * l, r[7] = -i * a + e * h, this
            },
            translate: function (t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            },
            equals: function (t) {
                for (var e = this.elements, i = t.elements, r = 0; r < 9; r++)
                    if (e[r] !== i[r]) return !1;
                return !0
            },
            fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        });
        var wl = 0;
        s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: s,
            isTexture: !0,
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function (t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                if (void 0 !== this.image) {
                    var r = this.image;
                    void 0 === r.uuid && (r.uuid = _l.generateUUID()), e || void 0 !== t.images[r.uuid] || (t.images[r.uuid] = {
                        uuid: r.uuid,
                        url: function (t) {
                            var e;
                            if (t instanceof HTMLCanvasElement) e = t;
                            else {
                                e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), e.width = t.width, e.height = t.height;
                                var i = e.getContext("2d");
                                t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height)
                            }
                            return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                        }(r)
                    }), i.image = r.uuid
                }
                return e || (t.textures[this.uuid] = i), i
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function (t) {
                if (300 === this.mapping) {
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case hs:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case cs:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case us:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case hs:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case cs:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case us:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        }), Object.defineProperty(s.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), (0, w.default)(h.prototype, {
            isVector4: !0,
            set: function (t, e, i, r) {
                return this.x = t, this.y = e, this.z = i, this.w = r, this
            },
            setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            },
            setX: function (t) {
                return this.x = t, this
            },
            setY: function (t) {
                return this.y = t, this
            },
            setZ: function (t) {
                return this.z = t, this
            },
            setW: function (t) {
                return this.w = t, this
            },
            setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function (t, e) {
                return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function (t, e) {
                return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function (t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function (t) {
                var e = this.x,
                    i = this.y,
                    r = this.z,
                    n = this.w,
                    o = t.elements;
                return this.x = o[0] * e + o[4] * i + o[8] * r + o[12] * n, this.y = o[1] * e + o[5] * i + o[9] * r + o[13] * n, this.z = o[2] * e + o[6] * i + o[10] * r + o[14] * n, this.w = o[3] * e + o[7] * i + o[11] * r + o[15] * n, this
            },
            divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function (t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function (t) {
                var e, i, r, n, o = t.elements,
                    a = o[0],
                    s = o[4],
                    l = o[8],
                    h = o[1],
                    c = o[5],
                    u = o[9],
                    p = o[2],
                    f = o[6],
                    d = o[10];
                if (Math.abs(s - h) < .01 && Math.abs(l - p) < .01 && Math.abs(u - f) < .01) {
                    if (Math.abs(s + h) < .1 && Math.abs(l + p) < .1 && Math.abs(u + f) < .1 && Math.abs(a + c + d - 3) < .1) return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var m = (a + 1) / 2,
                        g = (c + 1) / 2,
                        v = (d + 1) / 2,
                        y = (s + h) / 4,
                        A = (l + p) / 4,
                        x = (u + f) / 4;
                    return m > g && m > v ? m < .01 ? (i = 0, r = .707106781, n = .707106781) : (i = Math.sqrt(m), r = y / i, n = A / i) : g > v ? g < .01 ? (i = .707106781, r = 0, n = .707106781) : (r = Math.sqrt(g), i = y / r, n = x / r) : v < .01 ? (i = .707106781, r = .707106781, n = 0) : (n = Math.sqrt(v), i = A / n, r = x / n), this.set(i, r, n, e), this
                }
                var _ = Math.sqrt((f - u) * (f - u) + (l - p) * (l - p) + (h - s) * (h - s));
                return Math.abs(_) < .001 && (_ = 1), this.x = (f - u) / _, this.y = (l - p) / _, this.z = (h - s) / _, this.w = Math.acos((a + c + d - 1) / 2), this
            },
            min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function () {
                var t, e;
                return function (i, r) {
                    return void 0 === t && (t = new h, e = new h), t.set(i, i, i, i), e.set(r, r, r, r), this.clamp(t, e)
                }
            }(),
            clampLength: function (t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function (t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function (t, e, i) {
                return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), u.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: u,
            isWebGLRenderTarget: !0,
            setSize: function (t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), f.prototype = (0, y.default)(u.prototype), f.prototype.constructor = f, f.prototype.isWebGLRenderTargetCube = !0, m.prototype = (0, y.default)(s.prototype), m.prototype.constructor = m, m.prototype.isDataTexture = !0, (0, w.default)(v.prototype, {
            isBox3: !0,
            set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function (t) {
                for (var e = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.length; s < l; s += 3) {
                    var h = t[s],
                        c = t[s + 1],
                        u = t[s + 2];
                    h < e && (e = h), c < i && (i = c), u < r && (r = u), h > n && (n = h), c > o && (o = c), u > a && (a = u)
                }
                return this.min.set(e, i, r), this.max.set(n, o, a), this
            },
            setFromBufferAttribute: function (t) {
                for (var e = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.count; s < l; s++) {
                    var h = t.getX(s),
                        c = t.getY(s),
                        u = t.getZ(s);
                    h < e && (e = h), c < i && (i = c), u < r && (r = u), h > n && (n = h), c > o && (o = c), u > a && (a = u)
                }
                return this.min.set(e, i, r), this.max.set(n, o, a), this
            },
            setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function () {
                var t = new o;
                return function (e, i) {
                    var r = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                }
            }(),
            setFromObject: function (t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function (t) {
                return void 0 === t && (t = new o), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (t) {
                return void 0 === t && (t = new o), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: function () {
                function t(t) {
                    var o = t.geometry;
                    if (void 0 !== o)
                        if (o.isGeometry) {
                            var a = o.vertices;
                            for (i = 0, r = a.length; i < r; i++) n.copy(a[i]), n.applyMatrix4(t.matrixWorld), e.expandByPoint(n)
                        } else if (o.isBufferGeometry) {
                        var s = o.attributes.position;
                        if (void 0 !== s)
                            for (i = 0, r = s.count; i < r; i++) n.fromBufferAttribute(s, i).applyMatrix4(t.matrixWorld), e.expandByPoint(n)
                    }
                }
                var e, i, r, n = new o;
                return function (i) {
                    return e = this, i.updateMatrixWorld(!0), i.traverse(t), this
                }
            }(),
            containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function (t, e) {
                return void 0 === e && (e = new o), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function () {
                var t = new o;
                return function (e) {
                    return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }(),
            intersectsPlane: function (t) {
                var e, i;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
            },
            intersectsTriangle: function () {
                function t(t) {
                    var n, o;
                    for (n = 0, o = t.length - 3; n <= o; n += 3) {
                        l.fromArray(t, n);
                        var a = c.x * Math.abs(l.x) + c.y * Math.abs(l.y) + c.z * Math.abs(l.z),
                            s = e.dot(l),
                            h = i.dot(l),
                            u = r.dot(l);
                        if (Math.max(-Math.max(s, h, u), Math.min(s, h, u)) > a) return !1
                    }
                    return !0
                }
                var e = new o,
                    i = new o,
                    r = new o,
                    n = new o,
                    a = new o,
                    s = new o,
                    l = new o,
                    h = new o,
                    c = new o,
                    u = new o;
                return function (o) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(h), c.subVectors(this.max, h), e.subVectors(o.a, h), i.subVectors(o.b, h), r.subVectors(o.c, h), n.subVectors(i, e), a.subVectors(r, i), s.subVectors(e, r);
                    var l = [0, -n.z, n.y, 0, -a.z, a.y, 0, -s.z, s.y, n.z, 0, -n.x, a.z, 0, -a.x, s.z, 0, -s.x, -n.y, n.x, 0, -a.y, a.x, 0, -s.y, s.x, 0];
                    return !!t(l) && (l = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!t(l) && (u.crossVectors(n, a), l = [u.x, u.y, u.z], t(l)))
                }
            }(),
            clampPoint: function (t, e) {
                return void 0 === e && (e = new o), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function () {
                var t = new o;
                return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            getBoundingSphere: function () {
                var t = new o;
                return function (e) {
                    return void 0 === e && (e = new A), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                }
            }(),
            intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: function () {
                var t = [new o, new o, new o, new o, new o, new o, new o, new o];
                return function (e) {
                    return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                }
            }(),
            translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), (0, w.default)(A.prototype, {
            set: function (t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: function () {
                var t = new v;
                return function (e, i) {
                    var r = this.center;
                    void 0 !== i ? r.copy(i) : t.setFromPoints(e).getCenter(r);
                    for (var n = 0, o = 0, a = e.length; o < a; o++) n = Math.max(n, r.distanceToSquared(e[o]));
                    return this.radius = Math.sqrt(n), this
                }
            }(),
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            empty: function () {
                return this.radius <= 0
            },
            containsPoint: function (t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function (t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function (t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function (t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function (t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function (t, e) {
                var i = this.center.distanceToSquared(t);
                return void 0 === e && (e = new o), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            },
            getBoundingBox: function (t) {
                return void 0 === t && (t = new v), t.set(this.center, this.center), t.expandByScalar(this.radius), t
            },
            applyMatrix4: function (t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            },
            translate: function (t) {
                return this.center.add(t), this
            },
            equals: function (t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }), (0, w.default)(_.prototype, {
            set: function (t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function (t, e, i, r) {
                return this.normal.set(t, e, i), this.constant = r, this
            },
            setFromNormalAndCoplanarPoint: function (t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: function () {
                var t = new o,
                    e = new o;
                return function (i, r, n) {
                    var o = t.subVectors(n, r).cross(e.subVectors(i, r)).normalize();
                    return this.setFromNormalAndCoplanarPoint(o, i), this
                }
            }(),
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function () {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function () {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function (t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function (t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function (t, e) {
                return void 0 === e && (e = new o), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            },
            intersectLine: function () {
                var t = new o;
                return function (e, i) {
                    void 0 === i && (i = new o);
                    var r = e.delta(t),
                        n = this.normal.dot(r);
                    if (0 !== n) {
                        var a = -(e.start.dot(this.normal) + this.constant) / n;
                        if (!(a < 0 || a > 1)) return i.copy(r).multiplyScalar(a).add(e.start)
                    } else if (0 === this.distanceToPoint(e.start)) return i.copy(e.start)
                }
            }(),
            intersectsLine: function (t) {
                var e = this.distanceToPoint(t.start),
                    i = this.distanceToPoint(t.end);
                return e < 0 && i > 0 || i < 0 && e > 0
            },
            intersectsBox: function (t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function (t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function (t) {
                return void 0 === t && (t = new o), t.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function () {
                var t = new o,
                    e = new a;
                return function (i, r) {
                    var n = r || e.getNormalMatrix(i),
                        o = this.coplanarPoint(t).applyMatrix4(i),
                        a = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -o.dot(a), this
                }
            }(),
            translate: function (t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function (t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }), (0, w.default)(b.prototype, {
            set: function (t, e, i, r, n, o) {
                var a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(r), a[4].copy(n), a[5].copy(o), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                return this
            },
            setFromMatrix: function (t) {
                var e = this.planes,
                    i = t.elements,
                    r = i[0],
                    n = i[1],
                    o = i[2],
                    a = i[3],
                    s = i[4],
                    l = i[5],
                    h = i[6],
                    c = i[7],
                    u = i[8],
                    p = i[9],
                    f = i[10],
                    d = i[11],
                    m = i[12],
                    g = i[13],
                    v = i[14],
                    y = i[15];
                return e[0].setComponents(a - r, c - s, d - u, y - m).normalize(), e[1].setComponents(a + r, c + s, d + u, y + m).normalize(), e[2].setComponents(a + n, c + l, d + p, y + g).normalize(), e[3].setComponents(a - n, c - l, d - p, y - g).normalize(), e[4].setComponents(a - o, c - h, d - f, y - v).normalize(), e[5].setComponents(a + o, c + h, d + f, y + v).normalize(), this
            },
            intersectsObject: function () {
                var t = new A;
                return function (e) {
                    var i = e.geometry;
                    return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSprite: function () {
                var t = new A;
                return function (e) {
                    return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSphere: function (t) {
                for (var e = this.planes, i = t.center, r = -t.radius, n = 0; n < 6; n++) {
                    if (e[n].distanceToPoint(i) < r) return !1
                }
                return !0
            },
            intersectsBox: function () {
                var t = new o,
                    e = new o;
                return function (i) {
                    for (var r = this.planes, n = 0; n < 6; n++) {
                        var o = r[n];
                        t.x = o.normal.x > 0 ? i.min.x : i.max.x, e.x = o.normal.x > 0 ? i.max.x : i.min.x, t.y = o.normal.y > 0 ? i.min.y : i.max.y, e.y = o.normal.y > 0 ? i.max.y : i.min.y, t.z = o.normal.z > 0 ? i.min.z : i.max.z, e.z = o.normal.z > 0 ? i.max.z : i.min.z;
                        var a = o.distanceToPoint(t),
                            s = o.distanceToPoint(e);
                        if (a < 0 && s < 0) return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function (t) {
                for (var e = this.planes, i = 0; i < 6; i++)
                    if (e[i].distanceToPoint(t) < 0) return !1;
                return !0
            }
        });
        var bl = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
                lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
                normal_fragment_maps: "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
            },
            Ml = {
                merge: function (t) {
                    for (var e = {}, i = 0; i < t.length; i++) {
                        var r = this.clone(t[i]);
                        for (var n in r) e[n] = r[n]
                    }
                    return e
                },
                clone: function (t) {
                    var e = {};
                    for (var i in t) {
                        e[i] = {};
                        for (var r in t[i]) {
                            var n = t[i][r];
                            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture) ? e[i][r] = n.clone() : Array.isArray(n) ? e[i][r] = n.slice() : e[i][r] = n
                        }
                    }
                    return e
                }
            },
            Tl = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };
        (0, w.default)(T.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function (t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function (t) {
                return this.r = t, this.g = t, this.b = t, this
            },
            setHex: function (t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function (t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            },
            setHSL: function () {
                function t(t, e, i) {
                    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                }
                return function (e, i, r) {
                    if (e = _l.euclideanModulo(e, 1), i = _l.clamp(i, 0, 1), r = _l.clamp(r, 0, 1), 0 === i) this.r = this.g = this.b = r;
                    else {
                        var n = r <= .5 ? r * (1 + i) : r + i - r * i,
                            o = 2 * r - n;
                        this.r = t(o, n, e + 1 / 3), this.g = t(o, n, e), this.b = t(o, n, e - 1 / 3)
                    }
                    return this
                }
            }(),
            setStyle: function (t) {
                function e(t) {
                    void 0 !== t && parseFloat(t)
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var r, n = i[1],
                        o = i[2];
                    switch (n) {
                        case "rgb":
                        case "rgba":
                            if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                            if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                var a = parseFloat(r[1]) / 360,
                                    s = parseInt(r[2], 10) / 100,
                                    l = parseInt(r[3], 10) / 100;
                                return e(r[5]), this.setHSL(a, s, l)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var h = i[1],
                        c = h.length;
                    if (3 === c) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                    if (6 === c) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
                }
                if (t && t.length > 0) {
                    var h = Tl[t];
                    void 0 !== h && this.setHex(h)
                }
                return this
            },
            clone: function () {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function (t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function (t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function (t, e) {
                void 0 === e && (e = 2);
                var i = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
            },
            convertGammaToLinear: function () {
                var t = this.r,
                    e = this.g,
                    i = this.b;
                return this.r = t * t, this.g = e * e, this.b = i * i, this
            },
            convertLinearToGamma: function () {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            },
            getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function (t) {
                void 0 === t && (t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var e, i, r = this.r,
                    n = this.g,
                    o = this.b,
                    a = Math.max(r, n, o),
                    s = Math.min(r, n, o),
                    l = (s + a) / 2;
                if (s === a) e = 0, i = 0;
                else {
                    var h = a - s;
                    switch (i = l <= .5 ? h / (a + s) : h / (2 - a - s), a) {
                        case r:
                            e = (n - o) / h + (n < o ? 6 : 0);
                            break;
                        case n:
                            e = (o - r) / h + 2;
                            break;
                        case o:
                            e = (r - n) / h + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = i, t.l = l, t
            },
            getStyle: function () {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function () {
                var t = {};
                return function (e, i, r) {
                    return this.getHSL(t), t.h += e, t.s += i, t.l += r, this.setHSL(t.h, t.s, t.l), this
                }
            }(),
            add: function (t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function (t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function (t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function (t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function (t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function (t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function (t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            equals: function (t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function () {
                return this.getHex()
            }
        });
        var Sl = {
                common: {
                    diffuse: {
                        value: new T(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new a
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new i(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new T(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new T(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new a
                    }
                }
            },
            El = {
                basic: {
                    uniforms: Ml.merge([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.fog]),
                    vertexShader: bl.meshbasic_vert,
                    fragmentShader: bl.meshbasic_frag
                },
                lambert: {
                    uniforms: Ml.merge([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.fog, Sl.lights, {
                        emissive: {
                            value: new T(0)
                        }
                    }]),
                    vertexShader: bl.meshlambert_vert,
                    fragmentShader: bl.meshlambert_frag
                },
                phong: {
                    uniforms: Ml.merge([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.gradientmap, Sl.fog, Sl.lights, {
                        emissive: {
                            value: new T(0)
                        },
                        specular: {
                            value: new T(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: bl.meshphong_vert,
                    fragmentShader: bl.meshphong_frag
                },
                standard: {
                    uniforms: Ml.merge([Sl.common, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.roughnessmap, Sl.metalnessmap, Sl.fog, Sl.lights, {
                        emissive: {
                            value: new T(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: bl.meshphysical_vert,
                    fragmentShader: bl.meshphysical_frag
                },
                points: {
                    uniforms: Ml.merge([Sl.points, Sl.fog]),
                    vertexShader: bl.points_vert,
                    fragmentShader: bl.points_frag
                },
                dashed: {
                    uniforms: Ml.merge([Sl.common, Sl.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: bl.linedashed_vert,
                    fragmentShader: bl.linedashed_frag
                },
                depth: {
                    uniforms: Ml.merge([Sl.common, Sl.displacementmap]),
                    vertexShader: bl.depth_vert,
                    fragmentShader: bl.depth_frag
                },
                normal: {
                    uniforms: Ml.merge([Sl.common, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: bl.normal_vert,
                    fragmentShader: bl.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: bl.cube_vert,
                    fragmentShader: bl.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: bl.equirect_vert,
                    fragmentShader: bl.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Ml.merge([Sl.common, Sl.displacementmap, {
                        referencePosition: {
                            value: new o
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: bl.distanceRGBA_vert,
                    fragmentShader: bl.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Ml.merge([Sl.lights, Sl.fog, {
                        color: {
                            value: new T(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: bl.shadow_vert,
                    fragmentShader: bl.shadow_frag
                }
            };
        El.physical = {
            uniforms: Ml.merge([El.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: bl.meshphysical_vert,
            fragmentShader: bl.meshphysical_frag
        }, P.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], P.DefaultOrder = "XYZ", (0, x.default)(P.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            order: {
                get: function () {
                    return this._order
                },
                set: function (t) {
                    this._order = t, this.onChangeCallback()
                }
            }
        }), (0, w.default)(P.prototype, {
            isEuler: !0,
            set: function (t, e, i, r) {
                return this._x = t, this._y = e, this._z = i, this._order = r || this._order, this.onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function (t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function (t, e, i) {
                var r = _l.clamp,
                    n = t.elements,
                    o = n[0],
                    a = n[4],
                    s = n[8],
                    l = n[1],
                    h = n[5],
                    c = n[9],
                    u = n[2],
                    p = n[6],
                    f = n[10];
                return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-c, f), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(s, f), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-a, h)) : (this._y = 0, this._z = Math.atan2(l, o))) : "ZYX" === e ? (this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, h))) : "YZX" === e ? (this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-c, h), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, f))) : "XZY" === e && (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-c, f), this._y = 0)), this._order = e, !1 !== i && this.onChangeCallback(), this
            },
            setFromQuaternion: function () {
                var t = new r;
                return function (e, i, r) {
                    return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, r)
                }
            }(),
            setFromVector3: function (t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function () {
                var t = new n;
                return function (e) {
                    return t.setFromEuler(this), this.setFromQuaternion(t, e)
                }
            }(),
            equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function (t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function (t) {
                return t ? t.set(this._x, this._y, this._z) : new o(this._x, this._y, this._z)
            },
            onChange: function (t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function () {}
        }), (0, w.default)(D.prototype, {
            set: function (t) {
                this.mask = 1 << t | 0
            },
            enable: function (t) {
                this.mask |= 1 << t | 0
            },
            toggle: function (t) {
                this.mask ^= 1 << t | 0
            },
            disable: function (t) {
                this.mask &= ~(1 << t | 0)
            },
            test: function (t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var Cl = 0;
        R.DefaultUp = new o(0, 1, 0), R.DefaultMatrixAutoUpdate = !0, R.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: R,
            isObject3D: !0,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix: function (t) {
                this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function (t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function (t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function (t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function (t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function (t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function () {
                var t = new n;
                return function (e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
                }
            }(),
            rotateOnWorldAxis: function () {
                var t = new n;
                return function (e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
                }
            }(),
            rotateX: function () {
                var t = new o(1, 0, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateY: function () {
                var t = new o(0, 1, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateZ: function () {
                var t = new o(0, 0, 1);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            translateOnAxis: function () {
                var t = new o;
                return function (e, i) {
                    return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                }
            }(),
            translateX: function () {
                var t = new o(1, 0, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateY: function () {
                var t = new o(0, 1, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateZ: function () {
                var t = new o(0, 0, 1);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            localToWorld: function (t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function () {
                var t = new r;
                return function (e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function () {
                var t = new r,
                    e = new o;
                return function (i, r, n) {
                    i.isVector3 ? e.copy(i) : e.set(i, r, n), this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            add: function (t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function (t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var i = this.children.indexOf(t);
                return -1 !== i && (t.parent = null, t.dispatchEvent({
                    type: "removed"
                }), this.children.splice(i, 1)), this
            },
            getObjectById: function (t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function (t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function (t, e) {
                if (this[t] === e) return this;
                for (var i = 0, r = this.children.length; i < r; i++) {
                    var n = this.children[i],
                        o = n.getObjectByProperty(t, e);
                    if (void 0 !== o) return o
                }
            },
            getWorldPosition: function (t) {
                return void 0 === t && (t = new o), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function () {
                var t = new o,
                    e = new o;
                return function (i) {
                    return void 0 === i && (i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                }
            }(),
            getWorldScale: function () {
                var t = new o,
                    e = new n;
                return function (i) {
                    return void 0 === i && (i = new o), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                }
            }(),
            getWorldDirection: function () {
                var t = new n;
                return function (e) {
                    return void 0 === e && (e = new o), this.getWorldQuaternion(t), e.set(0, 0, 1).applyQuaternion(t)
                }
            }(),
            raycast: function () {},
            traverse: function (t) {
                t(this);
                for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].traverse(t)
            },
            traverseVisible: function (t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function (t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function (t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].updateMatrixWorld(t)
            },
            toJSON: function (t) {
                function e(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                }

                function i(t) {
                    var e = [];
                    for (var i in t) {
                        var r = t[i];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
                var r = void 0 === t || "string" == typeof t,
                    n = {};
                r && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var o = {};
                if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== (0, d.default)(this.userData) && (o.userData = this.userData), o.matrix = this.matrix.toArray(), void 0 !== this.geometry) {
                    o.geometry = e(t.geometries, this.geometry);
                    var a = this.geometry.parameters;
                    if (void 0 !== a && void 0 !== a.shapes) {
                        var s = a.shapes;
                        if (Array.isArray(s))
                            for (var l = 0, h = s.length; l < h; l++) {
                                var c = s[l];
                                e(t.shapes, c)
                            } else e(t.shapes, s)
                    }
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (var u = [], l = 0, h = this.material.length; l < h; l++) u.push(e(t.materials, this.material[l]));
                        o.material = u
                    } else o.material = e(t.materials, this.material);
                if (this.children.length > 0) {
                    o.children = [];
                    for (var l = 0; l < this.children.length; l++) o.children.push(this.children[l].toJSON(t).object)
                }
                if (r) {
                    var p = i(t.geometries),
                        f = i(t.materials),
                        m = i(t.textures),
                        g = i(t.images),
                        s = i(t.shapes);
                    p.length > 0 && (n.geometries = p), f.length > 0 && (n.materials = f), m.length > 0 && (n.textures = m), g.length > 0 && (n.images = g), s.length > 0 && (n.shapes = s)
                }
                return n.object = o, n
            },
            clone: function (t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function (t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse((0, d.default)(t.userData)), !0 === e)
                    for (var i = 0; i < t.children.length; i++) {
                        var r = t.children[i];
                        this.add(r.clone())
                    }
                return this
            }
        }), I.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: I,
            isCamera: !0,
            copy: function (t, e) {
                return R.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
            },
            getWorldDirection: function () {
                var t = new n;
                return function (e) {
                    return void 0 === e && (e = new o), this.getWorldQuaternion(t), e.set(0, 0, -1).applyQuaternion(t)
                }
            }(),
            updateMatrixWorld: function (t) {
                R.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), O.prototype = (0, w.default)((0, y.default)(I.prototype), {
            constructor: O,
            isOrthographicCamera: !0,
            copy: function (t, e) {
                return I.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : (0, w.default)({}, t.view), this
            },
            setViewOffset: function (t, e, i, r, n, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2,
                    n = i - t,
                    o = i + t,
                    a = r + e,
                    s = r - e;
                if (null !== this.view && this.view.enabled) {
                    var l = this.zoom / (this.view.width / this.view.fullWidth),
                        h = this.zoom / (this.view.height / this.view.fullHeight),
                        c = (this.right - this.left) / this.view.width,
                        u = (this.top - this.bottom) / this.view.height;
                    n += c * (this.view.offsetX / l), o = n + c * (this.view.width / l), a -= u * (this.view.offsetY / h), s = a - u * (this.view.height / h)
                }
                this.projectionMatrix.makeOrthographic(n, o, a, s, this.near, this.far)
            },
            toJSON: function (t) {
                var e = R.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = (0, w.default)({}, this.view)), e
            }
        }), (0, w.default)(B.prototype, {
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        });
        var Pl = 0;
        N.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: N,
            isGeometry: !0,
            applyMatrix: function (t) {
                for (var e = (new a).getNormalMatrix(t), i = 0, r = this.vertices.length; i < r; i++) {
                    this.vertices[i].applyMatrix4(t)
                }
                for (var i = 0, r = this.faces.length; i < r; i++) {
                    var n = this.faces[i];
                    n.normal.applyMatrix3(e).normalize();
                    for (var o = 0, s = n.vertexNormals.length; o < s; o++) n.vertexNormals[o].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function () {
                var t = new r;
                return function (e, i, r) {
                    return t.makeTranslation(e, i, r), this.applyMatrix(t), this
                }
            }(),
            scale: function () {
                var t = new r;
                return function (e, i, r) {
                    return t.makeScale(e, i, r), this.applyMatrix(t), this
                }
            }(),
            lookAt: function () {
                var t = new R;
                return function (e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            fromBufferGeometry: function (t) {
                function e(t, e, i, n) {
                    var o = void 0 !== l ? [p[t].clone(), p[e].clone(), p[i].clone()] : [],
                        a = void 0 !== h ? [r.colors[t].clone(), r.colors[e].clone(), r.colors[i].clone()] : [],
                        s = new B(t, e, i, o, a, n);
                    r.faces.push(s), void 0 !== c && r.faceVertexUvs[0].push([f[t].clone(), f[e].clone(), f[i].clone()]), void 0 !== u && r.faceVertexUvs[1].push([d[t].clone(), d[e].clone(), d[i].clone()])
                }
                var r = this,
                    n = null !== t.index ? t.index.array : void 0,
                    a = t.attributes,
                    s = a.position.array,
                    l = void 0 !== a.normal ? a.normal.array : void 0,
                    h = void 0 !== a.color ? a.color.array : void 0,
                    c = void 0 !== a.uv ? a.uv.array : void 0,
                    u = void 0 !== a.uv2 ? a.uv2.array : void 0;
                void 0 !== u && (this.faceVertexUvs[1] = []);
                for (var p = [], f = [], d = [], m = 0, g = 0; m < s.length; m += 3, g += 2) r.vertices.push(new o(s[m], s[m + 1], s[m + 2])), void 0 !== l && p.push(new o(l[m], l[m + 1], l[m + 2])), void 0 !== h && r.colors.push(new T(h[m], h[m + 1], h[m + 2])), void 0 !== c && f.push(new i(c[g], c[g + 1])), void 0 !== u && d.push(new i(u[g], u[g + 1]));
                var v = t.groups;
                if (v.length > 0)
                    for (var m = 0; m < v.length; m++)
                        for (var y = v[m], A = y.start, x = y.count, g = A, _ = A + x; g < _; g += 3) void 0 !== n ? e(n[g], n[g + 1], n[g + 2], y.materialIndex) : e(g, g + 1, g + 2, y.materialIndex);
                else if (void 0 !== n)
                    for (var m = 0; m < n.length; m += 3) e(n[m], n[m + 1], n[m + 2]);
                else
                    for (var m = 0; m < s.length / 3; m += 3) e(m, m + 1, m + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function () {
                var t = new o;
                return function () {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                }
            }(),
            normalize: function () {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    i = 0 === e ? 1 : 1 / e,
                    n = new r;
                return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
            },
            computeFaceNormals: function () {
                for (var t = new o, e = new o, i = 0, r = this.faces.length; i < r; i++) {
                    var n = this.faces[i],
                        a = this.vertices[n.a],
                        s = this.vertices[n.b],
                        l = this.vertices[n.c];
                    t.subVectors(l, s), e.subVectors(a, s), t.cross(e), t.normalize(), n.normal.copy(t)
                }
            },
            computeVertexNormals: function (t) {
                void 0 === t && (t = !0);
                var e, i, r, n, a, s;
                for (s = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) s[e] = new o;
                if (t) {
                    var l, h, c, u = new o,
                        p = new o;
                    for (r = 0, n = this.faces.length; r < n; r++) a = this.faces[r], l = this.vertices[a.a], h = this.vertices[a.b], c = this.vertices[a.c], u.subVectors(c, h), p.subVectors(l, h), u.cross(p), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u)
                } else
                    for (this.computeFaceNormals(), r = 0, n = this.faces.length; r < n; r++) a = this.faces[r], s[a.a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
                for (e = 0, i = this.vertices.length; e < i; e++) s[e].normalize();
                for (r = 0, n = this.faces.length; r < n; r++) {
                    a = this.faces[r];
                    var f = a.vertexNormals;
                    3 === f.length ? (f[0].copy(s[a.a]), f[1].copy(s[a.b]), f[2].copy(s[a.c])) : (f[0] = s[a.a].clone(), f[1] = s[a.b].clone(), f[2] = s[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function () {
                var t, e, i;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    i = this.faces[t];
                    var r = i.vertexNormals;
                    3 === r.length ? (r[0].copy(i.normal), r[1].copy(i.normal), r[2].copy(i.normal)) : (r[0] = i.normal.clone(), r[1] = i.normal.clone(), r[2] = i.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function () {
                var t, e, i, r, n;
                for (i = 0, r = this.faces.length; i < r; i++)
                    for (n = this.faces[i], n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []), t = 0, e = n.vertexNormals.length; t < e; t++) n.__originalVertexNormals[t] ? n.__originalVertexNormals[t].copy(n.vertexNormals[t]) : n.__originalVertexNormals[t] = n.vertexNormals[t].clone();
                var a = new N;
                for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        var s, l, h = this.morphNormals[t].faceNormals,
                            c = this.morphNormals[t].vertexNormals;
                        for (i = 0, r = this.faces.length; i < r; i++) s = new o, l = {
                            a: new o,
                            b: new o,
                            c: new o
                        }, h.push(s), c.push(l)
                    }
                    var u = this.morphNormals[t];
                    a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                    var s, l;
                    for (i = 0, r = this.faces.length; i < r; i++) n = this.faces[i], s = u.faceNormals[i], l = u.vertexNormals[i], s.copy(n.normal), l.a.copy(n.vertexNormals[0]), l.b.copy(n.vertexNormals[1]), l.c.copy(n.vertexNormals[2])
                }
                for (i = 0, r = this.faces.length; i < r; i++) n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new v), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new A), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function (t, e, i) {
                if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                var r, n = this.vertices.length,
                    o = this.vertices,
                    s = t.vertices,
                    l = this.faces,
                    h = t.faces,
                    c = this.faceVertexUvs[0],
                    u = t.faceVertexUvs[0],
                    p = this.colors,
                    f = t.colors;
                void 0 === i && (i = 0), void 0 !== e && (r = (new a).getNormalMatrix(e));
                for (var d = 0, m = s.length; d < m; d++) {
                    var g = s[d],
                        v = g.clone();
                    void 0 !== e && v.applyMatrix4(e), o.push(v)
                }
                for (var d = 0, m = f.length; d < m; d++) p.push(f[d].clone());
                for (d = 0, m = h.length; d < m; d++) {
                    var y, A, x, _ = h[d],
                        w = _.vertexNormals,
                        b = _.vertexColors;
                    y = new B(_.a + n, _.b + n, _.c + n), y.normal.copy(_.normal), void 0 !== r && y.normal.applyMatrix3(r).normalize();
                    for (var M = 0, T = w.length; M < T; M++) A = w[M].clone(), void 0 !== r && A.applyMatrix3(r).normalize(), y.vertexNormals.push(A);
                    y.color.copy(_.color);
                    for (var M = 0, T = b.length; M < T; M++) x = b[M], y.vertexColors.push(x.clone());
                    y.materialIndex = _.materialIndex + i, l.push(y)
                }
                for (d = 0, m = u.length; d < m; d++) {
                    var S = u[d],
                        E = [];
                    if (void 0 !== S) {
                        for (var M = 0, T = S.length; M < T; M++) E.push(S[M].clone());
                        c.push(E)
                    }
                }
            },
            mergeMesh: function (t) {
                if (!t || !t.isMesh) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
                t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)
            },
            mergeVertices: function () {
                var t, e, i, r, n, o, a, s, l = {},
                    h = [],
                    c = [],
                    u = Math.pow(10, 4);
                for (i = 0, r = this.vertices.length; i < r; i++) t = this.vertices[i], e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u), void 0 === l[e] ? (l[e] = i, h.push(this.vertices[i]), c[i] = h.length - 1) : c[i] = c[l[e]];
                var p = [];
                for (i = 0, r = this.faces.length; i < r; i++) {
                    n = this.faces[i], n.a = c[n.a], n.b = c[n.b], n.c = c[n.c], o = [n.a, n.b, n.c];
                    for (var f = 0; f < 3; f++)
                        if (o[f] === o[(f + 1) % 3]) {
                            p.push(i);
                            break
                        }
                }
                for (i = p.length - 1; i >= 0; i--) {
                    var d = p[i];
                    for (this.faces.splice(d, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(d, 1)
                }
                var m = this.vertices.length - h.length;
                return this.vertices = h, m
            },
            setFromPoints: function (t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var r = t[e];
                    this.vertices.push(new o(r.x, r.y, r.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function () {
                function t(t, e) {
                    return t.materialIndex - e.materialIndex
                }
                for (var e = this.faces, i = e.length, r = 0; r < i; r++) e[r]._id = r;
                e.sort(t);
                var n, o, a = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1];
                a && a.length === i && (n = []), s && s.length === i && (o = []);
                for (var r = 0; r < i; r++) {
                    var l = e[r]._id;
                    n && n.push(a[l]), o && o.push(s[l])
                }
                n && (this.faceVertexUvs[0] = n), o && (this.faceVertexUvs[1] = o)
            },
            toJSON: function () {
                function t(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== p[e] ? p[e] : (p[e] = u.length / 3, u.push(t.x, t.y, t.z), p[e])
                }

                function i(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== d[e] ? d[e] : (d[e] = f.length, f.push(t.getHex()), d[e])
                }

                function r(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2, m.push(t.x, t.y), g[e])
                }
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), void 0 !== this.parameters) {
                    var o = this.parameters;
                    for (var a in o) void 0 !== o[a] && (n[a] = o[a]);
                    return n
                }
                for (var s = [], l = 0; l < this.vertices.length; l++) {
                    var h = this.vertices[l];
                    s.push(h.x, h.y, h.z)
                }
                for (var c = [], u = [], p = {}, f = [], d = {}, m = [], g = {}, l = 0; l < this.faces.length; l++) {
                    var v = this.faces[l],
                        y = void 0 !== this.faceVertexUvs[0][l],
                        A = v.normal.length() > 0,
                        x = v.vertexNormals.length > 0,
                        _ = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                        w = v.vertexColors.length > 0,
                        b = 0;
                    if (b = t(b, 0, 0), b = t(b, 1, !0), b = t(b, 2, !1), b = t(b, 3, y), b = t(b, 4, A), b = t(b, 5, x), b = t(b, 6, _), b = t(b, 7, w), c.push(b), c.push(v.a, v.b, v.c), c.push(v.materialIndex), y) {
                        var M = this.faceVertexUvs[0][l];
                        c.push(r(M[0]), r(M[1]), r(M[2]))
                    }
                    if (A && c.push(e(v.normal)), x) {
                        var T = v.vertexNormals;
                        c.push(e(T[0]), e(T[1]), e(T[2]))
                    }
                    if (_ && c.push(i(v.color)), w) {
                        var S = v.vertexColors;
                        c.push(i(S[0]), i(S[1]), i(S[2]))
                    }
                }
                return n.data = {}, n.data.vertices = s, n.data.normals = u, f.length > 0 && (n.data.colors = f), m.length > 0 && (n.data.uvs = [m]), n.data.faces = c, n
            },
            clone: function () {
                return (new N).copy(this)
            },
            copy: function (t) {
                var e, i, r, n, o, a;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var s = t.vertices;
                for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
                var l = t.colors;
                for (e = 0, i = l.length; e < i; e++) this.colors.push(l[e].clone());
                var h = t.faces;
                for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
                for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                    var c = t.faceVertexUvs[e];
                    for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), r = 0, n = c.length; r < n; r++) {
                        var u = c[r],
                            p = [];
                        for (o = 0, a = u.length; o < a; o++) {
                            var f = u[o];
                            p.push(f.clone())
                        }
                        this.faceVertexUvs[e].push(p)
                    }
                }
                var d = t.morphTargets;
                for (e = 0, i = d.length; e < i; e++) {
                    var m = {};
                    if (m.name = d[e].name, void 0 !== d[e].vertices)
                        for (m.vertices = [], r = 0, n = d[e].vertices.length; r < n; r++) m.vertices.push(d[e].vertices[r].clone());
                    if (void 0 !== d[e].normals)
                        for (m.normals = [], r = 0, n = d[e].normals.length; r < n; r++) m.normals.push(d[e].normals[r].clone());
                    this.morphTargets.push(m)
                }
                var g = t.morphNormals;
                for (e = 0, i = g.length; e < i; e++) {
                    var v = {};
                    if (void 0 !== g[e].vertexNormals)
                        for (v.vertexNormals = [], r = 0, n = g[e].vertexNormals.length; r < n; r++) {
                            var y = g[e].vertexNormals[r],
                                A = {};
                            A.a = y.a.clone(), A.b = y.b.clone(), A.c = y.c.clone(), v.vertexNormals.push(A)
                        }
                    if (void 0 !== g[e].faceNormals)
                        for (v.faceNormals = [], r = 0, n = g[e].faceNormals.length; r < n; r++) v.faceNormals.push(g[e].faceNormals[r].clone());
                    this.morphNormals.push(v)
                }
                var x = t.skinWeights;
                for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
                var _ = t.skinIndices;
                for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
                var w = t.lineDistances;
                for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
                var b = t.boundingBox;
                null !== b && (this.boundingBox = b.clone());
                var M = t.boundingSphere;
                return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.defineProperty(k.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), (0, w.default)(k.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () {},
            setArray: function (t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
            },
            setDynamic: function (t) {
                return this.dynamic = t, this
            },
            copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            },
            copyAt: function (t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var r = 0, n = this.itemSize; r < n; r++) this.array[t + r] = e.array[i + r];
                return this
            },
            copyArray: function (t) {
                return this.array.set(t), this
            },
            copyColorsArray: function (t) {
                for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
                    var o = t[r];
                    void 0 === o && (o = new T), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                }
                return this
            },
            copyVector2sArray: function (t) {
                for (var e = this.array, r = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (a = new i), e[r++] = a.x, e[r++] = a.y
                }
                return this
            },
            copyVector3sArray: function (t) {
                for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
                    var a = t[r];
                    void 0 === a && (a = new o), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
                }
                return this
            },
            copyVector4sArray: function (t) {
                for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
                    var o = t[r];
                    void 0 === o && (o = new h), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
                }
                return this
            },
            set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function (t) {
                return this.array[t * this.itemSize]
            },
            setX: function (t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function (t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function (t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function (t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function (t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function (t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function (t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function (t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function (t, e, i, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this
            },
            setXYZW: function (t, e, i, r, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this.array[t + 3] = n, this
            },
            onUpload: function (t) {
                return this.onUploadCallback = t, this
            },
            clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
        }), F.prototype = (0, y.default)(k.prototype), F.prototype.constructor = F, z.prototype = (0, y.default)(k.prototype), z.prototype.constructor = z, U.prototype = (0, y.default)(k.prototype), U.prototype.constructor = U, G.prototype = (0, y.default)(k.prototype), G.prototype.constructor = G, V.prototype = (0, y.default)(k.prototype), V.prototype.constructor = V, H.prototype = (0, y.default)(k.prototype), H.prototype.constructor = H, j.prototype = (0, y.default)(k.prototype), j.prototype.constructor = j, W.prototype = (0, y.default)(k.prototype), W.prototype.constructor = W, Y.prototype = (0, y.default)(k.prototype), Y.prototype.constructor = Y, (0, w.default)(X.prototype, {
            computeGroups: function (t) {
                for (var e, i = [], r = void 0, n = t.faces, o = 0; o < n.length; o++) {
                    var a = n[o];
                    a.materialIndex !== r && (r = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), e = {
                        start: 3 * o,
                        materialIndex: r
                    })
                }
                void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), this.groups = i
            },
            fromGeometry: function (t) {
                var e, r = t.faces,
                    n = t.vertices,
                    o = t.faceVertexUvs,
                    a = o[0] && o[0].length > 0,
                    s = o[1] && o[1].length > 0,
                    l = t.morphTargets,
                    h = l.length;
                if (h > 0) {
                    e = [];
                    for (var c = 0; c < h; c++) e[c] = [];
                    this.morphTargets.position = e
                }
                var u, p = t.morphNormals,
                    f = p.length;
                if (f > 0) {
                    u = [];
                    for (var c = 0; c < f; c++) u[c] = [];
                    this.morphTargets.normal = u
                }
                for (var d = t.skinIndices, m = t.skinWeights, g = d.length === n.length, v = m.length === n.length, c = 0; c < r.length; c++) {
                    var y = r[c];
                    this.vertices.push(n[y.a], n[y.b], n[y.c]);
                    var A = y.vertexNormals;
                    if (3 === A.length) this.normals.push(A[0], A[1], A[2]);
                    else {
                        var x = y.normal;
                        this.normals.push(x, x, x)
                    }
                    var _ = y.vertexColors;
                    if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                    else {
                        var w = y.color;
                        this.colors.push(w, w, w)
                    }
                    if (!0 === a) {
                        var b = o[0][c];
                        void 0 !== b ? this.uvs.push(b[0], b[1], b[2]) : this.uvs.push(new i, new i, new i)
                    }
                    if (!0 === s) {
                        var b = o[1][c];
                        void 0 !== b ? this.uvs2.push(b[0], b[1], b[2]) : this.uvs2.push(new i, new i, new i)
                    }
                    for (var M = 0; M < h; M++) {
                        var T = l[M].vertices;
                        e[M].push(T[y.a], T[y.b], T[y.c])
                    }
                    for (var M = 0; M < f; M++) {
                        var S = p[M].vertexNormals[c];
                        u[M].push(S.a, S.b, S.c)
                    }
                    g && this.skinIndices.push(d[y.a], d[y.b], d[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        });
        var Ll = 1;
        J.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: J,
            isBufferGeometry: !0,
            getIndex: function () {
                return this.index
            },
            setIndex: function (t) {
                Array.isArray(t) ? this.index = new(Q(t) > 65535 ? j : V)(t, 1) : this.index = t
            },
            addAttribute: function (t, e) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? void this.setIndex(e) : (this.attributes[t] = e, this) : void this.addAttribute(t, new k(arguments[1], arguments[2]))
            },
            getAttribute: function (t) {
                return this.attributes[t]
            },
            removeAttribute: function (t) {
                return delete this.attributes[t], this
            },
            addGroup: function (t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function () {
                this.groups = []
            },
            setDrawRange: function (t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix: function (t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                var i = this.attributes.normal;
                if (void 0 !== i) {
                    (new a).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function () {
                var t = new r;
                return function (e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function () {
                var t = new r;
                return function (e, i, r) {
                    return t.makeTranslation(e, i, r), this.applyMatrix(t), this
                }
            }(),
            scale: function () {
                var t = new r;
                return function (e, i, r) {
                    return t.makeScale(e, i, r), this.applyMatrix(t), this
                }
            }(),
            lookAt: function () {
                var t = new R;
                return function (e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            center: function () {
                var t = new o;
                return function () {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                }
            }(),
            setFromObject: function (t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var i = new W(3 * e.vertices.length, 3),
                        r = new W(3 * e.colors.length, 3);
                    if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var n = new W(e.lineDistances.length, 1);
                        this.addAttribute("lineDistance", n.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            setFromPoints: function (t) {
                for (var e = [], i = 0, r = t.length; i < r; i++) {
                    var n = t[i];
                    e.push(n.x, n.y, n.z || 0)
                }
                return this.addAttribute("position", new W(e, 3)), this
            },
            updateFromObject: function (t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var i = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                    i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
                }
                var r;
                return !0 === e.verticesNeedUpdate && (r = this.attributes.position, void 0 !== r && (r.copyVector3sArray(e.vertices), r.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (r = this.attributes.normal, void 0 !== r && (r.copyVector3sArray(e.normals), r.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (r = this.attributes.color, void 0 !== r && (r.copyColorsArray(e.colors), r.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (r = this.attributes.uv, void 0 !== r && (r.copyVector2sArray(e.uvs), r.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (r = this.attributes.lineDistance, void 0 !== r && (r.copyArray(e.lineDistances), r.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function (t) {
                return t.__directGeometry = (new X).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function (t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new k(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var i = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new k(i, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var r = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new k(r, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var n = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new k(n, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var o = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new k(o, 2).copyVector2sArray(t.uvs2))
                }
                this.groups = t.groups;
                for (var a in t.morphTargets) {
                    for (var s = [], l = t.morphTargets[a], h = 0, c = l.length; h < c; h++) {
                        var u = l[h],
                            p = new W(3 * u.length, 3);
                        s.push(p.copyVector3sArray(u))
                    }
                    this.morphAttributes[a] = s
                }
                if (t.skinIndices.length > 0) {
                    var f = new W(4 * t.skinIndices.length, 4);
                    this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var d = new W(4 * t.skinWeights.length, 4);
                    this.addAttribute("skinWeight", d.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new v);
                var t = this.attributes.position;
                void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function () {
                var t = new v,
                    e = new o;
                return function () {
                    null === this.boundingSphere && (this.boundingSphere = new A);
                    var i = this.attributes.position;
                    if (i) {
                        var r = this.boundingSphere.center;
                        t.setFromBufferAttribute(i), t.getCenter(r);
                        for (var n = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), n = Math.max(n, r.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function () {},
            computeVertexNormals: function () {
                var t = this.index,
                    e = this.attributes,
                    i = this.groups;
                if (e.position) {
                    var r = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new k(new Float32Array(r.length), 3));
                    else
                        for (var n = e.normal.array, a = 0, s = n.length; a < s; a++) n[a] = 0;
                    var l, h, c, u = e.normal.array,
                        p = new o,
                        f = new o,
                        d = new o,
                        m = new o,
                        g = new o;
                    if (t) {
                        var v = t.array;
                        0 === i.length && this.addGroup(0, v.length);
                        for (var y = 0, A = i.length; y < A; ++y)
                            for (var x = i[y], _ = x.start, w = x.count, a = _, s = _ + w; a < s; a += 3) l = 3 * v[a + 0], h = 3 * v[a + 1], c = 3 * v[a + 2], p.fromArray(r, l), f.fromArray(r, h), d.fromArray(r, c), m.subVectors(d, f), g.subVectors(p, f), m.cross(g), u[l] += m.x, u[l + 1] += m.y, u[l + 2] += m.z, u[h] += m.x, u[h + 1] += m.y, u[h + 2] += m.z, u[c] += m.x, u[c + 1] += m.y, u[c + 2] += m.z
                    } else
                        for (var a = 0, s = r.length; a < s; a += 9) p.fromArray(r, a), f.fromArray(r, a + 3), d.fromArray(r, a + 6), m.subVectors(d, f), g.subVectors(p, f), m.cross(g), u[a] = m.x, u[a + 1] = m.y, u[a + 2] = m.z, u[a + 3] = m.x, u[a + 4] = m.y, u[a + 5] = m.z, u[a + 6] = m.x, u[a + 7] = m.y, u[a + 8] = m.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function (t, e) {
                if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0);
                var i = this.attributes;
                for (var r in i)
                    if (void 0 !== t.attributes[r])
                        for (var n = i[r], o = n.array, a = t.attributes[r], s = a.array, l = a.itemSize, h = 0, c = l * e; h < s.length; h++, c++) o[c] = s[h];
                return this
            },
            normalizeNormals: function () {
                var t = new o;
                return function () {
                    for (var e = this.attributes.normal, i = 0, r = e.count; i < r; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
                }
            }(),
            toNonIndexed: function () {
                if (null === this.index) return this;
                var t = new J,
                    e = this.index.array,
                    i = this.attributes;
                for (var r in i) {
                    for (var n = i[r], o = n.array, a = n.itemSize, s = new o.constructor(e.length * a), l = 0, h = 0, c = 0, u = e.length; c < u; c++) {
                        l = e[c] * a;
                        for (var p = 0; p < a; p++) s[h++] = o[l++]
                    }
                    t.addAttribute(r, new k(s, a))
                }
                for (var f = this.groups, c = 0, u = f.length; c < u; c++) {
                    var d = f[c];
                    t.addGroup(d.start, d.count, d.materialIndex)
                }
                return t
            },
            toJSON: function () {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var r = this.index;
                if (null !== r) {
                    var n = Array.prototype.slice.call(r.array);
                    t.data.index = {
                        type: r.array.constructor.name,
                        array: n
                    }
                }
                var o = this.attributes;
                for (var i in o) {
                    var a = o[i],
                        n = Array.prototype.slice.call(a.array);
                    t.data.attributes[i] = {
                        itemSize: a.itemSize,
                        type: a.array.constructor.name,
                        array: n,
                        normalized: a.normalized
                    }
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse((0, d.default)(s)));
                var l = this.boundingSphere;
                return null !== l && (t.data.boundingSphere = {
                    center: l.center.toArray(),
                    radius: l.radius
                }), t
            },
            clone: function () {
                return (new J).copy(this)
            },
            copy: function (t) {
                var e, i, r;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                var n = t.index;
                null !== n && this.setIndex(n.clone());
                var o = t.attributes;
                for (e in o) {
                    var a = o[e];
                    this.addAttribute(e, a.clone())
                }
                var s = t.morphAttributes;
                for (e in s) {
                    var l = [],
                        h = s[e];
                    for (i = 0, r = h.length; i < r; i++) l.push(h[i].clone());
                    this.morphAttributes[e] = l
                }
                var c = t.groups;
                for (i = 0, r = c.length; i < r; i++) {
                    var u = c[i];
                    this.addGroup(u.start, u.count, u.materialIndex)
                }
                var p = t.boundingBox;
                null !== p && (this.boundingBox = p.clone());
                var f = t.boundingSphere;
                return null !== f && (this.boundingSphere = f.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), q.prototype = (0, y.default)(N.prototype), q.prototype.constructor = q, Z.prototype = (0, y.default)(J.prototype), Z.prototype.constructor = Z, K.prototype = (0, y.default)(N.prototype), K.prototype.constructor = K, $.prototype = (0, y.default)(J.prototype), $.prototype.constructor = $;
        var Dl = 0;
        tt.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: tt,
            isMaterial: !0,
            onBeforeCompile: function () {},
            setValues: function (t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i = t[e];
                        if (void 0 !== i)
                            if ("shading" !== e) {
                                var r = this[e];
                                void 0 !== r && (r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[e] = "overdraw" === e ? Number(i) : i)
                            } else this.flatShading = 1 === i
                    }
            },
            toJSON: function (t) {
                function e(t) {
                    var e = [];
                    for (var i in t) {
                        var r = t[i];
                        delete r.metadata, e.push(r)
                    }
                    return e
                }
                var i = void 0 === t || "string" == typeof t;
                i && (t = {
                    textures: {},
                    images: {}
                });
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), void 0 !== this.roughness && (r.roughness = this.roughness), void 0 !== this.metalness && (r.metalness = this.metalness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), void 0 !== this.shininess && (r.shininess = this.shininess), void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (r.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (r.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(t).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(t).uuid, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(t).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(t).uuid, r.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (r.size = this.size), void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== Aa && (r.blending = this.blending), !0 === this.flatShading && (r.flatShading = this.flatShading), this.side !== pa && (r.side = this.side), this.vertexColors !== ma && (r.vertexColors = this.vertexColors), this.opacity < 1 && (r.opacity = this.opacity), !0 === this.transparent && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, 0 !== this.rotation && (r.rotation = this.rotation), 1 !== this.linewidth && (r.linewidth = this.linewidth), void 0 !== this.dashSize && (r.dashSize = this.dashSize), void 0 !== this.gapSize && (r.gapSize = this.gapSize), void 0 !== this.scale && (r.scale = this.scale), !0 === this.dithering && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (r.morphTargets = !0), !0 === this.skinning && (r.skinning = !0), !1 === this.visible && (r.visible = !1), "{}" !== (0, d.default)(this.userData) && (r.userData = this.userData), i) {
                    var n = e(t.textures),
                        o = e(t.images);
                    n.length > 0 && (r.textures = n), o.length > 0 && (r.images = o)
                }
                return r
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse((0, d.default)(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes,
                    i = null;
                if (null !== e) {
                    var r = e.length;
                    i = new Array(r);
                    for (var n = 0; n !== r; ++n) i[n] = e[n].clone()
                }
                return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), et.prototype = (0, y.default)(tt.prototype), et.prototype.constructor = et, et.prototype.isMeshBasicMaterial = !0, et.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, it.prototype = (0, y.default)(tt.prototype), it.prototype.constructor = it, it.prototype.isShaderMaterial = !0, it.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ml.clone(t.uniforms), this.defines = (0, w.default)({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, it.prototype.toJSON = function (t) {
            var e = tt.prototype.toJSON.call(this, t);
            return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
        }, (0, w.default)(rt.prototype, {
            set: function (t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function (t, e) {
                return void 0 === e && (e = new o), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function (t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: function () {
                var t = new o;
                return function (e) {
                    return this.origin.copy(this.at(e, t)), this
                }
            }(),
            closestPointToPoint: function (t, e) {
                void 0 === e && (e = new o), e.subVectors(t, this.origin);
                var i = e.dot(this.direction);
                return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
            },
            distanceToPoint: function (t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function () {
                var t = new o;
                return function (e) {
                    var i = t.subVectors(e, this.origin).dot(this.direction);
                    return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                }
            }(),
            distanceSqToSegment: function () {
                var t = new o,
                    e = new o,
                    i = new o;
                return function (r, n, o, a) {
                    t.copy(r).add(n).multiplyScalar(.5), e.copy(n).sub(r).normalize(), i.copy(this.origin).sub(t);
                    var s, l, h, c, u = .5 * r.distanceTo(n),
                        p = -this.direction.dot(e),
                        f = i.dot(this.direction),
                        d = -i.dot(e),
                        m = i.lengthSq(),
                        g = Math.abs(1 - p * p);
                    if (g > 0)
                        if (s = p * d - f, l = p * f - d, c = u * g, s >= 0)
                            if (l >= -c)
                                if (l <= c) {
                                    var v = 1 / g;
                                    s *= v, l *= v, h = s * (s + p * l + 2 * f) + l * (p * s + l + 2 * d) + m
                                } else l = u, s = Math.max(0, -(p * l + f)), h = -s * s + l * (l + 2 * d) + m;
                    else l = -u, s = Math.max(0, -(p * l + f)), h = -s * s + l * (l + 2 * d) + m;
                    else l <= -c ? (s = Math.max(0, -(-p * u + f)), l = s > 0 ? -u : Math.min(Math.max(-u, -d), u), h = -s * s + l * (l + 2 * d) + m) : l <= c ? (s = 0, l = Math.min(Math.max(-u, -d), u), h = l * (l + 2 * d) + m) : (s = Math.max(0, -(p * u + f)), l = s > 0 ? u : Math.min(Math.max(-u, -d), u), h = -s * s + l * (l + 2 * d) + m);
                    else l = p > 0 ? -u : u, s = Math.max(0, -(p * l + f)), h = -s * s + l * (l + 2 * d) + m;
                    return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(l).add(t), h
                }
            }(),
            intersectSphere: function () {
                var t = new o;
                return function (e, i) {
                    t.subVectors(e.center, this.origin);
                    var r = t.dot(this.direction),
                        n = t.dot(t) - r * r,
                        o = e.radius * e.radius;
                    if (n > o) return null;
                    var a = Math.sqrt(o - n),
                        s = r - a,
                        l = r + a;
                    return s < 0 && l < 0 ? null : s < 0 ? this.at(l, i) : this.at(s, i)
                }
            }(),
            intersectsSphere: function (t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function (t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var i = -(this.origin.dot(t.normal) + t.constant) / e;
                return i >= 0 ? i : null
            },
            intersectPlane: function (t, e) {
                var i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            },
            intersectsPlane: function (t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            },
            intersectBox: function (t, e) {
                var i, r, n, o, a, s, l = 1 / this.direction.x,
                    h = 1 / this.direction.y,
                    c = 1 / this.direction.z,
                    u = this.origin;
                return l >= 0 ? (i = (t.min.x - u.x) * l, r = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, r = (t.min.x - u.x) * l), h >= 0 ? (n = (t.min.y - u.y) * h, o = (t.max.y - u.y) * h) : (n = (t.max.y - u.y) * h, o = (t.min.y - u.y) * h), i > o || n > r ? null : ((n > i || i !== i) && (i = n), (o < r || r !== r) && (r = o), c >= 0 ? (a = (t.min.z - u.z) * c, s = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, s = (t.min.z - u.z) * c), i > s || a > r ? null : ((a > i || i !== i) && (i = a), (s < r || r !== r) && (r = s), r < 0 ? null : this.at(i >= 0 ? i : r, e)))
            },
            intersectsBox: function () {
                var t = new o;
                return function (e) {
                    return null !== this.intersectBox(e, t)
                }
            }(),
            intersectTriangle: function () {
                var t = new o,
                    e = new o,
                    i = new o,
                    r = new o;
                return function (n, o, a, s, l) {
                    e.subVectors(o, n), i.subVectors(a, n), r.crossVectors(e, i);
                    var h, c = this.direction.dot(r);
                    if (c > 0) {
                        if (s) return null;
                        h = 1
                    } else {
                        if (!(c < 0)) return null;
                        h = -1, c = -c
                    }
                    t.subVectors(this.origin, n);
                    var u = h * this.direction.dot(i.crossVectors(t, i));
                    if (u < 0) return null;
                    var p = h * this.direction.dot(e.cross(t));
                    if (p < 0) return null;
                    if (u + p > c) return null;
                    var f = -h * t.dot(r);
                    return f < 0 ? null : this.at(f / c, l)
                }
            }(),
            applyMatrix4: function (t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            },
            equals: function (t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }), (0, w.default)(nt.prototype, {
            set: function (t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function (t) {
                return void 0 === t && (t = new o), t.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function (t) {
                return void 0 === t && (t = new o), t.subVectors(this.end, this.start)
            },
            distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            },
            distance: function () {
                return this.start.distanceTo(this.end)
            },
            at: function (t, e) {
                return void 0 === e && (e = new o), this.delta(e).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function () {
                var t = new o,
                    e = new o;
                return function (i, r) {
                    t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                    var n = e.dot(e),
                        o = e.dot(t),
                        a = o / n;
                    return r && (a = _l.clamp(a, 0, 1)), a
                }
            }(),
            closestPointToPoint: function (t, e, i) {
                var r = this.closestPointToPointParameter(t, e);
                return void 0 === i && (i = new o), this.delta(i).multiplyScalar(r).add(this.start)
            },
            applyMatrix4: function (t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function (t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), (0, w.default)(ot, {
            getNormal: function () {
                var t = new o;
                return function (e, i, r, n) {
                    void 0 === n && (n = new o), n.subVectors(r, i), t.subVectors(e, i), n.cross(t);
                    var a = n.lengthSq();
                    return a > 0 ? n.multiplyScalar(1 / Math.sqrt(a)) : n.set(0, 0, 0)
                }
            }(),
            getBarycoord: function () {
                var t = new o,
                    e = new o,
                    i = new o;
                return function (r, n, a, s, l) {
                    t.subVectors(s, n), e.subVectors(a, n), i.subVectors(r, n);
                    var h = t.dot(t),
                        c = t.dot(e),
                        u = t.dot(i),
                        p = e.dot(e),
                        f = e.dot(i),
                        d = h * p - c * c;
                    if (void 0 === l && (l = new o), 0 === d) return l.set(-2, -1, -1);
                    var m = 1 / d,
                        g = (p * u - c * f) * m,
                        v = (h * f - c * u) * m;
                    return l.set(1 - g - v, v, g)
                }
            }(),
            containsPoint: function () {
                var t = new o;
                return function (e, i, r, n) {
                    return ot.getBarycoord(e, i, r, n, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                }
            }()
        }), (0, w.default)(ot.prototype, {
            set: function (t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function (t, e, i, r) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[r]), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            getArea: function () {
                var t = new o,
                    e = new o;
                return function () {
                    return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                }
            }(),
            getMidpoint: function (t) {
                return void 0 === t && (t = new o), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function (t) {
                return ot.getNormal(this.a, this.b, this.c, t)
            },
            getPlane: function (t) {
                return void 0 === t && (t = new o), t.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function (t, e) {
                return ot.getBarycoord(t, this.a, this.b, this.c, e)
            },
            containsPoint: function (t) {
                return ot.containsPoint(t, this.a, this.b, this.c)
            },
            intersectsBox: function (t) {
                return t.intersectsTriangle(this)
            },
            closestPointToPoint: function () {
                var t = new _,
                    e = [new nt, new nt, new nt],
                    i = new o,
                    r = new o;
                return function (n, a) {
                    void 0 === a && (a = new o);
                    var s = 1 / 0;
                    if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(n, i), !0 === this.containsPoint(i)) a.copy(i);
                    else {
                        e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                        for (var l = 0; l < e.length; l++) {
                            e[l].closestPointToPoint(i, !0, r);
                            var h = i.distanceToSquared(r);
                            h < s && (s = h, a.copy(r))
                        }
                    }
                    return a
                }
            }(),
            equals: function (t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), at.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: at,
            isMesh: !0,
            setDrawMode: function (t) {
                this.drawMode = t
            },
            copy: function (t) {
                return R.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = (0, w.default)({}, t.morphTargetDictionary)), this
            },
            updateMorphTargets: function () {
                var t, e, i, r = this.geometry;
                if (r.isBufferGeometry) {
                    var n = r.morphAttributes,
                        o = (0, p.default)(n);
                    if (o.length > 0) {
                        var a = n[o[0]];
                        if (void 0 !== a)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                    }
                } else {
                    var s = r.morphTargets;
                    if (void 0 !== s && s.length > 0)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) i = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                }
            },
            raycast: function () {
                function t(t, e, i, r, n, o, a) {
                    return ot.getBarycoord(t, e, i, r, y), n.multiplyScalar(y.x), o.multiplyScalar(y.y), a.multiplyScalar(y.z), n.add(o).add(a), n.clone()
                }

                function e(t, e, i, r, n, o, a, s) {
                    if (null === (e.side === fa ? r.intersectTriangle(a, o, n, !0, s) : r.intersectTriangle(n, o, a, e.side !== da, s))) return null;
                    _.copy(s), _.applyMatrix4(t.matrixWorld);
                    var l = i.ray.origin.distanceTo(_);
                    return l < i.near || l > i.far ? null : {
                        distance: l,
                        point: _.clone(),
                        object: t
                    }
                }

                function n(i, r, n, o, a, s, l, p) {
                    h.fromBufferAttribute(o, s), c.fromBufferAttribute(o, l), u.fromBufferAttribute(o, p);
                    var f = e(i, i.material, r, n, h, c, u, x);
                    if (f) {
                        a && (m.fromBufferAttribute(a, s), g.fromBufferAttribute(a, l), v.fromBufferAttribute(a, p), f.uv = t(x, h, c, u, m, g, v));
                        var d = new B(s, l, p);
                        ot.getNormal(h, c, u, d.normal), f.face = d, f.faceIndex = s
                    }
                    return f
                }
                var a = new r,
                    s = new rt,
                    l = new A,
                    h = new o,
                    c = new o,
                    u = new o,
                    p = new o,
                    f = new o,
                    d = new o,
                    m = new i,
                    g = new i,
                    v = new i,
                    y = new o,
                    x = new o,
                    _ = new o;
                return function (i, r) {
                    var o = this.geometry,
                        y = this.material,
                        A = this.matrixWorld;
                    if (void 0 !== y && (null === o.boundingSphere && o.computeBoundingSphere(), l.copy(o.boundingSphere), l.applyMatrix4(A), !1 !== i.ray.intersectsSphere(l) && (a.getInverse(A), s.copy(i.ray).applyMatrix4(a), null === o.boundingBox || !1 !== s.intersectsBox(o.boundingBox)))) {
                        var _;
                        if (o.isBufferGeometry) {
                            var w, b, M, T, S, E = o.index,
                                C = o.attributes.position,
                                P = o.attributes.uv;
                            if (null !== E)
                                for (T = 0, S = E.count; T < S; T += 3) w = E.getX(T), b = E.getX(T + 1), M = E.getX(T + 2), (_ = n(this, i, s, C, P, w, b, M)) && (_.faceIndex = Math.floor(T / 3), r.push(_));
                            else if (void 0 !== C)
                                for (T = 0, S = C.count; T < S; T += 3) w = T, b = T + 1, M = T + 2, (_ = n(this, i, s, C, P, w, b, M)) && r.push(_)
                        } else if (o.isGeometry) {
                            var L, D, R, I, O = Array.isArray(y),
                                B = o.vertices,
                                N = o.faces,
                                k = o.faceVertexUvs[0];
                            k.length > 0 && (I = k);
                            for (var F = 0, z = N.length; F < z; F++) {
                                var U = N[F],
                                    G = O ? y[U.materialIndex] : y;
                                if (void 0 !== G) {
                                    if (L = B[U.a], D = B[U.b], R = B[U.c], !0 === G.morphTargets) {
                                        var V = o.morphTargets,
                                            H = this.morphTargetInfluences;
                                        h.set(0, 0, 0), c.set(0, 0, 0), u.set(0, 0, 0);
                                        for (var j = 0, W = V.length; j < W; j++) {
                                            var Y = H[j];
                                            if (0 !== Y) {
                                                var X = V[j].vertices;
                                                h.addScaledVector(p.subVectors(X[U.a], L), Y), c.addScaledVector(f.subVectors(X[U.b], D), Y), u.addScaledVector(d.subVectors(X[U.c], R), Y)
                                            }
                                        }
                                        h.add(L), c.add(D), u.add(R), L = h, D = c, R = u
                                    }
                                    if (_ = e(this, G, i, s, L, D, R, x)) {
                                        if (I && I[F]) {
                                            var Q = I[F];
                                            m.copy(Q[0]), g.copy(Q[1]), v.copy(Q[2]), _.uv = t(x, L, D, R, m, g, v)
                                        }
                                        _.face = U, _.faceIndex = F, r.push(_)
                                    }
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), yt.prototype = (0, y.default)(s.prototype), yt.prototype.constructor = yt, yt.prototype.isCubeTexture = !0, Object.defineProperty(yt.prototype, "images", {
            get: function () {
                return this.image
            },
            set: function (t) {
                this.image = t
            }
        });
        var Rl = new s,
            Il = new yt,
            Ol = [],
            Bl = [],
            Nl = new Float32Array(16),
            kl = new Float32Array(9);
        Jt.prototype.setValue = function (t, e) {
            for (var i = this.seq, r = 0, n = i.length; r !== n; ++r) {
                var o = i[r];
                o.setValue(t, e[o.id])
            }
        };
        var Fl = /([\w\d_]+)(\])?(\[|\.)?/g;
        Kt.prototype.setValue = function (t, e, i) {
            var r = this.map[e];
            void 0 !== r && r.setValue(t, i, this.renderer)
        }, Kt.prototype.setOptional = function (t, e, i) {
            var r = e[i];
            void 0 !== r && this.setValue(t, i, r)
        }, Kt.upload = function (t, e, i, r) {
            for (var n = 0, o = e.length; n !== o; ++n) {
                var a = e[n],
                    s = i[a.id];
                !1 !== s.needsUpdate && a.setValue(t, s.value, r)
            }
        }, Kt.seqWithValue = function (t, e) {
            for (var i = [], r = 0, n = t.length; r !== n; ++r) {
                var o = t[r];
                o.id in e && i.push(o)
            }
            return i
        };
        var zl = 0,
            Ul = 0;
        be.prototype = (0, y.default)(tt.prototype), be.prototype.constructor = be, be.prototype.isMeshDepthMaterial = !0, be.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, Me.prototype = (0, y.default)(tt.prototype), Me.prototype.constructor = Me, Me.prototype.isMeshDistanceMaterial = !0, Me.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }, Se.prototype = (0, y.default)(s.prototype), Se.prototype.constructor = Se, De.prototype = (0, w.default)((0, y.default)(I.prototype), {
            constructor: De,
            isPerspectiveCamera: !0,
            copy: function (t, e) {
                return I.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : (0, w.default)({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function (t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * _l.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
                var t = Math.tan(.5 * _l.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function () {
                return 2 * _l.RAD2DEG * Math.atan(Math.tan(.5 * _l.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (t, e, i, r, n, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var t = this.near,
                    e = t * Math.tan(.5 * _l.DEG2RAD * this.fov) / this.zoom,
                    i = 2 * e,
                    r = this.aspect * i,
                    n = -.5 * r,
                    o = this.view;
                if (null !== this.view && this.view.enabled) {
                    var a = o.fullWidth,
                        s = o.fullHeight;
                    n += o.offsetX * r / a, e -= o.offsetY * i / s, r *= o.width / a, i *= o.height / s
                }
                var l = this.filmOffset;
                0 !== l && (n += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, e, e - i, t, this.far)
            },
            toJSON: function (t) {
                var e = R.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = (0, w.default)({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }), Re.prototype = (0, w.default)((0, y.default)(De.prototype), {
            constructor: Re,
            isArrayCamera: !0
        }), Be.prototype.isFogExp2 = !0, Be.prototype.clone = function () {
            return new Be(this.color.getHex(), this.density)
        }, Be.prototype.toJSON = function () {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }, Ne.prototype.isFog = !0, Ne.prototype.clone = function () {
            return new Ne(this.color.getHex(), this.near, this.far)
        }, Ne.prototype.toJSON = function () {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }, ke.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: ke,
            copy: function (t, e) {
                return R.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function (t) {
                var e = R.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }), Fe.prototype = (0, y.default)(tt.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isSpriteMaterial = !0, Fe.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
        }, ze.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: ze,
            isSprite: !0,
            raycast: function () {
                var t = new o,
                    e = new o,
                    i = new o;
                return function (r, n) {
                    e.setFromMatrixPosition(this.matrixWorld), r.ray.closestPointToPoint(e, t), i.setFromMatrixScale(this.matrixWorld);
                    var o = i.x * i.y / 4;
                    if (!(e.distanceToSquared(t) > o)) {
                        var a = r.ray.origin.distanceTo(t);
                        a < r.near || a > r.far || n.push({
                            distance: a,
                            point: t.clone(),
                            face: null,
                            object: this
                        })
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.material).copy(this)
            },
            copy: function (t) {
                return R.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
            }
        }), Ue.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: Ue,
            copy: function (t) {
                R.prototype.copy.call(this, t, !1);
                for (var e = t.levels, i = 0, r = e.length; i < r; i++) {
                    var n = e[i];
                    this.addLevel(n.object.clone(), n.distance)
                }
                return this
            },
            addLevel: function (t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, r = 0; r < i.length && !(e < i[r].distance); r++);
                i.splice(r, 0, {
                    distance: e,
                    object: t
                }), this.add(t)
            },
            getObjectForDistance: function (t) {
                for (var e = this.levels, i = 1, r = e.length; i < r && !(t < e[i].distance); i++);
                return e[i - 1].object
            },
            raycast: function () {
                var t = new o;
                return function (e, i) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var r = e.ray.origin.distanceTo(t);
                    this.getObjectForDistance(r).raycast(e, i)
                }
            }(),
            update: function () {
                var t = new o,
                    e = new o;
                return function (i) {
                    var r = this.levels;
                    if (r.length > 1) {
                        t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                        var n = t.distanceTo(e);
                        r[0].object.visible = !0;
                        for (var o = 1, a = r.length; o < a && n >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                        for (; o < a; o++) r[o].object.visible = !1
                    }
                }
            }(),
            toJSON: function (t) {
                var e = R.prototype.toJSON.call(this, t);
                e.object.levels = [];
                for (var i = this.levels, r = 0, n = i.length; r < n; r++) {
                    var o = i[r];
                    e.object.levels.push({
                        object: o.object.uuid,
                        distance: o.distance
                    })
                }
                return e
            }
        }), (0, w.default)(Ge.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new r;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function () {
                var t, e, i;
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            },
            update: function () {
                var t = new r,
                    e = new r;
                return function () {
                    for (var i = this.bones, r = this.boneInverses, n = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) {
                        var l = i[a] ? i[a].matrixWorld : e;
                        t.multiplyMatrices(l, r[a]), t.toArray(n, 16 * a)
                    }
                    void 0 !== o && (o.needsUpdate = !0)
                }
            }(),
            clone: function () {
                return new Ge(this.bones, this.boneInverses)
            },
            getBoneByName: function (t) {
                for (var e = 0, i = this.bones.length; e < i; e++) {
                    var r = this.bones[e];
                    if (r.name === t) return r
                }
            }
        }), Ve.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: Ve,
            isBone: !0
        }), He.prototype = (0, w.default)((0, y.default)(at.prototype), {
            constructor: He,
            isSkinnedMesh: !0,
            initBones: function () {
                var t, e, i, r, n = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (i = 0, r = this.geometry.bones.length; i < r; i++) e = this.geometry.bones[i], t = new Ve, n.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                    for (i = 0, r = this.geometry.bones.length; i < r; i++) e = this.geometry.bones[i], -1 !== e.parent && null !== e.parent && void 0 !== n[e.parent] ? n[e.parent].add(n[i]) : this.add(n[i])
                }
                return this.updateMatrixWorld(!0), n
            },
            bind: function (t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                var t, e;
                if (this.geometry && this.geometry.isGeometry)
                    for (e = 0; e < this.geometry.skinWeights.length; e++) {
                        var i = this.geometry.skinWeights[e];
                        t = 1 / i.manhattanLength(), t !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0)
                    } else if (this.geometry && this.geometry.isBufferGeometry) {
                        var r = new h,
                            n = this.geometry.attributes.skinWeight;
                        for (e = 0; e < n.count; e++) r.x = n.getX(e), r.y = n.getY(e), r.z = n.getZ(e), r.w = n.getW(e), t = 1 / r.manhattanLength(), t !== 1 / 0 ? r.multiplyScalar(t) : r.set(1, 0, 0, 0), n.setXYZW(e, r.x, r.y, r.z, r.w)
                    }
            },
            updateMatrixWorld: function (t) {
                at.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), je.prototype = (0, y.default)(tt.prototype), je.prototype.constructor = je, je.prototype.isLineBasicMaterial = !0, je.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, We.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: We,
            isLine: !0,
            computeLineDistances: function () {
                var t = new o,
                    e = new o;
                return function () {
                    var i = this.geometry;
                    if (i.isBufferGeometry) {
                        if (null === i.index) {
                            for (var r = i.attributes.position, n = [0], o = 1, a = r.count; o < a; o++) t.fromBufferAttribute(r, o - 1), e.fromBufferAttribute(r, o), n[o] = n[o - 1], n[o] += t.distanceTo(e);
                            i.addAttribute("lineDistance", new W(n, 1))
                        }
                    } else if (i.isGeometry) {
                        var s = i.vertices,
                            n = i.lineDistances;
                        n[0] = 0;
                        for (var o = 1, a = s.length; o < a; o++) n[o] = n[o - 1], n[o] += s[o - 1].distanceTo(s[o])
                    }
                    return this
                }
            }(),
            raycast: function () {
                var t = new r,
                    e = new rt,
                    i = new A;
                return function (r, n) {
                    var a = r.linePrecision,
                        s = a * a,
                        l = this.geometry,
                        h = this.matrixWorld;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(h), !1 !== r.ray.intersectsSphere(i)) {
                        t.getInverse(h), e.copy(r.ray).applyMatrix4(t);
                        var c = new o,
                            u = new o,
                            p = new o,
                            f = new o,
                            d = this && this.isLineSegments ? 2 : 1;
                        if (l.isBufferGeometry) {
                            var m = l.index,
                                g = l.attributes,
                                v = g.position.array;
                            if (null !== m)
                                for (var y = m.array, A = 0, x = y.length - 1; A < x; A += d) {
                                    var _ = y[A],
                                        w = y[A + 1];
                                    c.fromArray(v, 3 * _), u.fromArray(v, 3 * w);
                                    var b = e.distanceSqToSegment(c, u, f, p);
                                    if (!(b > s)) {
                                        f.applyMatrix4(this.matrixWorld);
                                        var M = r.ray.origin.distanceTo(f);
                                        M < r.near || M > r.far || n.push({
                                            distance: M,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: A,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                } else
                                    for (var A = 0, x = v.length / 3 - 1; A < x; A += d) {
                                        c.fromArray(v, 3 * A), u.fromArray(v, 3 * A + 3);
                                        var b = e.distanceSqToSegment(c, u, f, p);
                                        if (!(b > s)) {
                                            f.applyMatrix4(this.matrixWorld);
                                            var M = r.ray.origin.distanceTo(f);
                                            M < r.near || M > r.far || n.push({
                                                distance: M,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: A,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                        } else if (l.isGeometry)
                            for (var T = l.vertices, S = T.length, A = 0; A < S - 1; A += d) {
                                var b = e.distanceSqToSegment(T[A], T[A + 1], f, p);
                                if (!(b > s)) {
                                    f.applyMatrix4(this.matrixWorld);
                                    var M = r.ray.origin.distanceTo(f);
                                    M < r.near || M > r.far || n.push({
                                        distance: M,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: A,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Ye.prototype = (0, w.default)((0, y.default)(We.prototype), {
            constructor: Ye,
            isLineSegments: !0,
            computeLineDistances: function () {
                var t = new o,
                    e = new o;
                return function () {
                    var i = this.geometry;
                    if (i.isBufferGeometry) {
                        if (null === i.index) {
                            for (var r = i.attributes.position, n = [], o = 0, a = r.count; o < a; o += 2) t.fromBufferAttribute(r, o), e.fromBufferAttribute(r, o + 1), n[o] = 0 === o ? 0 : n[o - 1], n[o + 1] = n[o] + t.distanceTo(e);
                            i.addAttribute("lineDistance", new W(n, 1))
                        }
                    } else if (i.isGeometry)
                        for (var s = i.vertices, n = i.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), n[o] = 0 === o ? 0 : n[o - 1], n[o + 1] = n[o] + t.distanceTo(e);
                    return this
                }
            }()
        }), Xe.prototype = (0, w.default)((0, y.default)(We.prototype), {
            constructor: Xe,
            isLineLoop: !0
        }), Qe.prototype = (0, y.default)(tt.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isPointsMaterial = !0, Qe.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
        }, Je.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: Je,
            isPoints: !0,
            raycast: function () {
                var t = new r,
                    e = new rt,
                    i = new A;
                return function (r, n) {
                    function a(t, i) {
                        var o = e.distanceSqToPoint(t);
                        if (o < p) {
                            e.closestPointToPoint(t, d), d.applyMatrix4(h);
                            var a = r.ray.origin.distanceTo(d);
                            if (a < r.near || a > r.far) return;
                            n.push({
                                distance: a,
                                distanceToRay: Math.sqrt(o),
                                point: d.clone(),
                                index: i,
                                face: null,
                                object: s
                            })
                        }
                    }
                    var s = this,
                        l = this.geometry,
                        h = this.matrixWorld,
                        c = r.params.Points.threshold;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(h), i.radius += c, !1 !== r.ray.intersectsSphere(i)) {
                        t.getInverse(h), e.copy(r.ray).applyMatrix4(t);
                        var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            p = u * u,
                            f = new o,
                            d = new o;
                        if (l.isBufferGeometry) {
                            var m = l.index,
                                g = l.attributes,
                                v = g.position.array;
                            if (null !== m)
                                for (var y = m.array, A = 0, x = y.length; A < x; A++) {
                                    var _ = y[A];
                                    f.fromArray(v, 3 * _), a(f, _)
                                } else
                                    for (var A = 0, w = v.length / 3; A < w; A++) f.fromArray(v, 3 * A), a(f, A)
                        } else
                            for (var b = l.vertices, A = 0, w = b.length; A < w; A++) a(b[A], A)
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), qe.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: qe,
            isGroup: !0
        }), Ze.prototype = (0, w.default)((0, y.default)(s.prototype), {
            constructor: Ze,
            isVideoTexture: !0,
            update: function () {
                var t = this.image;
                t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), Ke.prototype = (0, y.default)(s.prototype), Ke.prototype.constructor = Ke, Ke.prototype.isCompressedTexture = !0, $e.prototype = (0, y.default)(s.prototype), $e.prototype.constructor = $e, $e.prototype.isDepthTexture = !0, ti.prototype = (0, y.default)(J.prototype), ti.prototype.constructor = ti, ei.prototype = (0, y.default)(N.prototype), ei.prototype.constructor = ei, ii.prototype = (0, y.default)(J.prototype), ii.prototype.constructor = ii, ri.prototype = (0, y.default)(N.prototype), ri.prototype.constructor = ri, ni.prototype = (0, y.default)(J.prototype), ni.prototype.constructor = ni, oi.prototype = (0, y.default)(N.prototype), oi.prototype.constructor = oi, ai.prototype = (0, y.default)(ni.prototype), ai.prototype.constructor = ai, si.prototype = (0, y.default)(N.prototype), si.prototype.constructor = si, li.prototype = (0, y.default)(ni.prototype), li.prototype.constructor = li, hi.prototype = (0, y.default)(N.prototype), hi.prototype.constructor = hi, ci.prototype = (0, y.default)(ni.prototype), ci.prototype.constructor = ci, ui.prototype = (0, y.default)(N.prototype), ui.prototype.constructor = ui, pi.prototype = (0, y.default)(ni.prototype), pi.prototype.constructor = pi, fi.prototype = (0, y.default)(N.prototype), fi.prototype.constructor = fi, di.prototype = (0, y.default)(J.prototype), di.prototype.constructor = di, mi.prototype = (0, y.default)(N.prototype), mi.prototype.constructor = mi, gi.prototype = (0, y.default)(J.prototype), gi.prototype.constructor = gi, vi.prototype = (0, y.default)(N.prototype), vi.prototype.constructor = vi, yi.prototype = (0, y.default)(J.prototype), yi.prototype.constructor = yi;
        var Gl = {
                triangulate: function (t, e, i) {
                    i = i || 2;
                    var r = e && e.length,
                        n = r ? e[0] * i : t.length,
                        o = Ai(t, 0, n, i, !0),
                        a = [];
                    if (!o) return a;
                    var s, l, h, c, u, p, f;
                    if (r && (o = Si(t, e, o, i)), t.length > 80 * i) {
                        s = h = t[0], l = c = t[1];
                        for (var d = i; d < n; d += i) u = t[d], p = t[d + 1], u < s && (s = u), p < l && (l = p), u > h && (h = u), p > c && (c = p);
                        f = Math.max(h - s, c - l), f = 0 !== f ? 1 / f : 0
                    }
                    return _i(o, a, i, s, l, f), a
                }
            },
            Vl = {
                area: function (t) {
                    for (var e = t.length, i = 0, r = e - 1, n = 0; n < e; r = n++) i += t[r].x * t[n].y - t[n].x * t[r].y;
                    return .5 * i
                },
                isClockWise: function (t) {
                    return Vl.area(t) < 0
                },
                triangulateShape: function (t, e) {
                    var i = [],
                        r = [],
                        n = [];
                    Xi(t), Qi(i, t);
                    var o = t.length;
                    e.forEach(Xi);
                    for (var a = 0; a < e.length; a++) r.push(o), o += e[a].length, Qi(i, e[a]);
                    for (var s = Gl.triangulate(i, r), a = 0; a < s.length; a += 3) n.push(s.slice(a, a + 3));
                    return n
                }
            };
        Ji.prototype = (0, y.default)(N.prototype), Ji.prototype.constructor = Ji, qi.prototype = (0, y.default)(J.prototype), qi.prototype.constructor = qi, qi.prototype.getArrays = function () {
            var t = this.getAttribute("position"),
                e = t ? Array.prototype.slice.call(t.array) : [],
                i = this.getAttribute("uv"),
                r = i ? Array.prototype.slice.call(i.array) : [],
                n = this.index;
            return {
                position: e,
                uv: r,
                index: n ? Array.prototype.slice.call(n.array) : []
            }
        }, qi.prototype.addShapeList = function (t, e) {
            var i = t.length;
            e.arrays = this.getArrays();
            for (var r = 0; r < i; r++) {
                var n = t[r];
                this.addShape(n, e)
            }
            this.setIndex(e.arrays.index), this.addAttribute("position", new W(e.arrays.position, 3)), this.addAttribute("uv", new W(e.arrays.uv, 2))
        }, qi.prototype.addShape = function (t, e) {
            function r(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }

            function n(t, e, r) {
                var n, o, a, s = t.x - e.x,
                    l = t.y - e.y,
                    h = r.x - t.x,
                    c = r.y - t.y,
                    u = s * s + l * l,
                    p = s * c - l * h;
                if (Math.abs(p) > C.default) {
                    var f = Math.sqrt(u),
                        d = Math.sqrt(h * h + c * c),
                        m = e.x - l / f,
                        g = e.y + s / f,
                        v = r.x - c / d,
                        y = r.y + h / d,
                        A = ((v - m) * c - (y - g) * h) / (s * c - l * h);
                    n = m + s * A - t.x, o = g + l * A - t.y;
                    var x = n * n + o * o;
                    if (x <= 2) return new i(n, o);
                    a = Math.sqrt(x / 2)
                } else {
                    var _ = !1;
                    s > C.default ? h > C.default && (_ = !0) : s < -C.default ? h < -C.default && (_ = !0) : (0, M.default)(l) === (0, M.default)(c) && (_ = !0), _ ? (n = -l, o = s, a = Math.sqrt(u)) : (n = s, o = l, a = Math.sqrt(u / 2))
                }
                return new i(n / a, o / a)
            }

            function a(t, e) {
                var i, r;
                for ($ = t.length; --$ >= 0;) {
                    i = $, r = $ - 1, r < 0 && (r = t.length - 1);
                    var n = 0,
                        o = L + 2 * S;
                    for (n = 0; n < o; n++) {
                        var a = q * n,
                            s = q * (n + 1);
                        h(e + i + a, e + r + a, e + r + s, e + i + s)
                    }
                }
            }

            function s(t, e, i) {
                _.push(t), _.push(e), _.push(i)
            }

            function l(t, e, i) {
                c(t), c(e), c(i);
                var r = y.length / 3,
                    n = I.generateTopUV(k, y, r - 3, r - 2, r - 1);
                u(n[0]), u(n[1]), u(n[2])
            }

            function h(t, e, i, r) {
                c(t), c(e), c(r), c(e), c(i), c(r);
                var n = y.length / 3,
                    o = I.generateSideWallUV(k, y, n - 6, n - 3, n - 2, n - 1);
                u(o[0]), u(o[1]), u(o[3]), u(o[1]), u(o[2]), u(o[3])
            }

            function c(t) {
                A.push(y.length / 3), y.push(_[3 * t + 0]), y.push(_[3 * t + 1]), y.push(_[3 * t + 2])
            }

            function u(t) {
                x.push(t.x), x.push(t.y)
            }
            var p, f, d, m, g, v = e.arrays ? e.arrays : this.getArrays(),
                y = v.position,
                A = v.index,
                x = v.uv,
                _ = [],
                w = void 0 !== e.amount ? e.amount : 100,
                b = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                T = void 0 !== e.bevelSize ? e.bevelSize : b - 2,
                S = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                E = void 0 === e.bevelEnabled || e.bevelEnabled,
                P = void 0 !== e.curveSegments ? e.curveSegments : 12,
                L = void 0 !== e.steps ? e.steps : 1,
                D = e.extrudePath,
                R = !1,
                I = void 0 !== e.UVGenerator ? e.UVGenerator : Ji.WorldUVGenerator;
            D && (p = D.getSpacedPoints(L), R = !0, E = !1, f = D.computeFrenetFrames(L, !1), d = new o, m = new o, g = new o), E || (S = 0, b = 0, T = 0);
            var O, B, N, k = this,
                F = t.extractPoints(P),
                z = F.shape,
                U = F.holes;
            if (!Vl.isClockWise(z))
                for (z = z.reverse(), B = 0, N = U.length; B < N; B++) O = U[B], Vl.isClockWise(O) && (U[B] = O.reverse());
            var G = Vl.triangulateShape(z, U),
                V = z;
            for (B = 0, N = U.length; B < N; B++) O = U[B], z = z.concat(O);
            for (var H, j, Y, X, Q, J, q = z.length, Z = G.length, K = [], $ = 0, tt = V.length, et = tt - 1, it = $ + 1; $ < tt; $++, et++, it++) et === tt && (et = 0), it === tt && (it = 0), K[$] = n(V[$], V[et], V[it]);
            var rt, nt = [],
                ot = K.concat();
            for (B = 0, N = U.length; B < N; B++) {
                for (O = U[B], rt = [], $ = 0, tt = O.length, et = tt - 1, it = $ + 1; $ < tt; $++, et++, it++) et === tt && (et = 0), it === tt && (it = 0), rt[$] = n(O[$], O[et], O[it]);
                nt.push(rt), ot = ot.concat(rt)
            }
            for (H = 0; H < S; H++) {
                for (Y = H / S, X = b * Math.cos(Y * Math.PI / 2), j = T * Math.sin(Y * Math.PI / 2), $ = 0, tt = V.length; $ < tt; $++) Q = r(V[$], K[$], j), s(Q.x, Q.y, -X);
                for (B = 0, N = U.length; B < N; B++)
                    for (O = U[B], rt = nt[B], $ = 0, tt = O.length; $ < tt; $++) Q = r(O[$], rt[$], j), s(Q.x, Q.y, -X)
            }
            for (j = T, $ = 0; $ < q; $++) Q = E ? r(z[$], ot[$], j) : z[$], R ? (m.copy(f.normals[0]).multiplyScalar(Q.x), d.copy(f.binormals[0]).multiplyScalar(Q.y), g.copy(p[0]).add(m).add(d), s(g.x, g.y, g.z)) : s(Q.x, Q.y, 0);
            var at;
            for (at = 1; at <= L; at++)
                for ($ = 0; $ < q; $++) Q = E ? r(z[$], ot[$], j) : z[$], R ? (m.copy(f.normals[at]).multiplyScalar(Q.x), d.copy(f.binormals[at]).multiplyScalar(Q.y), g.copy(p[at]).add(m).add(d), s(g.x, g.y, g.z)) : s(Q.x, Q.y, w / L * at);
            for (H = S - 1; H >= 0; H--) {
                for (Y = H / S, X = b * Math.cos(Y * Math.PI / 2), j = T * Math.sin(Y * Math.PI / 2), $ = 0, tt = V.length; $ < tt; $++) Q = r(V[$], K[$], j), s(Q.x, Q.y, w + X);
                for (B = 0, N = U.length; B < N; B++)
                    for (O = U[B], rt = nt[B], $ = 0, tt = O.length; $ < tt; $++) Q = r(O[$], rt[$], j), R ? s(Q.x, Q.y + p[L - 1].y, p[L - 1].x + X) : s(Q.x, Q.y, w + X)
            }! function () {
                var t = y.length / 3;
                if (E) {
                    var e = 0,
                        i = q * e;
                    for ($ = 0; $ < Z; $++) J = G[$], l(J[2] + i, J[1] + i, J[0] + i);
                    for (e = L + 2 * S, i = q * e, $ = 0; $ < Z; $++) J = G[$], l(J[0] + i, J[1] + i, J[2] + i)
                } else {
                    for ($ = 0; $ < Z; $++) J = G[$], l(J[2], J[1], J[0]);
                    for ($ = 0; $ < Z; $++) J = G[$], l(J[0] + q * L, J[1] + q * L, J[2] + q * L)
                }
                k.addGroup(t, y.length / 3 - t, 0)
            }(),
            function () {
                var t = y.length / 3,
                    e = 0;
                for (a(V, e), e += V.length, B = 0, N = U.length; B < N; B++) O = U[B], a(O, e), e += O.length;
                k.addGroup(t, y.length / 3 - t, 1)
            }(), e.arrays || (this.setIndex(A), this.addAttribute("position", new W(y, 3)), this.addAttribute("uv", new W(x, 2)))
        }, Ji.WorldUVGenerator = {
            generateTopUV: function (t, e, r, n, o) {
                var a = e[3 * r],
                    s = e[3 * r + 1],
                    l = e[3 * n],
                    h = e[3 * n + 1],
                    c = e[3 * o],
                    u = e[3 * o + 1];
                return [new i(a, s), new i(l, h), new i(c, u)]
            },
            generateSideWallUV: function (t, e, r, n, o, a) {
                var s = e[3 * r],
                    l = e[3 * r + 1],
                    h = e[3 * r + 2],
                    c = e[3 * n],
                    u = e[3 * n + 1],
                    p = e[3 * n + 2],
                    f = e[3 * o],
                    d = e[3 * o + 1],
                    m = e[3 * o + 2],
                    g = e[3 * a],
                    v = e[3 * a + 1],
                    y = e[3 * a + 2];
                return Math.abs(l - u) < .01 ? [new i(s, 1 - h), new i(c, 1 - p), new i(f, 1 - m), new i(g, 1 - y)] : [new i(l, 1 - h), new i(u, 1 - p), new i(d, 1 - m), new i(v, 1 - y)]
            }
        }, Zi.prototype = (0, y.default)(N.prototype), Zi.prototype.constructor = Zi, Ki.prototype = (0, y.default)(qi.prototype), Ki.prototype.constructor = Ki, $i.prototype = (0, y.default)(N.prototype), $i.prototype.constructor = $i, tr.prototype = (0, y.default)(J.prototype), tr.prototype.constructor = tr, er.prototype = (0, y.default)(N.prototype), er.prototype.constructor = er, ir.prototype = (0, y.default)(J.prototype), ir.prototype.constructor = ir, rr.prototype = (0, y.default)(N.prototype), rr.prototype.constructor = rr, nr.prototype = (0, y.default)(J.prototype), nr.prototype.constructor = nr, or.prototype = (0, y.default)(N.prototype), or.prototype.constructor = or, or.prototype.toJSON = function () {
            var t = N.prototype.toJSON.call(this);
            return sr(this.parameters.shapes, t)
        }, ar.prototype = (0, y.default)(J.prototype), ar.prototype.constructor = ar, ar.prototype.toJSON = function () {
            var t = J.prototype.toJSON.call(this);
            return sr(this.parameters.shapes, t)
        }, lr.prototype = (0, y.default)(J.prototype), lr.prototype.constructor = lr, hr.prototype = (0, y.default)(N.prototype), hr.prototype.constructor = hr, cr.prototype = (0, y.default)(J.prototype), cr.prototype.constructor = cr, ur.prototype = (0, y.default)(hr.prototype), ur.prototype.constructor = ur, pr.prototype = (0, y.default)(cr.prototype), pr.prototype.constructor = pr, fr.prototype = (0, y.default)(N.prototype), fr.prototype.constructor = fr, dr.prototype = (0, y.default)(J.prototype), dr.prototype.constructor = dr;
        var Hl = (0, l.default)({
            WireframeGeometry: ti,
            ParametricGeometry: ei,
            ParametricBufferGeometry: ii,
            TetrahedronGeometry: oi,
            TetrahedronBufferGeometry: ai,
            OctahedronGeometry: si,
            OctahedronBufferGeometry: li,
            IcosahedronGeometry: hi,
            IcosahedronBufferGeometry: ci,
            DodecahedronGeometry: ui,
            DodecahedronBufferGeometry: pi,
            PolyhedronGeometry: ri,
            PolyhedronBufferGeometry: ni,
            TubeGeometry: fi,
            TubeBufferGeometry: di,
            TorusKnotGeometry: mi,
            TorusKnotBufferGeometry: gi,
            TorusGeometry: vi,
            TorusBufferGeometry: yi,
            TextGeometry: Zi,
            TextBufferGeometry: Ki,
            SphereGeometry: $i,
            SphereBufferGeometry: tr,
            RingGeometry: er,
            RingBufferGeometry: ir,
            PlaneGeometry: K,
            PlaneBufferGeometry: $,
            LatheGeometry: rr,
            LatheBufferGeometry: nr,
            ShapeGeometry: or,
            ShapeBufferGeometry: ar,
            ExtrudeGeometry: Ji,
            ExtrudeBufferGeometry: qi,
            EdgesGeometry: lr,
            ConeGeometry: ur,
            ConeBufferGeometry: pr,
            CylinderGeometry: hr,
            CylinderBufferGeometry: cr,
            CircleGeometry: fr,
            CircleBufferGeometry: dr,
            BoxGeometry: q,
            BoxBufferGeometry: Z
        });
        mr.prototype = (0, y.default)(tt.prototype), mr.prototype.constructor = mr, mr.prototype.isShadowMaterial = !0, mr.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this
        }, gr.prototype = (0, y.default)(it.prototype), gr.prototype.constructor = gr, gr.prototype.isRawShaderMaterial = !0, vr.prototype = (0, y.default)(tt.prototype), vr.prototype.constructor = vr, vr.prototype.isMeshStandardMaterial = !0, vr.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, yr.prototype = (0, y.default)(vr.prototype), yr.prototype.constructor = yr, yr.prototype.isMeshPhysicalMaterial = !0, yr.prototype.copy = function (t) {
            return vr.prototype.copy.call(this, t), this.defines = {
                PHYSICAL: ""
            }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, Ar.prototype = (0, y.default)(tt.prototype), Ar.prototype.constructor = Ar, Ar.prototype.isMeshPhongMaterial = !0, Ar.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, xr.prototype = (0, y.default)(Ar.prototype), xr.prototype.constructor = xr, xr.prototype.isMeshToonMaterial = !0, xr.prototype.copy = function (t) {
            return Ar.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, _r.prototype = (0, y.default)(tt.prototype), _r.prototype.constructor = _r, _r.prototype.isMeshNormalMaterial = !0, _r.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, wr.prototype = (0, y.default)(tt.prototype), wr.prototype.constructor = wr, wr.prototype.isMeshLambertMaterial = !0, wr.prototype.copy = function (t) {
            return tt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, br.prototype = (0, y.default)(je.prototype), br.prototype.constructor = br, br.prototype.isLineDashedMaterial = !0, br.prototype.copy = function (t) {
            return je.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var jl = (0, l.default)({
                ShadowMaterial: mr,
                SpriteMaterial: Fe,
                RawShaderMaterial: gr,
                ShaderMaterial: it,
                PointsMaterial: Qe,
                MeshPhysicalMaterial: yr,
                MeshStandardMaterial: vr,
                MeshPhongMaterial: Ar,
                MeshToonMaterial: xr,
                MeshNormalMaterial: _r,
                MeshLambertMaterial: wr,
                MeshDepthMaterial: be,
                MeshDistanceMaterial: Me,
                MeshBasicMaterial: et,
                LineDashedMaterial: br,
                LineBasicMaterial: je,
                Material: tt
            }),
            Wl = {
                enabled: !1,
                files: {},
                add: function (t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function (t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function (t) {
                    delete this.files[t]
                },
                clear: function () {
                    this.files = {}
                }
            },
            Yl = new Mr,
            Xl = {};
        (0, w.default)(Tr.prototype, {
            load: function (t, e, i, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var n = this,
                    o = Wl.get(t);
                if (void 0 !== o) return n.manager.itemStart(t), setTimeout(function () {
                    e && e(o), n.manager.itemEnd(t)
                }, 0), o;
                if (void 0 !== Xl[t]) return void Xl[t].push({
                    onLoad: e,
                    onProgress: i,
                    onError: r
                });
                var a = /^data:(.*?)(;base64)?,(.*)$/,
                    s = t.match(a);
                if (s) {
                    var l = s[1],
                        h = !!s[2],
                        c = s[3];
                    c = window.decodeURIComponent(c), h && (c = window.atob(c));
                    try {
                        var u, p = (this.responseType || "").toLowerCase();
                        switch (p) {
                            case "arraybuffer":
                            case "blob":
                                for (var f = new Uint8Array(c.length), d = 0; d < c.length; d++) f[d] = c.charCodeAt(d);
                                u = "blob" === p ? new Blob([f.buffer], {
                                    type: l
                                }) : f.buffer;
                                break;
                            case "document":
                                var m = new DOMParser;
                                u = m.parseFromString(c, l);
                                break;
                            case "json":
                                u = JSON.parse(c);
                                break;
                            default:
                                u = c
                        }
                        window.setTimeout(function () {
                            e && e(u), n.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function () {
                            r && r(e), n.manager.itemEnd(t), n.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    Xl[t] = [], Xl[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: r
                    });
                    var g = new XMLHttpRequest;
                    g.open("GET", t, !0), g.addEventListener("load", function (e) {
                        var i = this.response;
                        Wl.add(t, i);
                        var r = Xl[t];
                        if (delete Xl[t], 200 === this.status) {
                            for (var o = 0, a = r.length; o < a; o++) {
                                var s = r[o];
                                s.onLoad && s.onLoad(i)
                            }
                            n.manager.itemEnd(t)
                        } else if (0 === this.status) {
                            for (var o = 0, a = r.length; o < a; o++) {
                                var s = r[o];
                                s.onLoad && s.onLoad(i)
                            }
                            n.manager.itemEnd(t)
                        } else {
                            for (var o = 0, a = r.length; o < a; o++) {
                                var s = r[o];
                                s.onError && s.onError(e)
                            }
                            n.manager.itemEnd(t), n.manager.itemError(t)
                        }
                    }, !1), g.addEventListener("progress", function (e) {
                        for (var i = Xl[t], r = 0, n = i.length; r < n; r++) {
                            var o = i[r];
                            o.onProgress && o.onProgress(e)
                        }
                    }, !1), g.addEventListener("error", function (e) {
                        var i = Xl[t];
                        delete Xl[t];
                        for (var r = 0, o = i.length; r < o; r++) {
                            var a = i[r];
                            a.onError && a.onError(e)
                        }
                        n.manager.itemEnd(t), n.manager.itemError(t)
                    }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (var v in this.requestHeader) g.setRequestHeader(v, this.requestHeader[v]);
                    g.send(null)
                }
                return n.manager.itemStart(t), g
            },
            setPath: function (t) {
                return this.path = t, this
            },
            setResponseType: function (t) {
                return this.responseType = t, this
            },
            setWithCredentials: function (t) {
                return this.withCredentials = t, this
            },
            setMimeType: function (t) {
                return this.mimeType = t, this
            },
            setRequestHeader: function (t) {
                return this.requestHeader = t, this
            }
        }), (0, w.default)(Sr.prototype, {
            load: function (t, e, i, r) {
                var n = this,
                    o = [],
                    a = new Ke;
                a.image = o;
                var s = new Tr(this.manager);
                if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                    for (var l = 0, h = 0, c = t.length; h < c; ++h) ! function (h) {
                        s.load(t[h], function (t) {
                            var i = n._parser(t, !0);
                            o[h] = {
                                width: i.width,
                                height: i.height,
                                format: i.format,
                                mipmaps: i.mipmaps
                            }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = ms), a.format = i.format, a.needsUpdate = !0, e && e(a))
                        }, i, r)
                    }(h);
                else s.load(t, function (t) {
                    var i = n._parser(t, !0);
                    if (i.isCubemap)
                        for (var r = i.mipmaps.length / i.mipmapCount, s = 0; s < r; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var l = 0; l < i.mipmapCount; l++) o[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + l]), o[s].format = i.format, o[s].width = i.width, o[s].height = i.height
                        } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                    1 === i.mipmapCount && (a.minFilter = ms), a.format = i.format, a.needsUpdate = !0, e && e(a)
                }, i, r);
                return a
            },
            setPath: function (t) {
                return this.path = t, this
            }
        }), (0, w.default)(Er.prototype, {
            load: function (t, e, i, r) {
                var n = this,
                    o = new m,
                    a = new Tr(this.manager);
                return a.setResponseType("arraybuffer"), a.load(t, function (t) {
                    var i = n._parser(t);
                    i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width, o.image.height = i.height, o.image.data = i.data), o.wrapS = void 0 !== i.wrapS ? i.wrapS : cs, o.wrapT = void 0 !== i.wrapT ? i.wrapT : cs, o.magFilter = void 0 !== i.magFilter ? i.magFilter : ms, o.minFilter = void 0 !== i.minFilter ? i.minFilter : vs, o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (o.format = i.format), void 0 !== i.type && (o.type = i.type), void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps), 1 === i.mipmapCount && (o.minFilter = ms), o.needsUpdate = !0, e && e(o, i))
                }, i, r), o
            }
        }), (0, w.default)(Cr.prototype, {
            crossOrigin: "Anonymous",
            load: function (t, e, i, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var n = this,
                    o = Wl.get(t);
                if (void 0 !== o) return n.manager.itemStart(t), setTimeout(function () {
                    e && e(o), n.manager.itemEnd(t)
                }, 0), o;
                var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                return a.addEventListener("load", function () {
                    Wl.add(t, this), e && e(this), n.manager.itemEnd(t)
                }, !1), a.addEventListener("error", function (e) {
                    r && r(e), n.manager.itemEnd(t), n.manager.itemError(t)
                }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), n.manager.itemStart(t), a.src = t, a
            },
            setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            },
            setPath: function (t) {
                return this.path = t, this
            }
        }), (0, w.default)(Pr.prototype, {
            crossOrigin: "Anonymous",
            load: function (t, e, i, r) {
                var n = new yt,
                    o = new Cr(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                for (var a = 0, s = 0; s < t.length; ++s) ! function (i) {
                    o.load(t[i], function (t) {
                        n.images[i] = t, 6 == ++a && (n.needsUpdate = !0, e && e(n))
                    }, void 0, r)
                }(s);
                return n
            },
            setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            },
            setPath: function (t) {
                return this.path = t, this
            }
        }), (0, w.default)(Lr.prototype, {
            crossOrigin: "Anonymous",
            load: function (t, e, i, r) {
                var n = new s,
                    o = new Cr(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (i) {
                    n.image = i;
                    var r = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    n.format = r ? Ds : Rs, n.needsUpdate = !0, void 0 !== e && e(n)
                }, i, r), n
            },
            setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            },
            setPath: function (t) {
                return this.path = t, this
            }
        }), (0, w.default)(Dr.prototype, {
            getPoint: function () {
                return null
            },
            getPointAt: function (t, e) {
                var i = this.getUtoTmapping(t);
                return this.getPoint(i, e)
            },
            getPoints: function (t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function (t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function () {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function (t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i, r = [],
                    n = this.getPoint(0),
                    o = 0;
                for (r.push(0), i = 1; i <= t; i++) e = this.getPoint(i / t), o += e.distanceTo(n), r.push(o), n = e;
                return this.cacheArcLengths = r, r
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function (t, e) {
                var i, r = this.getLengths(),
                    n = 0,
                    o = r.length;
                i = e || t * r[o - 1];
                for (var a, s = 0, l = o - 1; s <= l;)
                    if (n = Math.floor(s + (l - s) / 2), (a = r[n] - i) < 0) s = n + 1;
                    else {
                        if (!(a > 0)) {
                            l = n;
                            break
                        }
                        l = n - 1
                    } if (n = l, r[n] === i) return n / (o - 1);
                var h = r[n];
                return (n + (i - h) / (r[n + 1] - h)) / (o - 1)
            },
            getTangent: function (t) {
                var e = t - 1e-4,
                    i = t + 1e-4;
                e < 0 && (e = 0), i > 1 && (i = 1);
                var r = this.getPoint(e);
                return this.getPoint(i).clone().sub(r).normalize()
            },
            getTangentAt: function (t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            },
            computeFrenetFrames: function (t, e) {
                var i, n, a, s = new o,
                    l = [],
                    h = [],
                    c = [],
                    u = new o,
                    p = new r;
                for (i = 0; i <= t; i++) n = i / t, l[i] = this.getTangentAt(n), l[i].normalize();
                h[0] = new o, c[0] = new o;
                var f = Number.MAX_VALUE,
                    d = Math.abs(l[0].x),
                    m = Math.abs(l[0].y),
                    g = Math.abs(l[0].z);
                for (d <= f && (f = d, s.set(1, 0, 0)), m <= f && (f = m, s.set(0, 1, 0)), g <= f && s.set(0, 0, 1), u.crossVectors(l[0], s).normalize(), h[0].crossVectors(l[0], u), c[0].crossVectors(l[0], h[0]), i = 1; i <= t; i++) h[i] = h[i - 1].clone(), c[i] = c[i - 1].clone(), u.crossVectors(l[i - 1], l[i]), u.length() > C.default && (u.normalize(), a = Math.acos(_l.clamp(l[i - 1].dot(l[i]), -1, 1)), h[i].applyMatrix4(p.makeRotationAxis(u, a))), c[i].crossVectors(l[i], h[i]);
                if (!0 === e)
                    for (a = Math.acos(_l.clamp(h[0].dot(h[t]), -1, 1)), a /= t, l[0].dot(u.crossVectors(h[0], h[t])) > 0 && (a = -a), i = 1; i <= t; i++) h[i].applyMatrix4(p.makeRotationAxis(l[i], a * i)), c[i].crossVectors(l[i], h[i]);
                return {
                    tangents: l,
                    normals: h,
                    binormals: c
                }
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            },
            toJSON: function () {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            },
            fromJSON: function (t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), Rr.prototype = (0, y.default)(Dr.prototype), Rr.prototype.constructor = Rr, Rr.prototype.isEllipseCurve = !0, Rr.prototype.getPoint = function (t, e) {
            for (var r = e || new i, n = 2 * Math.PI, o = this.aEndAngle - this.aStartAngle, a = Math.abs(o) < C.default; o < 0;) o += n;
            for (; o > n;) o -= n;
            o < C.default && (o = a ? 0 : n), !0 !== this.aClockwise || a || (o === n ? o = -n : o -= n);
            var s = this.aStartAngle + t * o,
                l = this.aX + this.xRadius * Math.cos(s),
                h = this.aY + this.yRadius * Math.sin(s);
            if (0 !== this.aRotation) {
                var c = Math.cos(this.aRotation),
                    u = Math.sin(this.aRotation),
                    p = l - this.aX,
                    f = h - this.aY;
                l = p * c - f * u + this.aX, h = p * u + f * c + this.aY
            }
            return r.set(l, h)
        }, Rr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Rr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, Rr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Ir.prototype = (0, y.default)(Rr.prototype), Ir.prototype.constructor = Ir, Ir.prototype.isArcCurve = !0;
        var Ql = new o,
            Jl = new Or,
            ql = new Or,
            Zl = new Or;
        Br.prototype = (0, y.default)(Dr.prototype), Br.prototype.constructor = Br, Br.prototype.isCatmullRomCurve3 = !0, Br.prototype.getPoint = function (t, e) {
            var i = e || new o,
                r = this.points,
                n = r.length,
                a = (n - (this.closed ? 0 : 1)) * t,
                s = Math.floor(a),
                l = a - s;
            this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r.length) + 1) * r.length : 0 === l && s === n - 1 && (s = n - 2, l = 1);
            var h, c, u, p;
            if (this.closed || s > 0 ? h = r[(s - 1) % n] : (Ql.subVectors(r[0], r[1]).add(r[0]), h = Ql), c = r[s % n], u = r[(s + 1) % n], this.closed || s + 2 < n ? p = r[(s + 2) % n] : (Ql.subVectors(r[n - 1], r[n - 2]).add(r[n - 1]), p = Ql), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var f = "chordal" === this.curveType ? .5 : .25,
                    d = Math.pow(h.distanceToSquared(c), f),
                    m = Math.pow(c.distanceToSquared(u), f),
                    g = Math.pow(u.distanceToSquared(p), f);
                m < 1e-4 && (m = 1), d < 1e-4 && (d = m), g < 1e-4 && (g = m), Jl.initNonuniformCatmullRom(h.x, c.x, u.x, p.x, d, m, g), ql.initNonuniformCatmullRom(h.y, c.y, u.y, p.y, d, m, g), Zl.initNonuniformCatmullRom(h.z, c.z, u.z, p.z, d, m, g)
            } else "catmullrom" === this.curveType && (Jl.initCatmullRom(h.x, c.x, u.x, p.x, this.tension), ql.initCatmullRom(h.y, c.y, u.y, p.y, this.tension), Zl.initCatmullRom(h.z, c.z, u.z, p.z, this.tension));
            return i.set(Jl.calc(l), ql.calc(l), Zl.calc(l)), i
        }, Br.prototype.copy = function (t) {
            Dr.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var r = t.points[e];
                this.points.push(r.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Br.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var r = this.points[e];
                t.points.push(r.toArray())
            }
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, Br.prototype.fromJSON = function (t) {
            Dr.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var r = t.points[e];
                this.points.push((new o).fromArray(r))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Yr.prototype = (0, y.default)(Dr.prototype), Yr.prototype.constructor = Yr, Yr.prototype.isCubicBezierCurve = !0, Yr.prototype.getPoint = function (t, e) {
            var r = e || new i,
                n = this.v0,
                o = this.v1,
                a = this.v2,
                s = this.v3;
            return r.set(Wr(t, n.x, o.x, a.x, s.x), Wr(t, n.y, o.y, a.y, s.y)), r
        }, Yr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Yr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Yr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, Xr.prototype = (0, y.default)(Dr.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isCubicBezierCurve3 = !0, Xr.prototype.getPoint = function (t, e) {
            var i = e || new o,
                r = this.v0,
                n = this.v1,
                a = this.v2,
                s = this.v3;
            return i.set(Wr(t, r.x, n.x, a.x, s.x), Wr(t, r.y, n.y, a.y, s.y), Wr(t, r.z, n.z, a.z, s.z)), i
        }, Xr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Xr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Xr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, Qr.prototype = (0, y.default)(Dr.prototype), Qr.prototype.constructor = Qr, Qr.prototype.isLineCurve = !0, Qr.prototype.getPoint = function (t, e) {
            var r = e || new i;
            return 1 === t ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)), r
        }, Qr.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, Qr.prototype.getTangent = function () {
            return this.v2.clone().sub(this.v1).normalize()
        }, Qr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Qr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Qr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Jr.prototype = (0, y.default)(Dr.prototype), Jr.prototype.constructor = Jr, Jr.prototype.isLineCurve3 = !0, Jr.prototype.getPoint = function (t, e) {
            var i = e || new o;
            return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
        }, Jr.prototype.getPointAt = function (t, e) {
            return this.getPoint(t, e)
        }, Jr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Jr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Jr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, qr.prototype = (0, y.default)(Dr.prototype), qr.prototype.constructor = qr, qr.prototype.isQuadraticBezierCurve = !0, qr.prototype.getPoint = function (t, e) {
            var r = e || new i,
                n = this.v0,
                o = this.v1,
                a = this.v2;
            return r.set(Ur(t, n.x, o.x, a.x), Ur(t, n.y, o.y, a.y)), r
        }, qr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, qr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, qr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Zr.prototype = (0, y.default)(Dr.prototype), Zr.prototype.constructor = Zr, Zr.prototype.isQuadraticBezierCurve3 = !0, Zr.prototype.getPoint = function (t, e) {
            var i = e || new o,
                r = this.v0,
                n = this.v1,
                a = this.v2;
            return i.set(Ur(t, r.x, n.x, a.x), Ur(t, r.y, n.y, a.y), Ur(t, r.z, n.z, a.z)), i
        }, Zr.prototype.copy = function (t) {
            return Dr.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, Zr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, Zr.prototype.fromJSON = function (t) {
            return Dr.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, Kr.prototype = (0, y.default)(Dr.prototype), Kr.prototype.constructor = Kr, Kr.prototype.isSplineCurve = !0, Kr.prototype.getPoint = function (t, e) {
            var r = e || new i,
                n = this.points,
                o = (n.length - 1) * t,
                a = Math.floor(o),
                s = o - a,
                l = n[0 === a ? a : a - 1],
                h = n[a],
                c = n[a > n.length - 2 ? n.length - 1 : a + 1],
                u = n[a > n.length - 3 ? n.length - 1 : a + 2];
            return r.set(Nr(s, l.x, h.x, c.x, u.x), Nr(s, l.y, h.y, c.y, u.y)), r
        }, Kr.prototype.copy = function (t) {
            Dr.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var r = t.points[e];
                this.points.push(r.clone())
            }
            return this
        }, Kr.prototype.toJSON = function () {
            var t = Dr.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) {
                var r = this.points[e];
                t.points.push(r.toArray())
            }
            return t
        }, Kr.prototype.fromJSON = function (t) {
            Dr.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, r = t.points.length; e < r; e++) {
                var n = t.points[e];
                this.points.push((new i).fromArray(n))
            }
            return this
        };
        var Kl = (0, l.default)({
            ArcCurve: Ir,
            CatmullRomCurve3: Br,
            CubicBezierCurve: Yr,
            CubicBezierCurve3: Xr,
            EllipseCurve: Rr,
            LineCurve: Qr,
            LineCurve3: Jr,
            QuadraticBezierCurve: qr,
            QuadraticBezierCurve3: Zr,
            SplineCurve: Kr
        });
        $r.prototype = (0, w.default)((0, y.default)(Dr.prototype), {
            constructor: $r,
            add: function (t) {
                this.curves.push(t)
            },
            closePath: function () {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new Qr(e, t))
            },
            getPoint: function (t) {
                for (var e = t * this.getLength(), i = this.getCurveLengths(), r = 0; r < i.length;) {
                    if (i[r] >= e) {
                        var n = i[r] - e,
                            o = this.curves[r],
                            a = o.getLength(),
                            s = 0 === a ? 0 : 1 - n / a;
                        return o.getPointAt(s)
                    }
                    r++
                }
                return null
            },
            getLength: function () {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, r = this.curves.length; i < r; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t, t
            },
            getSpacedPoints: function (t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function (t) {
                t = t || 12;
                for (var e, i = [], r = 0, n = this.curves; r < n.length; r++)
                    for (var o = n[r], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
                        var h = s[l];
                        e && e.equals(h) || (i.push(h), e = h)
                    }
                return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            copy: function (t) {
                Dr.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var r = t.curves[e];
                    this.curves.push(r.clone())
                }
                return this.autoClose = t.autoClose, this
            },
            toJSON: function () {
                var t = Dr.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (var e = 0, i = this.curves.length; e < i; e++) {
                    var r = this.curves[e];
                    t.curves.push(r.toJSON())
                }
                return t
            },
            fromJSON: function (t) {
                Dr.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var r = t.curves[e];
                    this.curves.push((new Kl[r.type]).fromJSON(r))
                }
                return this
            }
        }), tn.prototype = (0, w.default)((0, y.default)($r.prototype), {
            constructor: tn,
            setFromPoints: function (t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function (t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function (t, e) {
                var r = new Qr(this.currentPoint.clone(), new i(t, e));
                this.curves.push(r), this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function (t, e, r, n) {
                var o = new qr(this.currentPoint.clone(), new i(t, e), new i(r, n));
                this.curves.push(o), this.currentPoint.set(r, n)
            },
            bezierCurveTo: function (t, e, r, n, o, a) {
                var s = new Yr(this.currentPoint.clone(), new i(t, e), new i(r, n), new i(o, a));
                this.curves.push(s), this.currentPoint.set(o, a)
            },
            splineThru: function (t) {
                var e = [this.currentPoint.clone()].concat(t),
                    i = new Kr(e);
                this.curves.push(i), this.currentPoint.copy(t[t.length - 1])
            },
            arc: function (t, e, i, r, n, o) {
                var a = this.currentPoint.x,
                    s = this.currentPoint.y;
                this.absarc(t + a, e + s, i, r, n, o)
            },
            absarc: function (t, e, i, r, n, o) {
                this.absellipse(t, e, i, i, r, n, o)
            },
            ellipse: function (t, e, i, r, n, o, a, s) {
                var l = this.currentPoint.x,
                    h = this.currentPoint.y;
                this.absellipse(t + l, e + h, i, r, n, o, a, s)
            },
            absellipse: function (t, e, i, r, n, o, a, s) {
                var l = new Rr(t, e, i, r, n, o, a, s);
                if (this.curves.length > 0) {
                    var h = l.getPoint(0);
                    h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
                }
                this.curves.push(l);
                var c = l.getPoint(1);
                this.currentPoint.copy(c)
            },
            copy: function (t) {
                return $r.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            },
            toJSON: function () {
                var t = $r.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            },
            fromJSON: function (t) {
                return $r.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), en.prototype = (0, w.default)((0, y.default)(tn.prototype), {
            constructor: en,
            getPointsHoles: function (t) {
                for (var e = [], i = 0, r = this.holes.length; i < r; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractPoints: function (t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function (t) {
                tn.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var r = t.holes[e];
                    this.holes.push(r.clone())
                }
                return this
            },
            toJSON: function () {
                var t = tn.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (var e = 0, i = this.holes.length; e < i; e++) {
                    var r = this.holes[e];
                    t.holes.push(r.toJSON())
                }
                return t
            },
            fromJSON: function (t) {
                tn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var r = t.holes[e];
                    this.holes.push((new tn).fromJSON(r))
                }
                return this
            }
        }), rn.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: rn,
            isLight: !0,
            copy: function (t) {
                return R.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function (t) {
                var e = R.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), nn.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: nn,
            isHemisphereLight: !0,
            copy: function (t) {
                return rn.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), (0, w.default)(on.prototype, {
            copy: function (t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), an.prototype = (0, w.default)((0, y.default)(on.prototype), {
            constructor: an,
            isSpotLightShadow: !0,
            update: function (t) {
                var e = this.camera,
                    i = 2 * _l.RAD2DEG * t.angle,
                    r = this.mapSize.width / this.mapSize.height,
                    n = t.distance || e.far;
                i === e.fov && r === e.aspect && n === e.far || (e.fov = i, e.aspect = r, e.far = n, e.updateProjectionMatrix())
            }
        }), sn.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: sn,
            isSpotLight: !0,
            copy: function (t) {
                return rn.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), ln.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: ln,
            isPointLight: !0,
            copy: function (t) {
                return rn.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), hn.prototype = (0, w.default)((0, y.default)(on.prototype), {
            constructor: hn
        }), cn.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: cn,
            isDirectionalLight: !0,
            copy: function (t) {
                return rn.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), un.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: un,
            isAmbientLight: !0
        }), pn.prototype = (0, w.default)((0, y.default)(rn.prototype), {
            constructor: pn,
            isRectAreaLight: !0,
            copy: function (t) {
                return rn.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function (t) {
                var e = rn.prototype.toJSON.call(this, t);
                return e.object.width = this.width, e.object.height = this.height, e
            }
        }), fn.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: fn,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), dn.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: dn,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), (0, w.default)(mn.prototype, {
            evaluate: function (t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    r = e[i],
                    n = e[i - 1];
                t: {
                    e: {
                        var o;i: {
                            r: if (!(t < r)) {
                                for (var a = i + 2;;) {
                                    if (void 0 === r) {
                                        if (t < n) break r;
                                        return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, n)
                                    }
                                    if (i === a) break;
                                    if (n = r, r = e[++i], t < r) break e
                                }
                                o = e.length;
                                break i
                            } {
                                if (t >= n) break t;
                                var s = e[1];
                                t < s && (i = 2, n = s);
                                for (var a = i - 2;;) {
                                    if (void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                    if (i === a) break;
                                    if (r = n, n = e[--i - 1], t >= n) break e
                                }
                                o = i, i = 0
                            }
                        }
                        for (; i < o;) {
                            var l = i + o >>> 1;
                            t < e[l] ? o = l : i = l + 1
                        }
                        if (r = e[i], void 0 === (n = e[i - 1])) return this._cachedIndex = 0,
                        this.beforeStart_(0, t, r);
                        if (void 0 === r) return i = e.length,
                        this._cachedIndex = i,
                        this.afterEnd_(i - 1, n, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, n, r)
                }
                return this.interpolate_(i, n, t, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function () {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function (t) {
                for (var e = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = t * r, o = 0; o !== r; ++o) e[o] = i[n + o];
                return e
            },
            interpolate_: function () {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function () {}
        }), (0, w.default)(mn.prototype, {
            beforeStart_: mn.prototype.copySampleValue_,
            afterEnd_: mn.prototype.copySampleValue_
        }), gn.prototype = (0, w.default)((0, y.default)(mn.prototype), {
            constructor: gn,
            interpolate_: function (t, e, i, r) {
                for (var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize, l = t * s, h = (i - e) / (r - e), c = l + s; l !== c; l += 4) n.slerpFlat(o, 0, a, l - s, a, l, h);
                return o
            }
        }), vn.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: vn,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function (t) {
                return new gn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), yn.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: yn,
            ValueTypeName: "color"
        }), An.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: An,
            ValueTypeName: "number"
        }), xn.prototype = (0, w.default)((0, y.default)(mn.prototype), {
            constructor: xn,
            DefaultSettings_: {
                endingStart: ll,
                endingEnd: ll
            },
            intervalChanged_: function (t, e, i) {
                var r = this.parameterPositions,
                    n = t - 2,
                    o = t + 1,
                    a = r[n],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        n = t, a = 2 * e - i;
                        break;
                    case 2402:
                        n = r.length - 2, a = e + r[n] - r[n + 1];
                        break;
                    default:
                        n = t, a = i
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        o = t, s = 2 * i - e;
                        break;
                    case 2402:
                        o = 1, s = i + r[1] - r[0];
                        break;
                    default:
                        o = t - 1, s = e
                }
                var l = .5 * (i - e),
                    h = this.valueSize;
                this._weightPrev = l / (e - a), this._weightNext = l / (s - i), this._offsetPrev = n * h, this._offsetNext = o * h
            },
            interpolate_: function (t, e, i, r) {
                for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, h = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, f = (i - e) / (r - e), d = f * f, m = d * f, g = -u * m + 2 * u * d - u * f, v = (1 + u) * m + (-1.5 - 2 * u) * d + (-.5 + u) * f + 1, y = (-1 - p) * m + (1.5 + p) * d + .5 * f, A = p * m - p * d, x = 0; x !== a; ++x) n[x] = g * o[h + x] + v * o[l + x] + y * o[s + x] + A * o[c + x];
                return n
            }
        }), _n.prototype = (0, w.default)((0, y.default)(mn.prototype), {
            constructor: _n,
            interpolate_: function (t, e, i, r) {
                for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, h = (i - e) / (r - e), c = 1 - h, u = 0; u !== a; ++u) n[u] = o[l + u] * c + o[s + u] * h;
                return n
            }
        }), wn.prototype = (0, w.default)((0, y.default)(mn.prototype), {
            constructor: wn,
            interpolate_: function (t) {
                return this.copySampleValue_(t - 1)
            }
        });
        var $l = {
            arraySlice: function (t, e, i) {
                return $l.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            },
            convertArray: function (t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function (t) {
                function e(e, i) {
                    return t[e] - t[i]
                }
                for (var i = t.length, r = new Array(i), n = 0; n !== i; ++n) r[n] = n;
                return r.sort(e), r
            },
            sortedArray: function (t, e, i) {
                for (var r = t.length, n = new t.constructor(r), o = 0, a = 0; a !== r; ++o)
                    for (var s = i[o] * e, l = 0; l !== e; ++l) n[a++] = t[s + l];
                return n
            },
            flattenJSON: function (t, e, i, r) {
                for (var n = 1, o = t[0]; void 0 !== o && void 0 === o[r];) o = t[n++];
                if (void 0 !== o) {
                    var a = o[r];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                a = o[r], void 0 !== a && (e.push(o.time), i.push.apply(i, a)), o = t[n++]
                            } while (void 0 !== o);
                        else if (void 0 !== a.toArray)
                        do {
                            a = o[r], void 0 !== a && (e.push(o.time), a.toArray(i, i.length)), o = t[n++]
                        } while (void 0 !== o);
                    else
                        do {
                            a = o[r], void 0 !== a && (e.push(o.time), i.push(a)), o = t[n++]
                        } while (void 0 !== o)
                }
            }
        };
        (0, w.default)(bn, {
            parse: function (t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = bn._getTrackTypeForValueTypeName(t.type);
                if (void 0 === t.times) {
                    var i = [],
                        r = [];
                    $l.flattenJSON(t.keys, i, r, "value"), t.times = i, t.values = r
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            },
            toJSON: function (t) {
                var e, i = t.constructor;
                if (void 0 !== i.toJSON) e = i.toJSON(t);
                else {
                    e = {
                        name: t.name,
                        times: $l.convertArray(t.times, Array),
                        values: $l.convertArray(t.values, Array)
                    };
                    var r = t.getInterpolation();
                    r !== t.DefaultInterpolation && (e.interpolation = r)
                }
                return e.type = t.ValueTypeName, e
            },
            _getTrackTypeForValueTypeName: function (t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return An;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Mn;
                    case "color":
                        return yn;
                    case "quaternion":
                        return vn;
                    case "bool":
                    case "boolean":
                        return dn;
                    case "string":
                        return fn
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }
        }), (0, w.default)(bn.prototype, {
            constructor: bn,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function (t) {
                return new wn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function (t) {
                return new _n(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function (t) {
                return new xn(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function (t) {
                var e;
                switch (t) {
                    case 2300:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 !== e) this.createInterpolant = e;
                else {
                    var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw new Error(i);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                }
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, r = e.length; i !== r; ++i) e[i] += t;
                return this
            },
            scale: function (t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, r = e.length; i !== r; ++i) e[i] *= t;
                return this
            },
            trim: function (t, e) {
                for (var i = this.times, r = i.length, n = 0, o = r - 1; n !== r && i[n] < t;) ++n;
                for (; - 1 !== o && i[o] > e;) --o;
                if (++o, 0 !== n || o !== r) {
                    n >= o && (o = Math.max(o, 1), n = o - 1);
                    var a = this.getValueSize();
                    this.times = $l.arraySlice(i, n, o), this.values = $l.arraySlice(this.values, n * a, o * a)
                }
                return this
            },
            validate: function () {
                var t = !0,
                    e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                var i = this.times,
                    r = this.values,
                    n = i.length;
                0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                for (var o = null, a = 0; a !== n; a++) {
                    var s = i[a];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                        break
                    }
                    if (null !== o && o > s) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                        break
                    }
                    o = s
                }
                if (void 0 !== r && $l.isTypedArray(r))
                    for (var a = 0, l = r.length; a !== l; ++a) {
                        var h = r[a];
                        if (isNaN(h)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, h), t = !1;
                            break
                        }
                    }
                return t
            },
            optimize: function () {
                for (var t = this.times, e = this.values, i = this.getValueSize(), r = 2302 === this.getInterpolation(), n = 1, o = t.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        l = t[a];
                    if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                        if (r) s = !0;
                        else
                            for (var h = a * i, c = h - i, u = h + i, p = 0; p !== i; ++p) {
                                var f = e[h + p];
                                if (f !== e[c + p] || f !== e[u + p]) {
                                    s = !0;
                                    break
                                }
                            }
                    if (s) {
                        if (a !== n) {
                            t[n] = t[a];
                            for (var d = a * i, m = n * i, p = 0; p !== i; ++p) e[m + p] = e[d + p]
                        }++n
                    }
                }
                if (o > 0) {
                    t[n] = t[o];
                    for (var d = o * i, m = n * i, p = 0; p !== i; ++p) e[m + p] = e[d + p];
                    ++n
                }
                return n !== t.length && (this.times = $l.arraySlice(t, 0, n), this.values = $l.arraySlice(e, 0, n * i)), this
            }
        }), Mn.prototype = (0, w.default)((0, y.default)(bn.prototype), {
            constructor: Mn,
            ValueTypeName: "vector"
        }), (0, w.default)(Tn, {
            parse: function (t) {
                for (var e = [], i = t.tracks, r = 1 / (t.fps || 1), n = 0, o = i.length; n !== o; ++n) e.push(bn.parse(i[n]).scale(r));
                return new Tn(t.name, t.duration, e)
            },
            toJSON: function (t) {
                for (var e = [], i = t.tracks, r = {
                        name: t.name,
                        duration: t.duration,
                        tracks: e
                    }, n = 0, o = i.length; n !== o; ++n) e.push(bn.toJSON(i[n]));
                return r
            },
            CreateFromMorphTargetSequence: function (t, e, i, r) {
                for (var n = e.length, o = [], a = 0; a < n; a++) {
                    var s = [],
                        l = [];
                    s.push((a + n - 1) % n, a, (a + 1) % n), l.push(0, 1, 0);
                    var h = $l.getKeyframeOrder(s);
                    s = $l.sortedArray(s, 1, h), l = $l.sortedArray(l, 1, h), r || 0 !== s[0] || (s.push(n), l.push(l[0])), o.push(new An(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / i))
                }
                return new Tn(t, -1, o)
            },
            findByName: function (t, e) {
                var i = t;
                if (!Array.isArray(t)) {
                    var r = t;
                    i = r.geometry && r.geometry.animations || r.animations
                }
                for (var n = 0; n < i.length; n++)
                    if (i[n].name === e) return i[n];
                return null
            },
            CreateClipsFromMorphTargetSequences: function (t, e, i) {
                for (var r = {}, n = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                    var s = t[o],
                        l = s.name.match(n);
                    if (l && l.length > 1) {
                        var h = l[1],
                            c = r[h];
                        c || (r[h] = c = []), c.push(s)
                    }
                }
                var u = [];
                for (var h in r) u.push(Tn.CreateFromMorphTargetSequence(h, r[h], e, i));
                return u
            },
            parseAnimation: function (t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var i = function (t, e, i, r, n) {
                        if (0 !== i.length) {
                            var o = [],
                                a = [];
                            $l.flattenJSON(i, o, a, r), 0 !== o.length && n.push(new t(e, o, a))
                        }
                    }, r = [], n = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
                    var h = s[l].keys;
                    if (h && 0 !== h.length)
                        if (h[0].morphTargets) {
                            for (var c = {}, u = 0; u < h.length; u++)
                                if (h[u].morphTargets)
                                    for (var p = 0; p < h[u].morphTargets.length; p++) c[h[u].morphTargets[p]] = -1;
                            for (var f in c) {
                                for (var d = [], m = [], p = 0; p !== h[u].morphTargets.length; ++p) {
                                    var g = h[u];
                                    d.push(g.time), m.push(g.morphTarget === f ? 1 : 0)
                                }
                                r.push(new An(".morphTargetInfluence[" + f + "]", d, m))
                            }
                            o = c.length * (a || 1)
                        } else {
                            var v = ".bones[" + e[l].name + "]";
                            i(Mn, v + ".position", h, "pos", r), i(vn, v + ".quaternion", h, "rot", r), i(Mn, v + ".scale", h, "scl", r)
                        }
                }
                return 0 === r.length ? null : new Tn(n, o, r)
            }
        }), (0, w.default)(Tn.prototype, {
            resetDuration: function () {
                for (var t = this.tracks, e = 0, i = 0, r = t.length; i !== r; ++i) {
                    var n = this.tracks[i];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                this.duration = e
            },
            trim: function () {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function () {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        }), (0, w.default)(Sn.prototype, {
            load: function (t, e, i, r) {
                var n = this;
                new Tr(n.manager).load(t, function (t) {
                    e(n.parse(JSON.parse(t)))
                }, i, r)
            },
            setTextures: function (t) {
                this.textures = t
            },
            parse: function (t) {
                function e(t) {
                    return r[t], r[t]
                }
                var r = this.textures,
                    n = new jl[t.type];
                if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (n.uniforms = t.uniforms), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = e(t.map)), void 0 !== t.alphaMap && (n.alphaMap = e(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = e(t.normalMap)), void 0 !== t.normalScale) {
                    var o = t.normalScale;
                    !1 === Array.isArray(o) && (o = [o, o]), n.normalScale = (new i).fromArray(o)
                }
                return void 0 !== t.displacementMap && (n.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = e(t.specularMap)), void 0 !== t.envMap && (n.envMap = e(t.envMap)), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = e(t.gradientMap)), n
            }
        }), (0, w.default)(En.prototype, {
            load: function (t, e, i, r) {
                var n = this;
                new Tr(n.manager).load(t, function (t) {
                    e(n.parse(JSON.parse(t)))
                }, i, r)
            },
            parse: function (t) {
                var e = new J,
                    i = t.data.index;
                if (void 0 !== i) {
                    var r = new th[i.type](i.array);
                    e.setIndex(new k(r, 1))
                }
                var n = t.data.attributes;
                for (var a in n) {
                    var s = n[a],
                        r = new th[s.type](s.array);
                    e.addAttribute(a, new k(r, s.itemSize, s.normalized))
                }
                var l = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== l)
                    for (var h = 0, c = l.length; h !== c; ++h) {
                        var u = l[h];
                        e.addGroup(u.start, u.count, u.materialIndex)
                    }
                var p = t.data.boundingSphere;
                if (void 0 !== p) {
                    var f = new o;
                    void 0 !== p.center && f.fromArray(p.center), e.boundingSphere = new A(f, p.radius)
                }
                return e
            }
        });
        var th = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        Cn.Handlers = {
            handlers: [],
            add: function (t, e) {
                this.handlers.push(t, e)
            },
            get: function (t) {
                for (var e = this.handlers, i = 0, r = e.length; i < r; i += 2) {
                    var n = e[i],
                        o = e[i + 1];
                    if (n.test(t)) return o
                }
                return null
            }
        }, (0, w.default)(Cn.prototype, {
            crossOrigin: void 0,
            onLoadStart: function () {},
            onLoadProgress: function () {},
            onLoadComplete: function () {},
            initMaterials: function (t, e, i) {
                for (var r = [], n = 0; n < t.length; ++n) r[n] = this.createMaterial(t[n], e, i);
                return r
            },
            createMaterial: function () {
                var t = {
                        NoBlending: ya,
                        NormalBlending: Aa,
                        AdditiveBlending: xa,
                        SubtractiveBlending: _a,
                        MultiplyBlending: wa,
                        CustomBlending: ba
                    },
                    e = new T,
                    i = new Lr,
                    r = new Sn;
                return function (n, o, a) {
                    function s(t, e, r, n, s) {
                        var h, c = o + t,
                            u = Cn.Handlers.get(c);
                        null !== u ? h = u.load(c) : (i.setCrossOrigin(a), h = i.load(c)), void 0 !== e && (h.repeat.fromArray(e), 1 !== e[0] && (h.wrapS = hs), 1 !== e[1] && (h.wrapT = hs)), void 0 !== r && h.offset.fromArray(r), void 0 !== n && ("repeat" === n[0] && (h.wrapS = hs), "mirror" === n[0] && (h.wrapS = us), "repeat" === n[1] && (h.wrapT = hs), "mirror" === n[1] && (h.wrapT = us)), void 0 !== s && (h.anisotropy = s);
                        var p = _l.generateUUID();
                        return l[p] = h, p
                    }
                    var l = {},
                        h = {
                            uuid: _l.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                    for (var c in n) {
                        var u = n[c];
                        switch (c) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                h.name = u;
                                break;
                            case "blending":
                                h.blending = t[u];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                break;
                            case "colorDiffuse":
                                h.color = e.fromArray(u).getHex();
                                break;
                            case "colorSpecular":
                                h.specular = e.fromArray(u).getHex();
                                break;
                            case "colorEmissive":
                                h.emissive = e.fromArray(u).getHex();
                                break;
                            case "specularCoef":
                                h.shininess = u;
                                break;
                            case "shading":
                                "basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                h.map = s(u, n.mapDiffuseRepeat, n.mapDiffuseOffset, n.mapDiffuseWrap, n.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                h.emissiveMap = s(u, n.mapEmissiveRepeat, n.mapEmissiveOffset, n.mapEmissiveWrap, n.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                h.lightMap = s(u, n.mapLightRepeat, n.mapLightOffset, n.mapLightWrap, n.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                h.aoMap = s(u, n.mapAORepeat, n.mapAOOffset, n.mapAOWrap, n.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                h.bumpMap = s(u, n.mapBumpRepeat, n.mapBumpOffset, n.mapBumpWrap, n.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                h.bumpScale = u;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                h.normalMap = s(u, n.mapNormalRepeat, n.mapNormalOffset, n.mapNormalWrap, n.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                h.normalScale = u;
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                h.specularMap = s(u, n.mapSpecularRepeat, n.mapSpecularOffset, n.mapSpecularWrap, n.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                h.metalnessMap = s(u, n.mapMetalnessRepeat, n.mapMetalnessOffset, n.mapMetalnessWrap, n.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                h.roughnessMap = s(u, n.mapRoughnessRepeat, n.mapRoughnessOffset, n.mapRoughnessWrap, n.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                h.alphaMap = s(u, n.mapAlphaRepeat, n.mapAlphaOffset, n.mapAlphaWrap, n.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                h.side = fa;
                                break;
                            case "doubleSided":
                                h.side = da;
                                break;
                            case "transparency":
                                h.opacity = u;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                h[c] = u;
                                break;
                            case "vertexColors":
                                !0 === u && (h.vertexColors = va), "face" === u && (h.vertexColors = ga);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", c, u)
                        }
                    }
                    return "MeshBasicMaterial" === h.type && delete h.emissive, "MeshPhongMaterial" !== h.type && delete h.specular, h.opacity < 1 && (h.transparent = !0), r.setTextures(l), r.parse(h)
                }
            }()
        });
        var eh = {
            decodeText: function (t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                for (var e = "", i = 0, r = t.length; i < r; i++) e += String.fromCharCode(t[i]);
                return decodeURIComponent(escape(e))
            },
            extractUrlBase: function (t) {
                var e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        };
        (0, w.default)(Pn.prototype, {
            load: function (t, e, i, r) {
                var n = this,
                    o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : eh.extractUrlBase(t),
                    a = new Tr(this.manager);
                a.setWithCredentials(this.withCredentials), a.load(t, function (i) {
                    var r = JSON.parse(i),
                        a = r.metadata;
                    if (void 0 !== a) {
                        var s = a.type;
                        if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.")
                    }
                    var l = n.parse(r, o);
                    e(l.geometry, l.materials)
                }, i, r)
            },
            setTexturePath: function (t) {
                this.texturePath = t
            },
            parse: function () {
                function t(t, e) {
                    function r(t, e) {
                        return t & 1 << e
                    }
                    var n, a, s, l, h, c, u, p, f, d, m, g, v, y, A, x, _, w, b, M, S, E, C, P, L, D, R, I = t.faces,
                        O = t.vertices,
                        N = t.normals,
                        k = t.colors,
                        F = t.scale,
                        z = 0;
                    if (void 0 !== t.uvs) {
                        for (n = 0; n < t.uvs.length; n++) t.uvs[n].length && z++;
                        for (n = 0; n < z; n++) e.faceVertexUvs[n] = []
                    }
                    for (l = 0, h = O.length; l < h;) w = new o, w.x = O[l++] * F, w.y = O[l++] * F, w.z = O[l++] * F, e.vertices.push(w);
                    for (l = 0, h = I.length; l < h;)
                        if (d = I[l++], m = r(d, 0), g = r(d, 1), v = r(d, 3), y = r(d, 4), A = r(d, 5), x = r(d, 6), _ = r(d, 7), m) {
                            if (M = new B, M.a = I[l], M.b = I[l + 1], M.c = I[l + 3], S = new B, S.a = I[l + 1], S.b = I[l + 2], S.c = I[l + 3], l += 4, g && (f = I[l++], M.materialIndex = f, S.materialIndex = f), s = e.faces.length, v)
                                for (n = 0; n < z; n++)
                                    for (P = t.uvs[n], e.faceVertexUvs[n][s] = [], e.faceVertexUvs[n][s + 1] = [], a = 0; a < 4; a++) p = I[l++], D = P[2 * p], R = P[2 * p + 1], L = new i(D, R), 2 !== a && e.faceVertexUvs[n][s].push(L), 0 !== a && e.faceVertexUvs[n][s + 1].push(L);
                            if (y && (u = 3 * I[l++], M.normal.set(N[u++], N[u++], N[u]), S.normal.copy(M.normal)), A)
                                for (n = 0; n < 4; n++) u = 3 * I[l++], C = new o(N[u++], N[u++], N[u]), 2 !== n && M.vertexNormals.push(C), 0 !== n && S.vertexNormals.push(C);
                            if (x && (c = I[l++], E = k[c], M.color.setHex(E), S.color.setHex(E)), _)
                                for (n = 0; n < 4; n++) c = I[l++], E = k[c], 2 !== n && M.vertexColors.push(new T(E)), 0 !== n && S.vertexColors.push(new T(E));
                            e.faces.push(M), e.faces.push(S)
                        } else {
                            if (b = new B, b.a = I[l++], b.b = I[l++], b.c = I[l++], g && (f = I[l++], b.materialIndex = f), s = e.faces.length, v)
                                for (n = 0; n < z; n++)
                                    for (P = t.uvs[n], e.faceVertexUvs[n][s] = [], a = 0; a < 3; a++) p = I[l++], D = P[2 * p], R = P[2 * p + 1], L = new i(D, R), e.faceVertexUvs[n][s].push(L);
                            if (y && (u = 3 * I[l++], b.normal.set(N[u++], N[u++], N[u])), A)
                                for (n = 0; n < 3; n++) u = 3 * I[l++], C = new o(N[u++], N[u++], N[u]), b.vertexNormals.push(C);
                            if (x && (c = I[l++], b.color.setHex(k[c])), _)
                                for (n = 0; n < 3; n++) c = I[l++], b.vertexColors.push(new T(k[c]));
                            e.faces.push(b)
                        }
                }

                function e(t, e) {
                    var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)
                        for (var r = 0, n = t.skinWeights.length; r < n; r += i) {
                            var o = t.skinWeights[r],
                                a = i > 1 ? t.skinWeights[r + 1] : 0,
                                s = i > 2 ? t.skinWeights[r + 2] : 0,
                                l = i > 3 ? t.skinWeights[r + 3] : 0;
                            e.skinWeights.push(new h(o, a, s, l))
                        }
                    if (t.skinIndices)
                        for (var r = 0, n = t.skinIndices.length; r < n; r += i) {
                            var c = t.skinIndices[r],
                                u = i > 1 ? t.skinIndices[r + 1] : 0,
                                p = i > 2 ? t.skinIndices[r + 2] : 0,
                                f = i > 3 ? t.skinIndices[r + 3] : 0;
                            e.skinIndices.push(new h(c, u, p, f))
                        }
                    e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || (e.skinIndices.length, e.vertices.length))
                }

                function r(t, e) {
                    var i = t.scale;
                    if (void 0 !== t.morphTargets)
                        for (var r = 0, n = t.morphTargets.length; r < n; r++) {
                            e.morphTargets[r] = {}, e.morphTargets[r].name = t.morphTargets[r].name, e.morphTargets[r].vertices = [];
                            for (var a = e.morphTargets[r].vertices, s = t.morphTargets[r].vertices, l = 0, h = s.length; l < h; l += 3) {
                                var c = new o;
                                c.x = s[l] * i, c.y = s[l + 1] * i, c.z = s[l + 2] * i, a.push(c)
                            }
                        }
                    if (void 0 !== t.morphColors && t.morphColors.length > 0)
                        for (var u = e.faces, p = t.morphColors[0].colors, r = 0, n = u.length; r < n; r++) u[r].color.fromArray(p, 3 * r)
                }

                function n(t, e) {
                    var i = [],
                        r = [];
                    void 0 !== t.animation && r.push(t.animation), void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                    for (var n = 0; n < r.length; n++) {
                        var o = Tn.parseAnimation(r[n], e.bones);
                        o && i.push(o)
                    }
                    if (e.morphTargets) {
                        var a = Tn.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                        i = i.concat(a)
                    }
                    i.length > 0 && (e.animations = i)
                }
                return function (i, o) {
                    void 0 !== i.data && (i = i.data), void 0 !== i.scale ? i.scale = 1 / i.scale : i.scale = 1;
                    var a = new N;
                    return t(i, a), e(i, a), r(i, a), n(i, a), a.computeFaceNormals(), a.computeBoundingSphere(), void 0 === i.materials || 0 === i.materials.length ? {
                        geometry: a
                    } : {
                        geometry: a,
                        materials: Cn.prototype.initMaterials(i.materials, o, this.crossOrigin)
                    }
                }
            }()
        }), (0, w.default)(Ln.prototype, {
            load: function (t, e, i, r) {
                "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                var n = this;
                new Tr(n.manager).load(t, function (i) {
                    var o = null;
                    try {
                        o = JSON.parse(i)
                    } catch (e) {
                        return void 0 !== r && r(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    var a = o.metadata;
                    if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.");
                    n.parse(o, e)
                }, i, r)
            },
            setTexturePath: function (t) {
                this.texturePath = t
            },
            setCrossOrigin: function (t) {
                this.crossOrigin = t
            },
            parse: function (t, e) {
                var i = this.parseShape(t.shapes),
                    r = this.parseGeometries(t.geometries, i),
                    n = this.parseImages(t.images, function () {
                        void 0 !== e && e(s)
                    }),
                    o = this.parseTextures(t.textures, n),
                    a = this.parseMaterials(t.materials, o),
                    s = this.parseObject(t.object, r, a);
                return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
            },
            parseShape: function (t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = 0, r = t.length; i < r; i++) {
                        var n = (new en).fromJSON(t[i]);
                        e[n.uuid] = n
                    }
                return e
            },
            parseGeometries: function (t, e) {
                var i = {};
                if (void 0 !== t)
                    for (var r = new Pn, n = new En, o = 0, a = t.length; o < a; o++) {
                        var s, l = t[o];
                        switch (l.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                s = new Hl[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                s = new Hl[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                s = new Hl[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                s = new Hl[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                s = new Hl[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                s = new Hl[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                s = new Hl[l.type](l.radius, l.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                s = new Hl[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                s = new Hl[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                s = new Hl[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                s = new Hl[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                s = new Hl[l.type](l.vertices, l.indices, l.radius, l.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                for (var h = [], c = 0, u = l.shapes.length; c < u; c++) {
                                    var p = e[l.shapes[c]];
                                    h.push(p)
                                }
                                s = new Hl[l.type](h, l.curveSegments);
                                break;
                            case "BufferGeometry":
                                s = n.parse(l);
                                break;
                            case "Geometry":
                                s = r.parse(l, this.texturePath).geometry;
                                break;
                            default:
                                continue
                        }
                        s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), i[l.uuid] = s
                    }
                return i
            },
            parseMaterials: function (t, e) {
                var i = {};
                if (void 0 !== t) {
                    var r = new Sn;
                    r.setTextures(e);
                    for (var n = 0, o = t.length; n < o; n++) {
                        var a = t[n];
                        if ("MultiMaterial" === a.type) {
                            for (var s = [], l = 0; l < a.materials.length; l++) s.push(r.parse(a.materials[l]));
                            i[a.uuid] = s
                        } else i[a.uuid] = r.parse(a)
                    }
                }
                return i
            },
            parseAnimations: function (t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var r = Tn.parse(t[i]);
                    e.push(r)
                }
                return e
            },
            parseImages: function (t, e) {
                var i = this,
                    r = {};
                if (void 0 !== t && t.length > 0) {
                    var n = new Mr(e),
                        o = new Cr(n);
                    o.setCrossOrigin(this.crossOrigin);
                    for (var a = 0, s = t.length; a < s; a++) {
                        var l = t[a],
                            h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
                        r[l.uuid] = function (t) {
                            return i.manager.itemStart(t), o.load(t, function () {
                                i.manager.itemEnd(t)
                            }, void 0, function () {
                                i.manager.itemEnd(t), i.manager.itemError(t)
                            })
                        }(h)
                    }
                }
                return r
            },
            parseTextures: function (t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : e[t]
                }
                var r = {};
                if (void 0 !== t)
                    for (var n = 0, o = t.length; n < o; n++) {
                        var a = t[n];
                        a.image, e[a.image];
                        var l = new s(e[a.image]);
                        l.needsUpdate = !0, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = i(a.mapping, ih)), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = i(a.wrap[0], rh), l.wrapT = i(a.wrap[1], rh)), void 0 !== a.format && (l.format = a.format), void 0 !== a.minFilter && (l.minFilter = i(a.minFilter, nh)), void 0 !== a.magFilter && (l.magFilter = i(a.magFilter, nh)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), r[a.uuid] = l
                    }
                return r
            },
            parseObject: function (t, e, i) {
                function r(t) {
                    return e[t], e[t]
                }

                function n(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], r = 0, n = t.length; r < n; r++) {
                                var o = t[r];
                                i[o], e.push(i[o])
                            }
                            return e
                        }
                        return i[t], i[t]
                    }
                }
                var o;
                switch (t.type) {
                    case "Scene":
                        o = new ke, void 0 !== t.background && (0, S.default)(t.background) && (o.background = new T(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new Ne(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new Be(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        o = new De(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = (0, w.default)({}, t.view));
                        break;
                    case "OrthographicCamera":
                        o = new O(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.view && (o.view = (0, w.default)({}, t.view));
                        break;
                    case "AmbientLight":
                        o = new un(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        o = new cn(t.color, t.intensity);
                        break;
                    case "PointLight":
                        o = new ln(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        o = new pn(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        o = new sn(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        o = new nn(t.color, t.groundColor, t.intensity);
                        break;
                    case "SkinnedMesh":
                    case "Mesh":
                        var a = r(t.geometry),
                            s = n(t.material);
                        o = a.bones && a.bones.length > 0 ? new He(a, s) : new at(a, s);
                        break;
                    case "LOD":
                        o = new Ue;
                        break;
                    case "Line":
                        o = new We(r(t.geometry), n(t.material), t.mode);
                        break;
                    case "LineLoop":
                        o = new Xe(r(t.geometry), n(t.material));
                        break;
                    case "LineSegments":
                        o = new Ye(r(t.geometry), n(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        o = new Je(r(t.geometry), n(t.material));
                        break;
                    case "Sprite":
                        o = new ze(n(t.material));
                        break;
                    case "Group":
                        o = new qe;
                        break;
                    default:
                        o = new R
                }
                if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix), o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.children)
                    for (var l = t.children, h = 0; h < l.length; h++) o.add(this.parseObject(l[h], e, i));
                if ("LOD" === t.type)
                    for (var c = t.levels, u = 0; u < c.length; u++) {
                        var p = c[u],
                            f = o.getObjectByProperty("uuid", p.object);
                        void 0 !== f && o.addLevel(f, p.distance)
                    }
                return o
            }
        });
        var ih = {
                UVMapping: 300,
                CubeReflectionMapping: is,
                CubeRefractionMapping: rs,
                EquirectangularReflectionMapping: ns,
                EquirectangularRefractionMapping: os,
                SphericalReflectionMapping: as,
                CubeUVReflectionMapping: ss,
                CubeUVRefractionMapping: ls
            },
            rh = {
                RepeatWrapping: hs,
                ClampToEdgeWrapping: cs,
                MirroredRepeatWrapping: us
            },
            nh = {
                NearestFilter: ps,
                NearestMipMapNearestFilter: fs,
                NearestMipMapLinearFilter: ds,
                LinearFilter: ms,
                LinearMipMapNearestFilter: gs,
                LinearMipMapLinearFilter: vs
            };
        Dn.prototype = {
            constructor: Dn,
            setOptions: function (t) {
                return this.options = t, this
            },
            load: function (t, e, i, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                var n = this,
                    o = Wl.get(t);
                if (void 0 !== o) return n.manager.itemStart(t), setTimeout(function () {
                    e && e(o), n.manager.itemEnd(t)
                }, 0), o;
                fetch(t).then(function (t) {
                    return t.blob()
                }).then(function (t) {
                    return createImageBitmap(t, n.options)
                }).then(function (i) {
                    Wl.add(t, i), e && e(i), n.manager.itemEnd(t)
                }).catch(function (e) {
                    r && r(e), n.manager.itemEnd(t), n.manager.itemError(t)
                })
            },
            setCrossOrigin: function () {
                return this
            },
            setPath: function (t) {
                return this.path = t, this
            }
        }, (0, w.default)(Rn.prototype, {
            moveTo: function (t, e) {
                this.currentPath = new tn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            },
            lineTo: function (t, e) {
                this.currentPath.lineTo(t, e)
            },
            quadraticCurveTo: function (t, e, i, r) {
                this.currentPath.quadraticCurveTo(t, e, i, r)
            },
            bezierCurveTo: function (t, e, i, r, n, o) {
                this.currentPath.bezierCurveTo(t, e, i, r, n, o)
            },
            splineThru: function (t) {
                this.currentPath.splineThru(t)
            },
            toShapes: function (t, e) {
                function i(t) {
                    for (var e = [], i = 0, r = t.length; i < r; i++) {
                        var n = t[i],
                            o = new en;
                        o.curves = n.curves, e.push(o)
                    }
                    return e
                }
                var r = Vl.isClockWise,
                    n = this.subPaths;
                if (0 === n.length) return [];
                if (!0 === e) return i(n);
                var o, a, s, l = [];
                if (1 === n.length) return a = n[0], s = new en, s.curves = a.curves, l.push(s), l;
                var h = !r(n[0].getPoints());
                h = t ? !h : h;
                var c, u = [],
                    p = [],
                    f = [],
                    d = 0;
                p[d] = void 0, f[d] = [];
                for (var m = 0, g = n.length; m < g; m++) a = n[m], c = a.getPoints(), o = r(c), o = t ? !o : o, o ? (!h && p[d] && d++, p[d] = {
                    s: new en,
                    p: c
                }, p[d].s.curves = a.curves, h && d++, f[d] = []) : f[d].push({
                    h: a,
                    p: c[0]
                });
                if (!p[0]) return i(n);
                if (p.length > 1) {
                    for (var v = !1, y = [], A = 0, x = p.length; A < x; A++) u[A] = [];
                    for (var A = 0, x = p.length; A < x; A++)
                        for (var _ = f[A], w = 0; w < _.length; w++) {
                            for (var b = _[w], M = !0, T = 0; T < p.length; T++)(function (t, e) {
                                for (var i = e.length, r = !1, n = i - 1, o = 0; o < i; n = o++) {
                                    var a = e[n],
                                        s = e[o],
                                        l = s.x - a.x,
                                        h = s.y - a.y;
                                    if (Math.abs(h) > C.default) {
                                        if (h < 0 && (a = e[o], l = -l, s = e[n], h = -h), t.y < a.y || t.y > s.y) continue;
                                        if (t.y === a.y) {
                                            if (t.x === a.x) return !0
                                        } else {
                                            var c = h * (t.x - a.x) - l * (t.y - a.y);
                                            if (0 === c) return !0;
                                            if (c < 0) continue;
                                            r = !r
                                        }
                                    } else {
                                        if (t.y !== a.y) continue;
                                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                                    }
                                }
                                return r
                            })(b.p, p[T].p) && (A !== T && y.push({
                                froms: A,
                                tos: T,
                                hole: w
                            }), M ? (M = !1, u[T].push(b)) : v = !0);
                            M && u[A].push(b)
                        }
                    y.length > 0 && (v || (f = u))
                }
                for (var S, m = 0, E = p.length; m < E; m++) {
                    s = p[m].s, l.push(s), S = f[m];
                    for (var P = 0, L = S.length; P < L; P++) s.holes.push(S[P].h)
                }
                return l
            }
        }), (0, w.default)(In.prototype, {
            isFont: !0,
            generateShapes: function (t, e, i) {
                void 0 === e && (e = 100), void 0 === i && (i = 4);
                for (var r = [], n = On(t, e, i, this.data), o = 0, a = n.length; o < a; o++) Array.prototype.push.apply(r, n[o].toShapes());
                return r
            }
        }), (0, w.default)(Nn.prototype, {
            load: function (t, e, i, r) {
                var n = this,
                    o = new Tr(this.manager);
                o.setPath(this.path), o.load(t, function (t) {
                    var i;
                    try {
                        i = JSON.parse(t)
                    } catch (e) {
                        i = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var r = n.parse(i);
                    e && e(r)
                }, i, r)
            },
            parse: function (t) {
                return new In(t)
            },
            setPath: function (t) {
                return this.path = t, this
            }
        });
        var oh, ah = {
            getContext: function () {
                return void 0 === oh && (oh = new(window.AudioContext || window.webkitAudioContext)), oh
            },
            setContext: function (t) {
                oh = t
            }
        };
        (0, w.default)(kn.prototype, {
            load: function (t, e, i, r) {
                var n = new Tr(this.manager);
                n.setResponseType("arraybuffer"), n.load(t, function (t) {
                    ah.getContext().decodeAudioData(t, function (t) {
                        e(t)
                    })
                }, i, r)
            }
        }), (0, w.default)(Fn.prototype, {
            update: function () {
                var t, e, i, n, o, a, s, l, h = new r,
                    c = new r;
                return function (r) {
                    if (t !== this || e !== r.focus || i !== r.fov || n !== r.aspect * this.aspect || o !== r.near || a !== r.far || s !== r.zoom || l !== this.eyeSep) {
                        t = this, e = r.focus, i = r.fov, n = r.aspect * this.aspect, o = r.near, a = r.far, s = r.zoom;
                        var u = r.projectionMatrix.clone();
                        l = this.eyeSep / 2;
                        var p, f, d = l * o / e,
                            m = o * Math.tan(_l.DEG2RAD * i * .5) / s;
                        c.elements[12] = -l, h.elements[12] = l, p = -m * n + d, f = m * n + d, u.elements[0] = 2 * o / (f - p), u.elements[8] = (f + p) / (f - p), this.cameraL.projectionMatrix.copy(u), p = -m * n - d, f = m * n - d, u.elements[0] = 2 * o / (f - p), u.elements[8] = (f + p) / (f - p), this.cameraR.projectionMatrix.copy(u)
                    }
                    this.cameraL.matrixWorld.copy(r.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(r.matrixWorld).multiply(h)
                }
            }()
        }), zn.prototype = (0, y.default)(R.prototype), zn.prototype.constructor = zn, Un.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: Un,
            getInput: function () {
                return this.gain
            },
            removeFilter: function () {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function () {
                return this.filter
            },
            setFilter: function (t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function () {
                return this.gain.gain.value
            },
            setMasterVolume: function (t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: function () {
                var t = new o,
                    e = new n,
                    i = new o,
                    r = new o;
                return function (n) {
                    R.prototype.updateMatrixWorld.call(this, n);
                    var o = this.context.listener,
                        a = this.up;
                    this.matrixWorld.decompose(t, e, i), r.set(0, 0, -1).applyQuaternion(e), o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime), o.positionY.setValueAtTime(t.y, this.context.currentTime), o.positionZ.setValueAtTime(t.z, this.context.currentTime), o.forwardX.setValueAtTime(r.x, this.context.currentTime), o.forwardY.setValueAtTime(r.y, this.context.currentTime), o.forwardZ.setValueAtTime(r.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z), o.setOrientation(r.x, r.y, r.z, a.x, a.y, a.z))
                }
            }()
        }), Gn.prototype = (0, w.default)((0, y.default)(R.prototype), {
            constructor: Gn,
            getOutput: function () {
                return this.gain
            },
            setNodeSource: function (t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setBuffer: function (t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function () {
                if (!0 !== this.isPlaying && !1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                }
            },
            pause: function () {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this
            },
            stop: function () {
                if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this
            },
            connect: function () {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function () {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function () {
                return this.filters
            },
            setFilters: function (t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            getFilter: function () {
                return this.getFilters()[0]
            },
            setFilter: function (t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function (t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this
            },
            getPlaybackRate: function () {
                return this.playbackRate
            },
            onEnded: function () {
                this.isPlaying = !1
            },
            getLoop: function () {
                return !1 !== this.hasPlaybackControl && this.loop
            },
            setLoop: function (t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this
            },
            getVolume: function () {
                return this.gain.gain.value
            },
            setVolume: function (t) {
                return this.gain.gain.value = t, this
            }
        }), Vn.prototype = (0, w.default)((0, y.default)(Gn.prototype), {
            constructor: Vn,
            getOutput: function () {
                return this.panner
            },
            getRefDistance: function () {
                return this.panner.refDistance
            },
            setRefDistance: function (t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function () {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function (t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function () {
                return this.panner.distanceModel
            },
            setDistanceModel: function (t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function () {
                return this.panner.maxDistance
            },
            setMaxDistance: function (t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: function () {
                var t = new o;
                return function (e) {
                    R.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
                }
            }()
        }), (0, w.default)(Hn.prototype, {
            getFrequencyData: function () {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function () {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), (0, w.default)(jn.prototype, {
            accumulate: function (t, e) {
                var i = this.buffer,
                    r = this.valueSize,
                    n = t * r + r,
                    o = this.cumulativeWeight;
                if (0 === o) {
                    for (var a = 0; a !== r; ++a) i[n + a] = i[a];
                    o = e
                } else {
                    o += e;
                    var s = e / o;
                    this._mixBufferRegion(i, n, 0, s, r)
                }
                this.cumulativeWeight = o
            },
            apply: function (t) {
                var e = this.valueSize,
                    i = this.buffer,
                    r = t * e + e,
                    n = this.cumulativeWeight,
                    o = this.binding;
                if (this.cumulativeWeight = 0, n < 1) {
                    var a = 3 * e;
                    this._mixBufferRegion(i, r, a, 1 - n, e)
                }
                for (var s = e, l = e + e; s !== l; ++s)
                    if (i[s] !== i[s + e]) {
                        o.setValue(i, r);
                        break
                    }
            },
            saveOriginalState: function () {
                var t = this.binding,
                    e = this.buffer,
                    i = this.valueSize,
                    r = 3 * i;
                t.getValue(e, r);
                for (var n = i, o = r; n !== o; ++n) e[n] = e[r + n % i];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function () {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _select: function (t, e, i, r, n) {
                if (r >= .5)
                    for (var o = 0; o !== n; ++o) t[e + o] = t[i + o]
            },
            _slerp: function (t, e, i, r) {
                n.slerpFlat(t, e, t, e, t, i, r)
            },
            _lerp: function (t, e, i, r, n) {
                for (var o = 1 - r, a = 0; a !== n; ++a) {
                    var s = e + a;
                    t[s] = t[s] * o + t[i + a] * r
                }
            }
        });
        var sh = "\\[\\]\\.:\\/";
        (0, w.default)(Wn.prototype, {
            getValue: function (t, e) {
                this.bind();
                var i = this._targetGroup.nCachedObjects_,
                    r = this._bindings[i];
                void 0 !== r && r.getValue(t, e)
            },
            setValue: function (t, e) {
                for (var i = this._bindings, r = this._targetGroup.nCachedObjects_, n = i.length; r !== n; ++r) i[r].setValue(t, e)
            },
            bind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), (0, w.default)(Yn, {
            Composite: Wn,
            create: function (t, e, i) {
                return t && t.isAnimationObjectGroup ? new Yn.Composite(t, e, i) : new Yn(t, e, i)
            },
            sanitizeNodeName: function () {
                var t = new RegExp("[" + sh + "]", "g");
                return function (e) {
                    return e.replace(/\s/g, "_").replace(t, "")
                }
            }(),
            parseTrackName: function () {
                var t = "[^" + sh + "]",
                    e = "[^" + sh.replace("\\.", "") + "]",
                    i = /((?:WC+[\/:])*)/.source.replace("WC", t),
                    r = /(WCOD+)?/.source.replace("WCOD", e),
                    n = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                    o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                    a = new RegExp("^" + i + r + n + o + "$"),
                    s = ["material", "materials", "bones"];
                return function (t) {
                    var e = a.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var i = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        r = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var n = i.nodeName.substring(r + 1); - 1 !== s.indexOf(n) && (i.nodeName = i.nodeName.substring(0, r), i.objectName = n)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i
                }
            }(),
            findNode: function (t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = t.skeleton.getBoneByName(e);
                    if (void 0 !== i) return i
                }
                if (t.children) {
                    var r = function t(i) {
                        for (var r = 0; r < i.length; r++) {
                            var n = i[r];
                            if (n.name === e || n.uuid === e) return n;
                            var o = t(n.children);
                            if (o) return o
                        }
                        return null
                    }(t.children);
                    if (r) return r
                }
                return null
            }
        }), (0, w.default)(Yn.prototype, {
            _getValue_unavailable: function () {},
            _setValue_unavailable: function () {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function (t, e) {
                t[e] = this.node[this.propertyName]
            }, function (t, e) {
                for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) t[e++] = i[r]
            }, function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function (t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function (t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function (t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function (t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (t, e) {
                    for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++]
                }, function (t, e) {
                    for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function (t, e) {
                    for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function (t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function (t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function (t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function (t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function (t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function (t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function () {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    r = e.propertyName,
                    n = e.propertyIndex;
                if (t || (t = Yn.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (i) {
                    var o = e.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === o) {
                                    o = a;
                                    break
                                } break;
                        default:
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var s = t[r];
                if (void 0 === s) {
                    var l = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", t)
                }
                var h = this.Versioning.None;
                void 0 !== t.needsUpdate ? (h = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                var c = this.BindingType.Direct;
                if (void 0 !== n) {
                    if ("morphTargetInfluences" === r) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (t.geometry.isBufferGeometry) {
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            for (var a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                if (t.geometry.morphAttributes.position[a].name === n) {
                                    n = a;
                                    break
                                }
                        } else {
                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                            for (var a = 0; a < this.node.geometry.morphTargets.length; a++)
                                if (t.geometry.morphTargets[a].name === n) {
                                    n = a;
                                    break
                                }
                        }
                    }
                    c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = n
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][h]
            },
            unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), (0, w.default)(Yn.prototype, {
            _getValue_unbound: Yn.prototype.getValue,
            _setValue_unbound: Yn.prototype.setValue
        }), (0, w.default)(Xn.prototype, {
            isAnimationObjectGroup: !0,
            add: function () {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, r = this._indicesByUUID, n = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, h = 0, c = arguments.length; h !== c; ++h) {
                    var u = arguments[h],
                        p = u.uuid,
                        f = r[p];
                    if (void 0 === f) {
                        f = e++, r[p] = f, t.push(u);
                        for (var d = 0, m = s; d !== m; ++d) a[d].push(new Yn(u, n[d], o[d]))
                    } else if (f < i) {
                        l = t[f];
                        var g = --i,
                            v = t[g];
                        r[v.uuid] = f, t[f] = v, r[p] = g, t[g] = u;
                        for (var d = 0, m = s; d !== m; ++d) {
                            var y = a[d],
                                A = y[g],
                                x = y[f];
                            y[f] = A, void 0 === x && (x = new Yn(u, n[d], o[d])), y[g] = x
                        }
                    } else t[f] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            },
            remove: function () {
                for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, n = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                    var s = arguments[o],
                        l = s.uuid,
                        h = i[l];
                    if (void 0 !== h && h >= e) {
                        var c = e++,
                            u = t[c];
                        i[u.uuid] = h, t[h] = u, i[l] = c, t[c] = s;
                        for (var p = 0, f = n; p !== f; ++p) {
                            var d = r[p],
                                m = d[c],
                                g = d[h];
                            d[h] = m, d[c] = g
                        }
                    }
                }
                this.nCachedObjects_ = e
            },
            uncache: function () {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, o = n.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var l = arguments[a],
                        h = l.uuid,
                        c = r[h];
                    if (void 0 !== c)
                        if (delete r[h], c < i) {
                            var u = --i,
                                p = t[u],
                                f = --e,
                                d = t[f];
                            r[p.uuid] = c, t[c] = p, r[d.uuid] = u, t[u] = d, t.pop();
                            for (var m = 0, g = o; m !== g; ++m) {
                                var v = n[m],
                                    y = v[u],
                                    A = v[f];
                                v[c] = y, v[u] = A, v.pop()
                            }
                        } else {
                            var f = --e,
                                d = t[f];
                            r[d.uuid] = c, t[c] = d, t.pop();
                            for (var m = 0, g = o; m !== g; ++m) {
                                var v = n[m];
                                v[c] = v[f], v.pop()
                            }
                        }
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function (t, e) {
                var i = this._bindingsIndicesByPath,
                    r = i[t],
                    n = this._bindings;
                if (void 0 !== r) return n[r];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    l = s.length,
                    h = this.nCachedObjects_,
                    c = new Array(l);
                r = n.length, i[t] = r, o.push(t), a.push(e), n.push(c);
                for (var u = h, p = s.length; u !== p; ++u) {
                    var f = s[u];
                    c[u] = new Yn(f, t, e)
                }
                return c
            },
            unsubscribe_: function (t) {
                var e = this._bindingsIndicesByPath,
                    i = e[t];
                if (void 0 !== i) {
                    var r = this._paths,
                        n = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    e[t[a]] = i, o[i] = s, o.pop(), n[i] = n[a], n.pop(), r[i] = r[a], r.pop()
                }
            }
        }), (0, w.default)(Qn.prototype, {
            play: function () {
                return this._mixer._activateAction(this), this
            },
            stop: function () {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function () {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function () {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function () {
                return this._mixer._isActiveAction(this)
            },
            startAt: function (t) {
                return this._startTime = t, this
            },
            setLoop: function (t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function (t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function () {
                return this._effectiveWeight
            },
            fadeIn: function (t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function (t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function (t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    var r = this._clip.duration,
                        n = t._clip.duration,
                        o = n / r,
                        a = r / n;
                    t.warp(1, o, e), this.warp(a, 1, e)
                }
                return this
            },
            crossFadeTo: function (t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function () {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function (t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function () {
                return this._effectiveTimeScale
            },
            setDuration: function (t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function (t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function (t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function (t, e, i) {
                var r = this._mixer,
                    n = r.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                var s = o.parameterPositions,
                    l = o.sampleValues;
                return s[0] = n, s[1] = n + i, l[0] = t / a, l[1] = e / a, this
            },
            stopWarping: function () {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function () {
                return this._mixer
            },
            getClip: function () {
                return this._clip
            },
            getRoot: function () {
                return this._localRoot || this._mixer._root
            },
            _update: function (t, e, i, r) {
                if (!this.enabled) return void this._updateWeight(t);
                var n = this._startTime;
                if (null !== n) {
                    var o = (t - n) * i;
                    if (o < 0 || 0 === i) return;
                    this._startTime = null, e = i * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e),
                    s = this._updateWeight(t);
                if (s > 0)
                    for (var l = this._interpolants, h = this._propertyBindings, c = 0, u = l.length; c !== u; ++c) l[c].evaluate(a), h[c].accumulate(r, s)
            },
            _updateWeight: function (t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var i = this._weightInterpolant;
                    if (null !== i) {
                        var r = i.evaluate(t)[0];
                        e *= r, t > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            },
            _updateTimeScale: function (t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var i = this._timeScaleInterpolant;
                    if (null !== i) {
                        e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e, e
            },
            _updateTime: function (t) {
                var e = this.time + t;
                if (0 === t) return e;
                var i = this._clip.duration,
                    r = this.loop,
                    n = this._loopCount;
                if (2200 === r) {
                    -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t: {
                        if (e >= i) e = i;
                        else {
                            if (!(e < 0)) break t;
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    var o = 2202 === r;
                    if (-1 === n && (t >= 0 ? (n = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || e < 0) {
                        var a = Math.floor(e / i);
                        e -= i * a, n += Math.abs(a);
                        var s = this.repetitions - n;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                var l = t < 0;
                                this._setEndings(l, !l, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = n, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a
                            })
                        }
                    }
                    if (o && 1 == (1 & n)) return this.time = e, i - e
                }
                return this.time = e, e
            },
            _setEndings: function (t, e, i) {
                var r = this._interpolantSettings;
                i ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = t ? this.zeroSlopeAtStart ? 2401 : ll : 2402, r.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : ll : 2402)
            },
            _scheduleFading: function (t, e, i) {
                var r = this._mixer,
                    n = r.time,
                    o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                var a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = n, s[0] = e, a[1] = n + t, s[1] = i, this
            }
        }), Jn.prototype = (0, w.default)((0, y.default)(e.prototype), {
            constructor: Jn,
            _bindAction: function (t, e) {
                var i = t._localRoot || this._root,
                    r = t._clip.tracks,
                    n = r.length,
                    o = t._propertyBindings,
                    a = t._interpolants,
                    s = i.uuid,
                    l = this._bindingsByRootAndName,
                    h = l[s];
                void 0 === h && (h = {}, l[s] = h);
                for (var c = 0; c !== n; ++c) {
                    var u = r[c],
                        p = u.name,
                        f = h[p];
                    if (void 0 !== f) o[c] = f;
                    else {
                        if (void 0 !== (f = o[c])) {
                            null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, s, p));
                            continue
                        }
                        var d = e && e._propertyBindings[c].binding.parsedPath;
                        f = new jn(Yn.create(i, p, d), u.ValueTypeName, u.getValueSize()), ++f.referenceCount, this._addInactiveBinding(f, s, p), o[c] = f
                    }
                    a[c].resultBuffer = f.buffer
                }
            },
            _activateAction: function (t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            i = t._clip.uuid,
                            r = this._actionsByClip[i];
                        this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (var n = t._propertyBindings, o = 0, a = n.length; o !== a; ++o) {
                        var s = n[o];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function (t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, r = e.length; i !== r; ++i) {
                        var n = e[i];
                        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function (t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            },
            _addInactiveAction: function (t, e, i) {
                var r = this._actions,
                    n = this._actionsByClip,
                    o = n[e];
                if (void 0 === o) o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, n[e] = o;
                else {
                    var a = o.knownActions;
                    t._byClipCacheIndex = a.length, a.push(t)
                }
                t._cacheIndex = r.length, r.push(t), o.actionByRoot[i] = t
            },
            _removeInactiveAction: function (t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    r = t._cacheIndex;
                i._cacheIndex = r, e[r] = i, e.pop(), t._cacheIndex = null;
                var n = t._clip.uuid,
                    o = this._actionsByClip,
                    a = o[n],
                    s = a.knownActions,
                    l = s[s.length - 1],
                    h = t._byClipCacheIndex;
                l._byClipCacheIndex = h, s[h] = l, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[n], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function (t) {
                for (var e = t._propertyBindings, i = 0, r = e.length; i !== r; ++i) {
                    var n = e[i];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function (t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    r = this._nActiveActions++,
                    n = e[r];
                t._cacheIndex = r, e[r] = t, n._cacheIndex = i, e[i] = n
            },
            _takeBackAction: function (t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    r = --this._nActiveActions,
                    n = e[r];
                t._cacheIndex = r, e[r] = t, n._cacheIndex = i, e[i] = n
            },
            _addInactiveBinding: function (t, e, i) {
                var r = this._bindingsByRootAndName,
                    n = r[e],
                    o = this._bindings;
                void 0 === n && (n = {}, r[e] = n), n[i] = t, t._cacheIndex = o.length, o.push(t)
            },
            _removeInactiveBinding: function (t) {
                var e = this._bindings,
                    i = t.binding,
                    r = i.rootNode.uuid,
                    n = i.path,
                    o = this._bindingsByRootAndName,
                    a = o[r],
                    s = e[e.length - 1],
                    l = t._cacheIndex;
                s._cacheIndex = l, e[l] = s, e.pop(), delete a[n];
                t: {
                    for (var h in a) break t;delete o[r]
                }
            },
            _lendBinding: function (t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    r = this._nActiveBindings++,
                    n = e[r];
                t._cacheIndex = r, e[r] = t, n._cacheIndex = i, e[i] = n
            },
            _takeBackBinding: function (t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    r = --this._nActiveBindings,
                    n = e[r];
                t._cacheIndex = r, e[r] = t, n._cacheIndex = i, e[i] = n
            },
            _lendControlInterpolant: function () {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && (i = new _n(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
            },
            _takeBackControlInterpolant: function (t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    n = e[r];
                t.__cacheIndex = r, e[r] = t, n.__cacheIndex = i, e[i] = n
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function (t, e) {
                var i = e || this._root,
                    r = i.uuid,
                    n = "string" == typeof t ? Tn.findByName(i, t) : t,
                    o = null !== n ? n.uuid : t,
                    a = this._actionsByClip[o],
                    s = null;
                if (void 0 !== a) {
                    var l = a.actionByRoot[r];
                    if (void 0 !== l) return l;
                    s = a.knownActions[0], null === n && (n = s._clip)
                }
                if (null === n) return null;
                var h = new Qn(this, n, e);
                return this._bindAction(h, s), this._addInactiveAction(h, o, r), h
            },
            existingAction: function (t, e) {
                var i = e || this._root,
                    r = i.uuid,
                    n = "string" == typeof t ? Tn.findByName(i, t) : t,
                    o = n ? n.uuid : t,
                    a = this._actionsByClip[o];
                return void 0 !== a ? a.actionByRoot[r] || null : null
            },
            stopAllAction: function () {
                var t = this._actions,
                    e = this._nActiveActions,
                    i = this._bindings,
                    r = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var n = 0; n !== e; ++n) t[n].reset();
                for (var n = 0; n !== r; ++n) i[n].useCount = 0;
                return this
            },
            update: function (t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, r = this.time += t, n = (0, M.default)(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                    e[a]._update(r, t, n, o)
                }
                for (var s = this._bindings, l = this._nActiveBindings, a = 0; a !== l; ++a) s[a].apply(o);
                return this
            },
            getRoot: function () {
                return this._root
            },
            uncacheClip: function (t) {
                var e = this._actions,
                    i = t.uuid,
                    r = this._actionsByClip,
                    n = r[i];
                if (void 0 !== n) {
                    for (var o = n.knownActions, a = 0, s = o.length; a !== s; ++a) {
                        var l = o[a];
                        this._deactivateAction(l);
                        var h = l._cacheIndex,
                            c = e[e.length - 1];
                        l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = h, e[h] = c, e.pop(), this._removeInactiveBindingsForAction(l)
                    }
                    delete r[i]
                }
            },
            uncacheRoot: function (t) {
                var e = t.uuid,
                    i = this._actionsByClip;
                for (var r in i) {
                    var n = i[r].actionByRoot,
                        o = n[e];
                    void 0 !== o && (this._deactivateAction(o), this._removeInactiveAction(o))
                }
                var a = this._bindingsByRootAndName,
                    s = a[e];
                if (void 0 !== s)
                    for (var l in s) {
                        var h = s[l];
                        h.restoreOriginalState(), this._removeInactiveBinding(h)
                    }
            },
            uncacheAction: function (t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        }), qn.prototype.clone = function () {
            return new qn(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Zn.prototype = (0, w.default)((0, y.default)(J.prototype), {
            constructor: Zn,
            isInstancedBufferGeometry: !0,
            copy: function (t) {
                return J.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), (0, x.default)(Kn.prototype, {
            count: {
                get: function () {
                    return this.data.count
                }
            },
            array: {
                get: function () {
                    return this.data.array
                }
            }
        }), (0, w.default)(Kn.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function (t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function (t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function (t, e, i, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = r, this
            },
            setXYZW: function (t, e, i, r, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = r, this.data.array[t + 3] = n, this
            }
        }), Object.defineProperty($n.prototype, "needsUpdate", {
            set: function (t) {
                !0 === t && this.version++
            }
        }), (0, w.default)($n.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () {},
            setArray: function (t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            },
            setDynamic: function (t) {
                return this.dynamic = t, this
            },
            copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function (t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var r = 0, n = this.stride; r < n; r++) this.array[t + r] = e.array[i + r];
                return this
            },
            set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            onUpload: function (t) {
                return this.onUploadCallback = t, this
            }
        }), to.prototype = (0, w.default)((0, y.default)($n.prototype), {
            constructor: to,
            isInstancedInterleavedBuffer: !0,
            copy: function (t) {
                return $n.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), eo.prototype = (0, w.default)((0, y.default)(k.prototype), {
            constructor: eo,
            isInstancedBufferAttribute: !0,
            copy: function (t) {
                return k.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), (0, w.default)(io.prototype, {
            linePrecision: 1,
            set: function (t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function (t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function (t, e, i) {
                var r = i || [];
                return no(t, this, r, e), r.sort(ro), r
            },
            intersectObjects: function (t, e, i) {
                var r = i || [];
                if (!1 === Array.isArray(t)) return r;
                for (var n = 0, o = t.length; n < o; n++) no(t[n], this, r, e);
                return r.sort(ro), r
            }
        }), (0, w.default)(oo.prototype, {
            start: function () {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function () {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function () {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function () {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), (0, w.default)(ao.prototype, {
            set: function (t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function () {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function (t) {
                return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(_l.clamp(t.y / this.radius, -1, 1))), this
            }
        }), (0, w.default)(so.prototype, {
            set: function (t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function (t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }), (0, w.default)(lo.prototype, {
            set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function () {
                var t = new i;
                return function (e, i) {
                    var r = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                }
            }(),
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function (t) {
                return void 0 === t && (t = new i), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (t) {
                return void 0 === t && (t = new i), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function (t, e) {
                return void 0 === e && (e = new i), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function (t, e) {
                return void 0 === e && (e = new i), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function () {
                var t = new i;
                return function (e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), ho.prototype = (0, y.default)(R.prototype), ho.prototype.constructor = ho, ho.prototype.isImmediateRenderObject = !0, co.prototype = (0, y.default)(Ye.prototype), co.prototype.constructor = co, co.prototype.update = function () {
            var t = new o,
                e = new o,
                i = new a;
            return function () {
                var r = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                var n = this.object.matrixWorld,
                    o = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var s = a.vertices, l = a.faces, h = 0, c = 0, u = l.length; c < u; c++)
                        for (var p = l[c], f = 0, d = p.vertexNormals.length; f < d; f++) {
                            var m = s[p[r[f]]],
                                g = p.vertexNormals[f];
                            t.copy(m).applyMatrix4(n), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1
                        } else if (a && a.isBufferGeometry)
                            for (var v = a.attributes.position, y = a.attributes.normal, h = 0, f = 0, d = v.count; f < d; f++) t.set(v.getX(f), v.getY(f), v.getZ(f)).applyMatrix4(n), e.set(y.getX(f), y.getY(f), y.getZ(f)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1;
                o.needsUpdate = !0
            }
        }(), uo.prototype = (0, y.default)(R.prototype), uo.prototype.constructor = uo, uo.prototype.dispose = function () {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, uo.prototype.update = function () {
            var t = new o,
                e = new o;
            return function () {
                this.light.updateMatrixWorld();
                var i = this.light.distance ? this.light.distance : 1e3,
                    r = i * Math.tan(this.light.angle);
                this.cone.scale.set(r, r, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }(), fo.prototype = (0, y.default)(Ye.prototype), fo.prototype.constructor = fo, fo.prototype.updateMatrixWorld = function () {
            var t = new o,
                e = new r,
                i = new r;
            return function (r) {
                var n = this.bones,
                    o = this.geometry,
                    a = o.getAttribute("position");
                i.getInverse(this.root.matrixWorld);
                for (var s = 0, l = 0; s < n.length; s++) {
                    var h = n[s];
                    h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l, t.x, t.y, t.z), e.multiplyMatrices(i, h.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l + 1, t.x, t.y, t.z), l += 2)
                }
                o.getAttribute("position").needsUpdate = !0, R.prototype.updateMatrixWorld.call(this, r)
            }
        }(), mo.prototype = (0, y.default)(at.prototype), mo.prototype.constructor = mo, mo.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, mo.prototype.update = function () {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, go.prototype = (0, y.default)(R.prototype), go.prototype.constructor = go, go.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, go.prototype.update = function () {
            var t = .5 * this.light.width,
                e = .5 * this.light.height,
                i = this.line.geometry.attributes.position,
                r = i.array;
            r[0] = t, r[1] = -e, r[2] = 0, r[3] = t, r[4] = e, r[5] = 0, r[6] = -t, r[7] = e, r[8] = 0, r[9] = -t, r[10] = -e, r[11] = 0, r[12] = t, r[13] = -e, r[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
        }, vo.prototype = (0, y.default)(R.prototype), vo.prototype.constructor = vo, vo.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, vo.prototype.update = function () {
            var t = new o,
                e = new T,
                i = new T;
            return function () {
                var r = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    var n = r.geometry.getAttribute("color");
                    e.copy(this.light.color), i.copy(this.light.groundColor);
                    for (var o = 0, a = n.count; o < a; o++) {
                        var s = o < a / 2 ? e : i;
                        n.setXYZ(o, s.r, s.g, s.b)
                    }
                    n.needsUpdate = !0
                }
                r.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }(), yo.prototype = (0, y.default)(Ye.prototype), yo.prototype.constructor = yo, Ao.prototype = (0, y.default)(Ye.prototype), Ao.prototype.constructor = Ao, xo.prototype = (0, y.default)(Ye.prototype), xo.prototype.constructor = xo, xo.prototype.update = function () {
            var t = new o,
                e = new o,
                i = new a;
            return function () {
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                for (var r = this.object.matrixWorld, n = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, l = 0, h = 0, c = s.length; h < c; h++) {
                    var u = s[h],
                        p = u.normal;
                    t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(r), e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), n.setXYZ(l, t.x, t.y, t.z), l += 1, n.setXYZ(l, e.x, e.y, e.z), l += 1
                }
                n.needsUpdate = !0
            }
        }(), _o.prototype = (0, y.default)(R.prototype), _o.prototype.constructor = _o, _o.prototype.dispose = function () {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, _o.prototype.update = function () {
            var t = new o,
                e = new o,
                i = new o;
            return function () {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length()
            }
        }(), wo.prototype = (0, y.default)(Ye.prototype), wo.prototype.constructor = wo, wo.prototype.update = function () {
            function t(t, o, a, s) {
                r.set(o, a, s).unproject(n);
                var l = i[t];
                if (void 0 !== l)
                    for (var h = e.getAttribute("position"), c = 0, u = l.length; c < u; c++) h.setXYZ(l[c], r.x, r.y, r.z)
            }
            var e, i, r = new o,
                n = new I;
            return function () {
                e = this.geometry, i = this.pointMap;
                n.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            }
        }(), bo.prototype = (0, y.default)(Ye.prototype), bo.prototype.constructor = bo, bo.prototype.update = function () {
            var t = new v;
            return function (e) {
                if (void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    var i = t.min,
                        r = t.max,
                        n = this.geometry.attributes.position,
                        o = n.array;
                    o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = i.x, o[4] = r.y, o[5] = r.z, o[6] = i.x, o[7] = i.y, o[8] = r.z, o[9] = r.x, o[10] = i.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = i.z, o[15] = i.x, o[16] = r.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = r.x, o[22] = i.y, o[23] = i.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), bo.prototype.setFromObject = function (t) {
            return this.object = t, this.update(), this
        }, Mo.prototype = (0, y.default)(Ye.prototype), Mo.prototype.constructor = Mo, Mo.prototype.updateMatrixWorld = function (t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), R.prototype.updateMatrixWorld.call(this, t))
        }, To.prototype = (0, y.default)(We.prototype), To.prototype.constructor = To, To.prototype.updateMatrixWorld = function (t) {
            var e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.lookAt(this.plane.normal), R.prototype.updateMatrixWorld.call(this, t)
        };
        var lh, hh;
        So.prototype = (0, y.default)(R.prototype), So.prototype.constructor = So, So.prototype.setDirection = function () {
            var t, e = new o;
            return function (i) {
                i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
            }
        }(), So.prototype.setLength = function (t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, So.prototype.setColor = function (t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, Eo.prototype = (0, y.default)(Ye.prototype), Eo.prototype.constructor = Eo;
        Dr.create = function (t, e) {
            return t.prototype = (0, y.default)(Dr.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, (0, w.default)($r.prototype, {
            createPointsGeometry: function (t) {
                var e = this.getPoints(t);
                return this.createGeometry(e)
            },
            createSpacedPointsGeometry: function (t) {
                var e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            },
            createGeometry: function (t) {
                for (var e = new N, i = 0, r = t.length; i < r; i++) {
                    var n = t[i];
                    e.vertices.push(new o(n.x, n.y, n.z || 0))
                }
                return e
            }
        }), (0, w.default)(tn.prototype, {
            fromPoints: function (t) {
                this.setFromPoints(t)
            }
        }), Qo.prototype = (0, y.default)(Br.prototype), Jo.prototype = (0, y.default)(Br.prototype), qo.prototype = (0, y.default)(Br.prototype), (0, w.default)(qo.prototype, {
            initFromArray: function () {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function () {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function () {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), yo.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, fo.prototype.update = function () {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, (0, w.default)(Cn.prototype, {
            extractUrlBase: function (t) {
                return eh.extractUrlBase(t)
            }
        }), (0, w.default)(lo.prototype, {
            center: function (t) {
                return this.getCenter(t)
            },
            empty: function () {
                return this.isEmpty()
            },
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            size: function (t) {
                return this.getSize(t)
            }
        }), (0, w.default)(v.prototype, {
            center: function (t) {
                return this.getCenter(t)
            },
            empty: function () {
                return this.isEmpty()
            },
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            isIntersectionSphere: function (t) {
                return this.intersectsSphere(t)
            },
            size: function (t) {
                return this.getSize(t)
            }
        }), nt.prototype.center = function (t) {
            return this.getCenter(t)
        }, (0, w.default)(_l, {
            random16: function () {
                return Math.random()
            },
            nearestPowerOfTwo: function (t) {
                return _l.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function (t) {
                return _l.ceilPowerOfTwo(t)
            }
        }), (0, w.default)(a.prototype, {
            flattenToArrayOffset: function (t, e) {
                return this.toArray(t, e)
            },
            multiplyVector3: function (t) {
                return t.applyMatrix3(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBuffer: function (t) {
                return this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), (0, w.default)(r.prototype, {
            extractPosition: function (t) {
                return this.copyPosition(t)
            },
            flattenToArrayOffset: function (t, e) {
                return this.toArray(t, e)
            },
            getPosition: function () {
                var t;
                return function () {
                    return void 0 === t && (t = new o), t.setFromMatrixColumn(this, 3)
                }
            }(),
            setRotationFromQuaternion: function (t) {
                return this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function () {},
            multiplyVector3: function (t) {
                return t.applyMatrix4(this)
            },
            multiplyVector4: function (t) {
                return t.applyMatrix4(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function (t) {
                t.transformDirection(this)
            },
            crossVector: function (t) {
                return t.applyMatrix4(this)
            },
            translate: function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBuffer: function (t) {
                return this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function (t, e, i, r, n, o) {
                return this.makePerspective(t, e, r, i, n, o)
            }
        }), _.prototype.isIntersectionLine = function (t) {
            return this.intersectsLine(t)
        }, n.prototype.multiplyVector3 = function (t) {
            return t.applyQuaternion(this)
        }, (0, w.default)(rt.prototype, {
            isIntersectionBox: function (t) {
                return this.intersectsBox(t)
            },
            isIntersectionPlane: function (t) {
                return this.intersectsPlane(t)
            },
            isIntersectionSphere: function (t) {
                return this.intersectsSphere(t)
            }
        }), (0, w.default)(ot.prototype, {
            area: function () {
                return this.getArea()
            },
            barycoordFromPoint: function (t, e) {
                return this.getBarycoord(t, e)
            },
            midpoint: function (t) {
                return this.getMidpoint(t)
            },
            normal: function (t) {
                return this.getNormal(t)
            },
            plane: function (t) {
                return this.getPlane(t)
            }
        }), (0, w.default)(ot, {
            barycoordFromPoint: function (t, e, i, r, n) {
                return ot.getBarycoord(t, e, i, r, n)
            },
            normal: function (t, e, i, r) {
                return ot.getNormal(t, e, i, r)
            }
        }), (0, w.default)(en.prototype, {
            extractAllPoints: function (t) {
                return this.extractPoints(t)
            },
            extrude: function (t) {
                return new Ji(this, t)
            },
            makeGeometry: function (t) {
                return new or(this, t)
            }
        }), (0, w.default)(i.prototype, {
            fromAttribute: function (t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function (t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), (0, w.default)(o.prototype, {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function (t) {
                return this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function (t) {
                return this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function (t, e) {
                return this.setFromMatrixColumn(e, t)
            },
            applyProjection: function (t) {
                return this.applyMatrix4(t)
            },
            fromAttribute: function (t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function (t) {
                return this.manhattanDistanceTo(t)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), (0, w.default)(h.prototype, {
            fromAttribute: function (t, e, i) {
                return this.fromBufferAttribute(t, e, i)
            },
            lengthManhattan: function () {
                return this.manhattanLength()
            }
        }), (0, w.default)(N.prototype, {
            computeTangents: function () {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function () {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            }
        }), (0, w.default)(R.prototype, {
            getChildByName: function (t) {
                return this.getObjectByName(t)
            },
            renderDepth: function () {},
            translate: function (t, e) {
                return this.translateOnAxis(e, t)
            },
            getWorldRotation: function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }
        }), (0, x.default)(R.prototype, {
            eulerOrder: {
                get: function () {
                    return this.rotation.order
                },
                set: function (t) {
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function () {},
                set: function () {}
            }
        }), (0, x.default)(Ue.prototype, {
            objects: {
                get: function () {
                    return this.levels
                }
            }
        }), Object.defineProperty(Ge.prototype, "useVertexTexture", {
            get: function () {},
            set: function () {}
        }), Object.defineProperty(Dr.prototype, "__arcLengthDivisions", {
            get: function () {
                return this.arcLengthDivisions
            },
            set: function (t) {
                this.arcLengthDivisions = t
            }
        }), De.prototype.setLens = function (t, e) {
            void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, (0, x.default)(rn.prototype, {
            onlyShadow: {
                set: function () {}
            },
            shadowCameraFov: {
                set: function (t) {
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function (t) {
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function (t) {
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function (t) {
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function (t) {
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function (t) {
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function (t) {
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function () {}
            },
            shadowBias: {
                set: function (t) {
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function () {}
            },
            shadowMapWidth: {
                set: function (t) {
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function (t) {
                    this.shadow.mapSize.height = t
                }
            }
        }), (0, x.default)(k.prototype, {
            length: {
                get: function () {
                    return this.array.length
                }
            },
            copyIndicesArray: function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }
        }), (0, w.default)(J.prototype, {
            addIndex: function (t) {
                this.setIndex(t)
            },
            addDrawCall: function (t, e, i) {
                this.addGroup(t, e)
            },
            clearDrawCalls: function () {
                this.clearGroups()
            },
            computeTangents: function () {},
            computeOffsets: function () {}
        }), (0, x.default)(J.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function () {
                    return this.groups
                }
            }
        }), (0, x.default)(qn.prototype, {
            dynamic: {
                set: function () {}
            },
            onUpdate: {
                value: function () {
                    return this
                }
            }
        }), (0, x.default)(tt.prototype, {
            wrapAround: {
                get: function () {},
                set: function () {}
            },
            wrapRGB: {
                get: function () {
                    return new T
                }
            },
            shading: {
                get: function () {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function (t) {
                    this.flatShading = 1 === t
                }
            }
        }), (0, x.default)(Ar.prototype, {
            metal: {
                get: function () {
                    return !1
                },
                set: function () {}
            }
        }), (0, x.default)(it.prototype, {
            derivatives: {
                get: function () {
                    return this.extensions.derivatives
                },
                set: function (t) {
                    this.extensions.derivatives = t
                }
            }
        }), (0, w.default)(Oe.prototype, {
            getCurrentRenderTarget: function () {
                return this.getRenderTarget()
            },
            getMaxAnisotropy: function () {
                return this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function () {
                return this.capabilities.precision
            },
            resetGLState: function () {
                return this.state.reset()
            },
            supportsFloatTextures: function () {
                return this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function () {
                return this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function () {
                return this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function () {
                return this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function () {
                return this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function () {
                return this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function () {
                return this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function () {
                return this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function (t) {
                this.setScissorTest(t)
            },
            initMaterial: function () {},
            addPrePlugin: function () {},
            addPostPlugin: function () {},
            updateShadowMap: function () {},
            setFaceCulling: function () {}
        }), (0, x.default)(Oe.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                },
                set: function (t) {
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                },
                set: function (t) {
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function () {},
                set: function () {}
            }
        }), (0, x.default)(Te.prototype, {
            cullFace: {
                get: function () {},
                set: function () {}
            },
            renderReverseSided: {
                get: function () {},
                set: function () {}
            },
            renderSingleSided: {
                get: function () {},
                set: function () {}
            }
        }), (0, x.default)(u.prototype, {
            wrapS: {
                get: function () {
                    return this.texture.wrapS
                },
                set: function (t) {
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function () {
                    return this.texture.wrapT
                },
                set: function (t) {
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function () {
                    return this.texture.magFilter
                },
                set: function (t) {
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function () {
                    return this.texture.minFilter
                },
                set: function (t) {
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function () {
                    return this.texture.anisotropy
                },
                set: function (t) {
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function () {
                    return this.texture.offset
                },
                set: function (t) {
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function () {
                    return this.texture.repeat
                },
                set: function (t) {
                    this.texture.repeat = t
                }
            },
            format: {
                get: function () {
                    return this.texture.format
                },
                set: function (t) {
                    this.texture.format = t
                }
            },
            type: {
                get: function () {
                    return this.texture.type
                },
                set: function (t) {
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function () {
                    return this.texture.generateMipmaps
                },
                set: function (t) {
                    this.texture.generateMipmaps = t
                }
            }
        }), (0, x.default)(Ie.prototype, {
            standing: {
                set: function () {}
            }
        }), Gn.prototype.load = function (t) {
            var e = this;
            return (new kn).load(t, function (t) {
                e.setBuffer(t)
            }), this
        }, Hn.prototype.getData = function () {
            return this.getFrequencyData()
        }, zn.prototype.updateCubeMap = function (t, e) {
            return this.update(t, e)
        };
        var ch = {
                merge: function (t, e, i) {
                    var r;
                    e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, i)
                },
                center: function (t) {
                    return t.center()
                }
            },
            uh = {
                crossOrigin: void 0,
                loadTexture: function (t, e, i, r) {
                    var n = new Lr;
                    n.setCrossOrigin(this.crossOrigin);
                    var o = n.load(t, i, void 0, r);
                    return e && (o.mapping = e), o
                },
                loadTextureCube: function (t, e, i, r) {
                    var n = new Pr;
                    n.setCrossOrigin(this.crossOrigin);
                    var o = n.load(t, i, void 0, r);
                    return e && (o.mapping = e), o
                },
                loadCompressedTexture: function () {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function () {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            },
            ph = {
                createMultiMaterialObject: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
        t.WebGLRenderTargetCube = f, t.WebGLRenderTarget = u, t.WebGLRenderer = Oe, t.ShaderLib = El, t.UniformsLib = Sl, t.UniformsUtils = Ml, t.ShaderChunk = bl, t.FogExp2 = Be, t.Fog = Ne, t.Scene = ke, t.Sprite = ze, t.LOD = Ue, t.SkinnedMesh = He, t.Skeleton = Ge, t.Bone = Ve, t.Mesh = at, t.LineSegments = Ye, t.LineLoop = Xe, t.Line = We, t.Points = Je, t.Group = qe, t.VideoTexture = Ze, t.DataTexture = m, t.CompressedTexture = Ke, t.CubeTexture = yt, t.CanvasTexture = Se, t.DepthTexture = $e, t.Texture = s, t.CompressedTextureLoader = Sr, t.DataTextureLoader = Er, t.CubeTextureLoader = Pr, t.TextureLoader = Lr, t.ObjectLoader = Ln, t.MaterialLoader = Sn, t.BufferGeometryLoader = En, t.DefaultLoadingManager = Yl, t.LoadingManager = Mr, t.JSONLoader = Pn, t.ImageLoader = Cr, t.ImageBitmapLoader = Dn, t.FontLoader = Nn, t.FileLoader = Tr, t.Loader = Cn, t.LoaderUtils = eh, t.Cache = Wl, t.AudioLoader = kn, t.SpotLightShadow = an, t.SpotLight = sn, t.PointLight = ln, t.RectAreaLight = pn, t.HemisphereLight = nn, t.DirectionalLightShadow = hn, t.DirectionalLight = cn, t.AmbientLight = un, t.LightShadow = on, t.Light = rn, t.StereoCamera = Fn, t.PerspectiveCamera = De, t.OrthographicCamera = O, t.CubeCamera = zn, t.ArrayCamera = Re, t.Camera = I, t.AudioListener = Un, t.PositionalAudio = Vn, t.AudioContext = ah, t.AudioAnalyser = Hn, t.Audio = Gn, t.VectorKeyframeTrack = Mn, t.StringKeyframeTrack = fn, t.QuaternionKeyframeTrack = vn, t.NumberKeyframeTrack = An, t.ColorKeyframeTrack = yn, t.BooleanKeyframeTrack = dn, t.PropertyMixer = jn, t.PropertyBinding = Yn, t.KeyframeTrack = bn, t.AnimationUtils = $l, t.AnimationObjectGroup = Xn, t.AnimationMixer = Jn, t.AnimationClip = Tn, t.Uniform = qn, t.InstancedBufferGeometry = Zn, t.BufferGeometry = J, t.Geometry = N, t.InterleavedBufferAttribute = Kn, t.InstancedInterleavedBuffer = to, t.InterleavedBuffer = $n, t.InstancedBufferAttribute = eo, t.Face3 = B, t.Object3D = R, t.Raycaster = io, t.Layers = D, t.EventDispatcher = e, t.Clock = oo, t.QuaternionLinearInterpolant = gn, t.LinearInterpolant = _n, t.DiscreteInterpolant = wn, t.CubicInterpolant = xn, t.Interpolant = mn, t.Triangle = ot, t.Math = _l, t.Spherical = ao, t.Cylindrical = so, t.Plane = _, t.Frustum = b, t.Sphere = A, t.Ray = rt, t.Matrix4 = r, t.Matrix3 = a, t.Box3 = v, t.Box2 = lo, t.Line3 = nt, t.Euler = P, t.Vector4 = h, t.Vector3 = o, t.Vector2 = i, t.Quaternion = n, t.Color = T, t.ImmediateRenderObject = ho, t.VertexNormalsHelper = co, t.SpotLightHelper = uo, t.SkeletonHelper = fo, t.PointLightHelper = mo, t.RectAreaLightHelper = go, t.HemisphereLightHelper = vo, t.GridHelper = yo, t.PolarGridHelper = Ao, t.FaceNormalsHelper = xo, t.DirectionalLightHelper = _o, t.CameraHelper = wo, t.BoxHelper = bo, t.Box3Helper = Mo, t.PlaneHelper = To, t.ArrowHelper = So, t.AxesHelper = Eo, t.Shape = en, t.Path = tn, t.ShapePath = Rn, t.Font = In, t.CurvePath = $r, t.Curve = Dr, t.ShapeUtils = Vl, t.WebGLUtils = Le, t.WireframeGeometry = ti, t.ParametricGeometry = ei, t.ParametricBufferGeometry = ii, t.TetrahedronGeometry = oi, t.TetrahedronBufferGeometry = ai, t.OctahedronGeometry = si, t.OctahedronBufferGeometry = li, t.IcosahedronGeometry = hi, t.IcosahedronBufferGeometry = ci, t.DodecahedronGeometry = ui, t.DodecahedronBufferGeometry = pi, t.PolyhedronGeometry = ri, t.PolyhedronBufferGeometry = ni, t.TubeGeometry = fi, t.TubeBufferGeometry = di, t.TorusKnotGeometry = mi, t.TorusKnotBufferGeometry = gi, t.TorusGeometry = vi, t.TorusBufferGeometry = yi, t.TextGeometry = Zi, t.TextBufferGeometry = Ki, t.SphereGeometry = $i, t.SphereBufferGeometry = tr, t.RingGeometry = er, t.RingBufferGeometry = ir, t.PlaneGeometry = K, t.PlaneBufferGeometry = $, t.LatheGeometry = rr, t.LatheBufferGeometry = nr, t.ShapeGeometry = or, t.ShapeBufferGeometry = ar, t.ExtrudeGeometry = Ji, t.ExtrudeBufferGeometry = qi, t.EdgesGeometry = lr, t.ConeGeometry = ur, t.ConeBufferGeometry = pr, t.CylinderGeometry = hr, t.CylinderBufferGeometry = cr, t.CircleGeometry = fr, t.CircleBufferGeometry = dr, t.BoxGeometry = q, t.BoxBufferGeometry = Z, t.ShadowMaterial = mr, t.SpriteMaterial = Fe, t.RawShaderMaterial = gr, t.ShaderMaterial = it, t.PointsMaterial = Qe, t.MeshPhysicalMaterial = yr, t.MeshStandardMaterial = vr, t.MeshPhongMaterial = Ar, t.MeshToonMaterial = xr, t.MeshNormalMaterial = _r, t.MeshLambertMaterial = wr, t.MeshDepthMaterial = be, t.MeshDistanceMaterial = Me, t.MeshBasicMaterial = et, t.LineDashedMaterial = br;
        t.LineBasicMaterial = je, t.Material = tt, t.Float64BufferAttribute = Y, t.Float32BufferAttribute = W, t.Uint32BufferAttribute = j, t.Int32BufferAttribute = H, t.Uint16BufferAttribute = V, t.Int16BufferAttribute = G, t.Uint8ClampedBufferAttribute = U, t.Uint8BufferAttribute = z, t.Int8BufferAttribute = F, t.BufferAttribute = k, t.ArcCurve = Ir, t.CatmullRomCurve3 = Br, t.CubicBezierCurve = Yr, t.CubicBezierCurve3 = Xr, t.EllipseCurve = Rr, t.LineCurve = Qr, t.LineCurve3 = Jr, t.QuadraticBezierCurve = qr, t.QuadraticBezierCurve3 = Zr, t.SplineCurve = Kr, t.REVISION = "92dev", t.MOUSE = aa, t.CullFaceNone = sa, t.CullFaceBack = la, t.CullFaceFront = ha, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = ca, t.PCFSoftShadowMap = ua, t.FrontSide = pa, t.BackSide = fa, t.DoubleSide = da, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = ma, t.FaceColors = ga, t.VertexColors = va, t.NoBlending = ya, t.NormalBlending = Aa, t.AdditiveBlending = xa, t.SubtractiveBlending = _a, t.MultiplyBlending = wa, t.CustomBlending = ba, t.AddEquation = Ma, t.SubtractEquation = Ta, t.ReverseSubtractEquation = Sa, t.MinEquation = Ea, t.MaxEquation = Ca, t.ZeroFactor = Pa, t.OneFactor = La, t.SrcColorFactor = Da, t.OneMinusSrcColorFactor = Ra, t.SrcAlphaFactor = Ia, t.OneMinusSrcAlphaFactor = Oa, t.DstAlphaFactor = Ba, t.OneMinusDstAlphaFactor = Na, t.DstColorFactor = ka, t.OneMinusDstColorFactor = Fa, t.SrcAlphaSaturateFactor = za, t.NeverDepth = Ua, t.AlwaysDepth = Ga, t.LessDepth = Va, t.LessEqualDepth = Ha, t.EqualDepth = ja, t.GreaterEqualDepth = Wa, t.GreaterDepth = Ya, t.NotEqualDepth = Xa, t.MultiplyOperation = Qa, t.MixOperation = Ja, t.AddOperation = qa, t.NoToneMapping = Za, t.LinearToneMapping = Ka, t.ReinhardToneMapping = $a, t.Uncharted2ToneMapping = ts, t.CineonToneMapping = es, t.UVMapping = 300, t.CubeReflectionMapping = is, t.CubeRefractionMapping = rs, t.EquirectangularReflectionMapping = ns, t.EquirectangularRefractionMapping = os, t.SphericalReflectionMapping = as, t.CubeUVReflectionMapping = ss, t.CubeUVRefractionMapping = ls, t.RepeatWrapping = hs, t.ClampToEdgeWrapping = cs, t.MirroredRepeatWrapping = us, t.NearestFilter = ps, t.NearestMipMapNearestFilter = fs, t.NearestMipMapLinearFilter = ds, t.LinearFilter = ms, t.LinearMipMapNearestFilter = gs, t.LinearMipMapLinearFilter = vs, t.UnsignedByteType = ys, t.ByteType = As, t.ShortType = xs, t.UnsignedShortType = _s, t.IntType = ws, t.UnsignedIntType = bs, t.FloatType = Ms, t.HalfFloatType = Ts, t.UnsignedShort4444Type = Ss, t.UnsignedShort5551Type = Es, t.UnsignedShort565Type = Cs, t.UnsignedInt248Type = Ps, t.AlphaFormat = Ls, t.RGBFormat = Ds, t.RGBAFormat = Rs, t.LuminanceFormat = Is, t.LuminanceAlphaFormat = Os, t.RGBEFormat = Bs, t.DepthFormat = Ns, t.DepthStencilFormat = ks, t.RGB_S3TC_DXT1_Format = Fs, t.RGBA_S3TC_DXT1_Format = zs, t.RGBA_S3TC_DXT3_Format = Us, t.RGBA_S3TC_DXT5_Format = Gs, t.RGB_PVRTC_4BPPV1_Format = Vs, t.RGB_PVRTC_2BPPV1_Format = Hs, t.RGBA_PVRTC_4BPPV1_Format = js, t.RGBA_PVRTC_2BPPV1_Format = Ws, t.RGB_ETC1_Format = Ys, t.RGBA_ASTC_4x4_Format = Xs, t.RGBA_ASTC_5x4_Format = Qs, t.RGBA_ASTC_5x5_Format = Js, t.RGBA_ASTC_6x5_Format = qs, t.RGBA_ASTC_6x6_Format = Zs, t.RGBA_ASTC_8x5_Format = Ks, t.RGBA_ASTC_8x6_Format = $s, t.RGBA_ASTC_8x8_Format = tl, t.RGBA_ASTC_10x5_Format = el, t.RGBA_ASTC_10x6_Format = il, t.RGBA_ASTC_10x8_Format = rl, t.RGBA_ASTC_10x10_Format = nl, t.RGBA_ASTC_12x10_Format = ol, t.RGBA_ASTC_12x12_Format = al, t.LoopOnce = 2200, t.LoopRepeat = sl, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = ll, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = hl, t.TriangleStripDrawMode = cl, t.TriangleFanDrawMode = ul, t.LinearEncoding = pl, t.sRGBEncoding = fl, t.GammaEncoding = dl, t.RGBEEncoding = ml, t.LogLuvEncoding = 3003, t.RGBM7Encoding = gl, t.RGBM16Encoding = vl, t.RGBDEncoding = yl, t.BasicDepthPacking = Al, t.RGBADepthPacking = xl, t.CubeGeometry = q, t.Face4 = Co, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = Po, t.MultiMaterial = Lo, t.PointCloud = Do, t.Particle = Ro, t.ParticleSystem = Io, t.PointCloudMaterial = Oo, t.ParticleBasicMaterial = Bo, t.ParticleSystemMaterial = No, t.Vertex = ko, t.DynamicBufferAttribute = Fo, t.Int8Attribute = zo, t.Uint8Attribute = Uo, t.Uint8ClampedAttribute = Go, t.Int16Attribute = Vo, t.Uint16Attribute = Ho, t.Int32Attribute = jo, t.Uint32Attribute = Wo, t.Float32Attribute = Yo, t.Float64Attribute = Xo, t.ClosedSplineCurve3 = Qo, t.SplineCurve3 = Jo, t.Spline = qo, t.AxisHelper = Zo, t.BoundingBoxHelper = Ko, t.EdgesHelper = $o, t.WireframeHelper = ta, t.XHRLoader = ea, t.BinaryTextureLoader = ia, t.GeometryUtils = ch, t.ImageUtils = uh, t.Projector = ra, t.CanvasRenderer = na, t.SceneUtils = ph, t.LensFlare = oa, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
}, function (t, e) {
    var i = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = i)
}, function (t, e) {
    t.exports = function (t) {
        return "object" == typeof t ? null !== t : "function" == typeof t
    }
}, function (t, e, i) {
    var r = i(49)("wks"),
        n = i(34),
        o = i(5).Symbol,
        a = "function" == typeof o;
    (t.exports = function (t) {
        return r[t] || (r[t] = a && o[t] || (a ? o : n)("Symbol." + t))
    }).store = r
}, function (t, e, i) {
    t.exports = !i(13)(function () {
        return 7 != Object.defineProperty({}, "a", {
            get: function () {
                return 7
            }
        }).a
    })
}, function (t, e, i) {
    t.exports = {
        default: i(96),
        __esModule: !0
    }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(44),
        o = r(n),
        a = i(101),
        s = r(a),
        l = i(9),
        h = r(l),
        c = {
            isEmpty: function (t) {
                return !t || (t.length <= 0 || "{}" == (0, h.default)(t))
            },
            cloneOwn: function (t) {
                if ("undefined" === t || null === t || !(t instanceof Array)) return !1;
                var e = [];
                return t.forEach(function (t) {
                    return e.push(JSON.parse((0, h.default)(t)))
                }), e
            },
            isJSON: function (t) {
                if ("string" == typeof t) try {
                    var e = JSON.parse(t);
                    return t.indexOf("{") > -1 ? e : (console.error("The " + t + " isn't json"), !1)
                } catch (e) {
                    return console.error("The " + t + " isn't json"), !1
                }
                return console.error("The " + t + " isn't json"), !1
            },
            getExtremum: function (t) {
                var e = {},
                    i = void 0,
                    r = void 0,
                    n = void 0,
                    o = void 0,
                    a = void 0,
                    s = void 0;
                return t instanceof Array && (t.forEach(function (t, e) {
                    i || r || n || o ? (r = t[0] < r ? t[0] : r, i = i < t[0] ? t[0] : i, n = t[1] < n ? t[1] : n, o = o < t[1] ? t[1] : o) : (i = t[0], r = t[0], o = t[1], n = t[1])
                }), i - r < o - n ? (a = o - n, s = i - r) : (a = i - r, s = o - n), e = {
                    xExtremum: [r, i],
                    yExtremum: [n, o],
                    l: a,
                    w: s
                }), e
            },
            log: function (t) {
                throw new Error(t)
            },
            hasOwn: function (t, e) {
                var i = [],
                    r = new s.default((0, o.default)(t));
                return e.forEach(function (t) {
                    r.has(t) || i.push(t)
                }), i
            },
            mapLogo: function () {
                return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMkAAAAxCAYAAABwB41xAAAKN2lDQ1BzUkdCIElFQzYxOTY2LTIuMQAAeJydlndUU9kWh8+9N71QkhCKlNBraFICSA29SJEuKjEJEErAkAAiNkRUcERRkaYIMijggKNDkbEiioUBUbHrBBlE1HFwFBuWSWStGd+8ee/Nm98f935rn73P3Wfvfda6AJD8gwXCTFgJgAyhWBTh58WIjYtnYAcBDPAAA2wA4HCzs0IW+EYCmQJ82IxsmRP4F726DiD5+yrTP4zBAP+flLlZIjEAUJiM5/L42VwZF8k4PVecJbdPyZi2NE3OMErOIlmCMlaTc/IsW3z2mWUPOfMyhDwZy3PO4mXw5Nwn4405Er6MkWAZF+cI+LkyviZjg3RJhkDGb+SxGXxONgAoktwu5nNTZGwtY5IoMoIt43kA4EjJX/DSL1jMzxPLD8XOzFouEiSniBkmXFOGjZMTi+HPz03ni8XMMA43jSPiMdiZGVkc4XIAZs/8WRR5bRmyIjvYODk4MG0tbb4o1H9d/JuS93aWXoR/7hlEH/jD9ld+mQ0AsKZltdn6h21pFQBd6wFQu/2HzWAvAIqyvnUOfXEeunxeUsTiLGcrq9zcXEsBn2spL+jv+p8Of0NffM9Svt3v5WF485M4knQxQ143bmZ6pkTEyM7icPkM5p+H+B8H/nUeFhH8JL6IL5RFRMumTCBMlrVbyBOIBZlChkD4n5r4D8P+pNm5lona+BHQllgCpSEaQH4eACgqESAJe2Qr0O99C8ZHA/nNi9GZmJ37z4L+fVe4TP7IFiR/jmNHRDK4ElHO7Jr8WgI0IABFQAPqQBvoAxPABLbAEbgAD+ADAkEoiARxYDHgghSQAUQgFxSAtaAYlIKtYCeoBnWgETSDNnAYdIFj4DQ4By6By2AE3AFSMA6egCnwCsxAEISFyBAVUod0IEPIHLKFWJAb5AMFQxFQHJQIJUNCSAIVQOugUqgcqobqoWboW+godBq6AA1Dt6BRaBL6FXoHIzAJpsFasBFsBbNgTzgIjoQXwcnwMjgfLoK3wJVwA3wQ7oRPw5fgEVgKP4GnEYAQETqiizARFsJGQpF4JAkRIauQEqQCaUDakB6kH7mKSJGnyFsUBkVFMVBMlAvKHxWF4qKWoVahNqOqUQdQnag+1FXUKGoK9RFNRmuizdHO6AB0LDoZnYsuRlegm9Ad6LPoEfQ4+hUGg6FjjDGOGH9MHCYVswKzGbMb0445hRnGjGGmsVisOtYc64oNxXKwYmwxtgp7EHsSewU7jn2DI+J0cLY4X1w8TogrxFXgWnAncFdwE7gZvBLeEO+MD8Xz8MvxZfhGfA9+CD+OnyEoE4wJroRIQiphLaGS0EY4S7hLeEEkEvWITsRwooC4hlhJPEQ8TxwlviVRSGYkNimBJCFtIe0nnSLdIr0gk8lGZA9yPFlM3kJuJp8h3ye/UaAqWCoEKPAUVivUKHQqXFF4pohXNFT0VFysmK9YoXhEcUjxqRJeyUiJrcRRWqVUo3RU6YbStDJV2UY5VDlDebNyi/IF5UcULMWI4kPhUYoo+yhnKGNUhKpPZVO51HXURupZ6jgNQzOmBdBSaaW0b2iDtCkVioqdSrRKnkqNynEVKR2hG9ED6On0Mvph+nX6O1UtVU9Vvuom1TbVK6qv1eaoeajx1UrU2tVG1N6pM9R91NPUt6l3qd/TQGmYaYRr5Grs0Tir8XQObY7LHO6ckjmH59zWhDXNNCM0V2ju0xzQnNbS1vLTytKq0jqj9VSbru2hnaq9Q/uE9qQOVcdNR6CzQ+ekzmOGCsOTkc6oZPQxpnQ1df11Jbr1uoO6M3rGelF6hXrtevf0Cfos/ST9Hfq9+lMGOgYhBgUGrQa3DfGGLMMUw12G/YavjYyNYow2GHUZPTJWMw4wzjduNb5rQjZxN1lm0mByzRRjyjJNM91tetkMNrM3SzGrMRsyh80dzAXmu82HLdAWThZCiwaLG0wS05OZw2xljlrSLYMtCy27LJ9ZGVjFW22z6rf6aG1vnW7daH3HhmITaFNo02Pzq62ZLde2xvbaXPJc37mr53bPfW5nbse322N3055qH2K/wb7X/oODo4PIoc1h0tHAMdGx1vEGi8YKY21mnXdCO3k5rXY65vTW2cFZ7HzY+RcXpkuaS4vLo3nG8/jzGueNueq5clzrXaVuDLdEt71uUnddd457g/sDD30PnkeTx4SnqWeq50HPZ17WXiKvDq/XbGf2SvYpb8Tbz7vEe9CH4hPlU+1z31fPN9m31XfKz95vhd8pf7R/kP82/xsBWgHcgOaAqUDHwJWBfUGkoAVB1UEPgs2CRcE9IXBIYMj2kLvzDecL53eFgtCA0O2h98KMw5aFfR+OCQ8Lrwl/GGETURDRv4C6YMmClgWvIr0iyyLvRJlESaJ6oxWjE6Kbo1/HeMeUx0hjrWJXxl6K04gTxHXHY+Oj45vipxf6LNy5cDzBPqE44foi40V5iy4s1licvvj4EsUlnCVHEtGJMYktie85oZwGzvTSgKW1S6e4bO4u7hOeB28Hb5Lvyi/nTyS5JpUnPUp2Td6ePJninlKR8lTAFlQLnqf6p9alvk4LTduf9ik9Jr09A5eRmHFUSBGmCfsytTPzMoezzLOKs6TLnJftXDYlChI1ZUPZi7K7xTTZz9SAxESyXjKa45ZTk/MmNzr3SJ5ynjBvYLnZ8k3LJ/J9879egVrBXdFboFuwtmB0pefK+lXQqqWrelfrry5aPb7Gb82BtYS1aWt/KLQuLC98uS5mXU+RVtGaorH1futbixWKRcU3NrhsqNuI2ijYOLhp7qaqTR9LeCUXS61LK0rfb+ZuvviVzVeVX33akrRlsMyhbM9WzFbh1uvb3LcdKFcuzy8f2x6yvXMHY0fJjpc7l+y8UGFXUbeLsEuyS1oZXNldZVC1tep9dUr1SI1XTXutZu2m2te7ebuv7PHY01anVVda926vYO/Ner/6zgajhop9mH05+x42Rjf2f836urlJo6m06cN+4X7pgYgDfc2Ozc0tmi1lrXCrpHXyYMLBy994f9Pdxmyrb6e3lx4ChySHHn+b+O31w0GHe4+wjrR9Z/hdbQe1o6QT6lzeOdWV0iXtjusePhp4tLfHpafje8vv9x/TPVZzXOV42QnCiaITn07mn5w+lXXq6enk02O9S3rvnIk9c60vvG/wbNDZ8+d8z53p9+w/ed71/LELzheOXmRd7LrkcKlzwH6g4wf7HzoGHQY7hxyHui87Xe4Znjd84or7ldNXva+euxZw7dLI/JHh61HXb95IuCG9ybv56Fb6ree3c27P3FlzF3235J7SvYr7mvcbfjT9sV3qID0+6j068GDBgztj3LEnP2X/9H686CH5YcWEzkTzI9tHxyZ9Jy8/Xvh4/EnWk5mnxT8r/1z7zOTZd794/DIwFTs1/lz0/NOvm1+ov9j/0u5l73TY9P1XGa9mXpe8UX9z4C3rbf+7mHcTM7nvse8rP5h+6PkY9PHup4xPn34D94Tz+49wZioAAAAJcEhZcwAALiMAAC4jAXilP3YAABRiSURBVHic7V0LcBvVud6V9bIsP2XLj8ROCJAnKReIA0lMHJzED9khJSGlFCgZZkqYlgLTC/eRNpSQFLgdevuAtmnLhOFSApSQUmLZcvyAvIDiNrSTNCmXPNwk2CbxU09blrT3+xUZ5NVZaSXL2NzuN+NZabV7zn/O+f//fP9/zq7VgiBwChQokIZ6sgVQoGCqQzESBQpiQDESBQpiQDESBQpiQDESBQpiQDESBQpiYFxGUllZmanVah/iBSF/yOvd2tzc/EmyBFOgYKogISOprq5OU6vV39JptY/gay7H85xep/vaGovlqb7BwZ8ePnzYk2Q5FSiYNMRlJLW1tTocvgED2cxzXKHo50xOpXoyJytrE4xls9VmezUAJE9UBQomB7KMpLS0VFOQl/d1lUq1BV9nRL2Y52fib1dtTc0DdXV1D9fX1x9OgpwKFEwaZBkJDOQOzBLPxVUyz9+A2eZAVVVVcVNTU2dC0ilQMAUgy0gCPK9SCUIrFH8xvqbHUb4K1EyVmGgKFEwNyI5JBJ5/SRCEjdD4p2EsX8EpfgLlCgL0Tmc2m4s1Go05JSUlDd/V+BtjdDBen08QvPjYPzQ01Nnd3X0RoZDkrk3cPi8vL29Wenqkrfv9/tNnzpw5IUMufUZGRkV2djYPuViXHDp58uQgrstCPYU5RiPHabVjLrDb7Z29vb2DUeowoI7pLDmB3nPnzvXiGj4tLa0yNzdXLZJjGH1wvqOj4xSOI7HaIwWj0ViUlZV1mVarTUddn1bA8/z/fgTEU5Zer19gMpn0GMvgd8jr9Hg85zs7O12JygeZ0tFHyzEOnMQ4RN4TCPj9PO9BG7qgL+cBd6x74grcrVbreRy+igD+N6jkZ7CS+bHuwSDFbUwGg2EmGv8fs2fP/jKOZr1Ox6eo1TQ4TMsMWoQgkJIPz5o16/iSJUt+5XQ6nz969KhXfC0G6wYM/M5pRUXB8sKB7804VMaSD7PjcpRhnVFSwhocd1d3d0GorlugwDuLGHUBd+Pvf6LUcUNmRkZrcXExJ/IL1N5HcdiGvxTUsRttMep0urHXAMXTp59ZunTptvfee++FaI5DDPT56szMzK2XX375onSjUUOKHS4DCtqKw2Nyy8O9OeiH99FfBm2YsxACgb6ypUvfdA8NbT1y5EiH3PLCMBPy1UuMQ1RQf0BfBpYtW/a21+v97/b29kNS1yaUAoaxtC5cuPCamSUlP8ToPxjtWggSl5GkpqbWwdO/WFJcnIXBirfxpCnXoAN2GA2Gu8rKytYdOnToQvgF8B5veYeHfVAq6GFE85dRettms0X1blCaavJe8LQs5T94/Phxx+gXKDEHZY+4LiDjEQVSKFYfhN+ZAuVFnwXrEYEqnIW+2Lly5UofPv82ZoVc0EF9o7Cg4BclM2aoDShXbKDi+uUA7ajOzsoywLGI25JD7MTo862BjGtbW1vjSvJQ/9AYUvsZYxkL1D/ZqP8W6OjNqyoqtre9/fbjrIxswouJ5KXXWCwHYhkJGiLbSKC4i2Eguy+fNUsHGsFSQFmggdWnpi7TaLWvw5hXimaUs26P5+/Dw8NXMTrWgDpvxNEWQ87qdLaBkAu3JiT0BIEomU6jeWLOnDmvffjhh8PRroWhXQOP/8wMGAj1f7IAHVjPMJAgqA/hdEz47fcVFRXXtrW1nU9axTJA9UMPUH3K91evXt2PUz8VXzPh21J8Pp+swJ04L7zmz0ERxmUg4UDDy6ZPn34PPu4YPUeeAlSixeVyXcVSBMhRxUUxEvw+C/RpDsNzE/yC19s0bsGTDF6lKgZ1uhkfX4t2HYx/O2YRHWaTpNWN/kqD46umWTfGdXmpev1T+Hhn0iqPA0FjVau3rVq1andLS8vH4b9NuJGgYitmnO9ZbbY3oi0uwptcD+VdhD9JA8G0OAKa4ufGUpUUXK8hL8W6D3TkmxiAX4VzcnDQZrvD8RC8ZgSdUPH8akoOSMkK46iCMatGA1ARPmpobY0roP28oLoUA0kaCZp8GQykkjx+MhzUKGB4NegvgzhmkpDhVktFxfca2to6klC1D/riYwwjDbiW9EU89mh3OuSkfnoi/LwsI1EJgl7g+US3msyDNK/XWix/RMD/XYpnWBdB6EoyEAlueRot3tTX13cMjfaF/4CO0CHO+HpGevp2k8kkTn5Rw+dhGi/Bx3+MngPVOux0ONyY5cYEkiHMRVxC13ewBKF4BHVJcfXGeALkzxOYTSpAJ/Kl9teB138FcZaa0R/jAsZzfbYE1WJAp9LrKXP6wyRUvfNiT893xSfhIFMEn2+ZRqd7wWw2G8X6hlGt4eIxkrq6ukW8IDwMjViPr/eOU+jr4aVbUGYz7/P9516b7c/hP0L55lAAxvJimD02NzY2tkQp+8n8/PzlFCtQoCuCGmVfyYUZCRR5kLItMK4VDKVIQUetwjFi8RSGkQpDXCHF14UpFo+IkIrYZA3HbhcPB3UbzSIs408URLVyTaZqiTQ2G5eWF8ZvJILgaW9v75H4dQ8o4J2glbdQm0X1X0XUHzriHz0VYSTkii0WC/Hyh6GuNyV17uWCKYXVcC8r19TV7dpbX3/XZ7LxmWppb/OnWOV6PJ4jLrebZSTUpizxOcwm+5xO5woaQEYqmNofoUzwOsswi2RIeNtezGrvxZJzUnFJAVk7J+YiZviXZAbrBDitlRiPLFZ/waEQI1Az+v5qzORzbTbb35MqjAiYUQZHRphLSKlVVVWZOPaNnhhjJDCOstqamp/j45fiqI8yJrEJ51iQu7pZdC5Fyh5hADEXnKCgLr/PR53PUvoI9xiKS57ADBRJBXh+OSiavq2tbSj8NKUyo6Sl98dKHU820A9llvLywob9+7vCz8Oj3gZKxEvEWQkD5a3Pkljoc3s8z2G87mM4KUo1reNElCfZICOVeFOQCg50jFWPMRI0pYymm7gq47gtfCBAURDxv+gpjASBTks6z4cXOeJyOntwzGUMopnSoTi+O3qCZlhMzVVGxswTRCDQkGwZJwCpvNFIlOvXoyeIWqBdGzKTHLDTjgFQ0xpWqhyDeers2bO/0Go098JAVRFxwaUZb0KNhKNMJPu8gBlwzCJ0BN3Cjd/kyVg47g5O3taT4b0NDT+rrKzcBc77I/TIepn3TSooe5WTk9MKj3YbK52rurTy/m7YqRmImeZR3MSAP8DzUy71ywJizA1cmJFgdrwaVGteWhLTvgQo/o2gpnmsvoUMjadPnz5eUFBwrtDrncFI1iwE5ZnX1NQUc4tQooDhpko4BTfqHbNdKEI6zApdUPq7EGD/Bo15BqXJol779u07i8OG2traSngCWpCZm4jwnycwi+xzOBxENSIp2qX1kq2j3zHYlaBaKRp29u0vjY2NH7N+mGpAu5aHUy4o6FdpD1oCK9ZRAeO7VWoBER7KSoEx6m11u933MNZlaHYhY3480fpBpVLnz5+/0OVyic9DxQOFWZmZq5iOQRCOhQftBMmeqa+vP1BaWrqowGz+FjToMbnCWa3WfTCU+ymTJfeeyQI68C0YiQ9QM/j4tbXl5XnW/fsv0hcMmmTqFx3bMAVTvyNQCA3DW2pVBsNaHHegLZqc7Oz1Wey1qU/QL/lS60/RQBtTQbVq0xnbcQBHd0/PAfpAcaHD6bwHMzprvWoDzm1LtF8FnvZ+pr0PB6hXi8aWJKLxZq3d4L4I2hzVfbS3t1P4/xMovSvJSa6pgg54so8wWPMYRqLjjMZyHHcHU5m5uculsj8Bjpty8UhAEA6gbTem6vXaCG+uUpGX3kELuIixLmNRyIDf/4rdbn+QEhXxzjKUBUQsUqhnLyC+Bb0K7rz1eDwH4KS8fr9fy3A+C0C5aAPt3+KqPASU1jM8NPSBMS1tSazV/jBQxusF8Um5rffHvuSLB/JSoAQtLrd7HssA4BaIcu3GoF+Pjs6RWDW+CKrVPtGyxgs4tTP9vb0pQk7OinSRkuC3clpYhAHdJkG1RuxO5ysDAwMPxrXGEQL6aR1RLaZxjV1L6oKhHBseHr6W4aTADFUUwH8/bgFCsDscLTq9XraRwLFsYT0g+E//SiFaL3HY7d/ONZlY2xSC2+ajpX7BBWxiDjtV0DcwsAuatsIYuRcuhWKR/IKC9RLbgOh5mDMUdMfLdShbBvpEjziwyhV8gUD2lxYsuGtoZIS74ooriHL1YyZhl8Xz61He44n2L2apfZjNtpjz8qIukoKWBoRAYHtjU9OzrN8jjCTA87mJCPRFBYzkHfBiF/h3GmPRq6R29er58KbMVCYBHTzlqNYoBgcH34By/CQ/P98g9tQpKtWW6dOmmZi8nONepIA3kWAe9SxBXxVJbADlofhPFU6b9umjAqPxgQTmY8ZbiONf4hYE6O/vb4ccA0NDQ6wFzRFI0IUBPCj4fL9sirJNf0wvCCrVyypB+HFdXd11sO4toBF9Ujf+fwG8VB/ijT+hI8tZK8MBleregvz8uRKpX1pIZe5FmwqAkVxE25qh8GvF2y9g8CaJ3b52jP0fnE6nhrV7IRa0ajVRLWa2zB8IvOsdHl5Chilz+wsfynIlZCQY22GTyXT1Jxcu6MJpI+IOL/7sR48edYj3ArIwpiX19fW0v2ndGoulVp2SshfHnVab7fmamppEZPzCAB3W7HS5yllKAV5yn9lsZmW/CO9brdaLEy7gOADOvwuxxVpqm0zFtJJzxLX58dZFC66IcaSoFj02sbm7u3tPUVFRtpxdwSEQ5Xo0UcrV29t7NpH7wsGcT/c2NFgrKipa01JT/7XWYmnCtHScS9Cak4Hw56vHc40UMIs02+327flmc0TcgcHWSe6MHccqO2bsWBpLuddEi/8UMBIrjGSwsLAwU45iEtVKtC44kmsRJDOzZcC5rq6udy5cvNhCK/xyjQT0bDYoF+1+iLl/b6IgSTpD+5Z+UFlZ+WJwJZ3jiiDsm83Nzb0TIQiUcVjqv25BcemZ8aivJcL9BerQc/AMRH0iDzPJX0EvPsExP47HhQM+QWiMKlMgQGsVzP1koLZ50e6lh5DUEmsU/KUXX8gTMhBwIZB+AzPl3TIU82PI2ia3bDFgJLdGyWo10xOiaWlpu/sHBlYS1RO1LYOep2bMdqOUa+oZyShGV9LX1NSsQifvQbzyYkNDw85kv50RPLgT0zHzN3iTO9B5H0gtLNG2qry8PItBYh0DZXcxfwghyF2zsw+4PZ4NEgEnC/9A0B81hw9DoAU5jmX8OFeL2frHcEYRjaat66AsdZL7xAQhrncuY6Z8eaC//25aNIzqBAThNdDHqA5FCjSTZ2dlrWU9zx8qO5j6xcy2+8SJE2/iOOZnjNEvS4qLN0ZsXeeCDpAo1+bJyiLKTl/sbWxsKS0t3Q9+/oDFYrHBWDYnc3kRSvM+Om4Ty+sCD0Gh5pZed90RDPhI4LN7wFqEnCuvvNKSk50908g2Egc6OOa2a6/P1+RwODawtqgw5YX/YCl4OCDrMfx5MbgRC3ow/HIEuY2LFy/+A+odgpKQJfGYJYwzZ86ktY2b0SamLF6/Py7qCxnaEMR3IVotTI1iJH5BSJhqgZJelWY0zpFIBnhckIE+hJzrkPgCULTXMctsZMVO6IFZYDSL8PGPico3HsSV4wutwP+oqqrqZa1G8wRGcA6+v5IMQVwuV/3A4KC7cGQk4mlB2uqeqtdbtGazZZS+hIM6lf4kPFgTvKNdRv17oUhDIwUFejlP5/Hy4pHuIY/nXRh/OSvw12i1q3JNplVkmOFtorawHi8N4SRo4TEZdX8KevcWKNdup8Px7VTpmfKozWZLOO5UR8lqoWWH4FAGot2PWbkNcWE/2sYK6un9ZkS5pr6RjCK0KrkRs8lyqOUWHF1xUrC/BgRha/gJ3HrBZDI9iyDz30Cd2M+rx/luJY5e0iZzyzXVD0V6DgN1P+SINZs4h32+/TLKFNLT05/s6emhLS3MF9nRuXja5Q8Enoo1g7EAJ7Crv7//frSR/UI9QXgpUQodeoxgnSTV4riYT2yiajf63QY5b2fFTqG9XI9Mxh65ca240yZI0KAaTJX3gYLVw1gexbloAdYxMo7GxsY9rAHBID7W3d29FOWVSbzTKh74oVDfgfF+IPcGGOiWru7um1D/ghhP6R1CrCb59sVwYND3XezpeQY04gEZxhcVQiDwGrz984ncCw/dbnc4PoLHns2gRL7hkZGXE5ULMy9t65kn9ZYVUElZjzVDtj2DdvvtEo8Rl4DBLMHxnUTlTBTj3pYS8mrPVldX/45eyQJD2QhFOCC67ARcxTarzfa7aMEXfvPQ08Mo5+n8ggLip9pEdqGCunTDQB6CMb4az32ofwDGWQlq9NuioiLazsFL7fqNo0zE76rv6PX6Pnz+9+zs7NQoWTgm0B56S8yOU6dOPZKot6d+h/K9iplyS8S7BARhfyhBkxAwRl/OysxMkchqfYhxOCmnHLfb3QrKa4dBZzBnk0t7ub54RjIKeDh6U+ImGMn1CD6fDub40UEY0W3g5K/KpQgYTHr74aaSkpKn4XnXQVGvUWs0RSkqlRElagSRdvG0Lw2xLFR5EHV2wDj2e73e3x88eNAhUUVUOJ3OTgzGaihmDRT61jSDYT4G3xC+ZoHf43rhQ8gxbIXhveAZGrozIz29DN53BsrJpHUYLuzxYj64qZjzCZRw4PmPcXzH5/O9hP5jxSEC2nsCHtgg5iAYg4iUOa7b1dfffwucD70C/bNCBOHX4mtJBsj9N9zDifdW4foxb8VE/6zU6fUDXvYz43tYJ1lAff0Y8waHw1EtwaluovdBj66SY5wp4RGUcSQyM9ott95YSPoGR9AtCq5uHG85Z8+epfdX/df4JYofIaWuD/0lDZ2dnR04bE9WeSE5F8u9Hs6KsnwLZZZN62GyHuWG96+QK0Ms9Pb23i73WshIOhLX4+aJ4J9+F7ACBbGgGIkCBTGgGIkCBTGgGIkCBTGgGIkCBTGgGIkCBTHwf7/4DANKrnT+AAAAAElFTkSuQmCC"
            },
            getOffset: function (t, e) {
                var i = new s.default(["Left", "Top"]),
                    r = 0,
                    n = void 0;
                if (i.has(e))
                    for (r = t["offset" + e], n = t.offsetParent; null != n;) r += n["offset" + e], n = n.offsetParent;
                else console.error("getOffset param error");
                return r
            },
            isLight: function (t) {
                var e = this;
                return 4 !== t.length && console.warn("The default light had better have four"), t.forEach(function (t) {
                    try {
                        void 0 === t.position ? e.log("the position of light is undefined") : "number" == typeof t.position.x && "number" == typeof t.position.y && "number" == typeof t.position.z || e.log("The default light position xyz must be number"), void 0 === t.color && e.log("the color of light is undefined"), void 0 === t.opacity && e.log("the opacity of light is undefined")
                    } catch (t) {
                        if ("Error" === t.name) return !1;
                        e.log("default light error")
                    }
                }), !0
            },
            verdictFence: function (t, e) {
                var i = !1;
                if (void 0 == t || 0 == t.length) return -3;
                if (void 0 == e) return -2;
                e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1] || e.push(e[0]);
                for (var r = 0, n = e.length - 1; r < e.length; r++)(e[r][1] < t[1] && e[n][1] >= t[1] || e[n][1] < t[1] && e[r][1] >= t[1]) && (e[r][0] <= t[0] || e[n][0] <= t[0]) && (i ^= e[r][0] + (t[1] - e[r][1]) / (e[n][1] - e[r][1]) * (e[n][0] - e[r][0]) < t[0]), n = r;
                return i ? 1 : -1
            },
            nearestPoint: function (t, e) {
                var i = [],
                    r = void 0,
                    n = 0,
                    o = [];
                if (void 0 == e) return -2;
                e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1] || e.push(e[0]);
                for (var a = 0; a < e.length - 1; a++) i[a] = Math.sqrt(Math.pow(e[a][0] - t[0], 2) + Math.pow(e[a][1] - t[1], 2)), 0 == a && (r = i[a]), i[a] < r && (r = i[a], n = a);
                o[0] = [t[0] - e[n][0], t[1] - e[n][1]], o[1] = [e[n + 1][0] - e[n][0], e[n + 1][1] - e[n][1]], o[2] = 0 == n ? [e[e.length - 2][0] - e[n][0], e[e.length - 2][1] - e[n][1]] : [e[n - 1][0] - e[n][0], e[n - 1][1] - e[n][1]];
                var s = [e[n], this.getdistance(t, e[n])],
                    l = this.getFootPoint(t, e[n], e[n + 1]),
                    h = void 0;
                return h = 0 == n ? this.getFootPoint(t, e[n], e[e.length - 2]) : this.getFootPoint(t, e[n], e[n - 1]), this.getmin(this.getmin(s, l), h)
            },
            nearestPoints: function (t, e) {
                var i = [];
                if (void 0 == e) return -2;
                e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1] || e.push(e[0]);
                for (var r = 0; r < e.length - 1; r++) {
                    var n = this.getFootPoint(t, e[r], e[r + 1]);
                    i.push(n)
                }
                return i
            },
            getFootPoint: function (t, e, i) {
                var r = void 0,
                    n = void 0,
                    o = void 0;
                e[0] == i[0] ? (r = 1, n = 0, o = -e[0]) : e[1] == i[1] ? (r = 0, n = 1, o = -e[1]) : (r = 1 / (i[0] - e[0]), n = -1 / (i[1] - e[1]), o = e[1] / (i[1] - e[1]) - e[0] / (i[0] - e[0]));
                var a = Math.sqrt(r * r + n * n);
                r /= a, n /= a, o /= a;
                var s = [];
                s[0] = (n * n * t[0] - r * n * t[1] - r * o) / (r * r + n * n), s[1] = (-r * n * t[0] + r * r * t[1] - n * o) / (r * r + n * n);
                var l = [e[0], i[0]].sort(function (t, e) {
                        return t - e
                    }),
                    h = [e[1], i[1]].sort(function (t, e) {
                        return t - e
                    });
                return s[0] >= l[0] && s[0] <= l[1] && s[1] >= h[0] && s[1] <= h[1] ? s[2] = Math.abs(t[0] * r + t[1] * n + o) : (s[0] = e[0], s[1] = e[1], s[2] = Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))), [
                    [s[0], s[1]], s[2]
                ]
            },
            getdistance: function (t, e) {
                return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
            },
            getmin: function (t, e) {
                return t[1] < e[1] ? t : e
            },
            pointFindArea: function (t, e) {
                for (var i = 0; i < e.length; i++) {
                    if (this.verdictFence(t, e[i]) >= 0) return i
                }
                return !1
            },
            debounce: function (t, e, i) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                clearTimeout(t.tid), t.tid = setTimeout(function () {
                    return t.call(e, i)
                }, r)
            },
            throttle: function (t, e, i) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100,
                    n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e3;
                clearTimeout(t.timer), t._cur = Date.now(), t._start || (t._start = t._cur), t._cur - t._start > n ? (t.call(e, i), t._start = t._cur) : t.timer = setTimeout(function () {
                    t.call(e, i)
                }, r)
            },
            findNearPoints: function (t, e, i) {
                var r = [],
                    n = 0,
                    o = [];
                try {
                    e.children.forEach(function (o, a) {
                        if ((n = Math.sqrt((t[0] - o.children[0].position.x) * (t[0] - o.children[0].position.x) + (t[1] - o.children[0].position.z) * (t[1] - o.children[0].position.z)) / .85) <= i / .85) {
                            o.children[0].info.properties.distance = n;
                            for (var s = !1, l = 0; l < r.length; l++)
                                if (n < e.children[r[l]].children[0].info.properties.distance) {
                                    r.splice(l, 0, a), s = !0;
                                    break
                                } s || r.push(a)
                        }
                    });
                    for (var a = 0; a < r.length; a++) o.push(e.children[r[a]].children[0])
                } catch (t) {
                    console.warn("params is wrong.")
                }
                return o
            }
        };
    e.default = c
}, function (t, e, i) {
    var r = i(12),
        n = i(69),
        o = i(52),
        a = Object.defineProperty;
    e.f = i(8) ? Object.defineProperty : function (t, e, i) {
        if (r(t), e = o(e, !0), r(i), n) try {
            return a(t, e, i)
        } catch (t) {}
        if ("get" in i || "set" in i) throw TypeError("Accessors not supported!");
        return "value" in i && (t[e] = i.value), t
    }
}, function (t, e, i) {
    var r = i(6);
    t.exports = function (t) {
        if (!r(t)) throw TypeError(t + " is not an object!");
        return t
    }
}, function (t, e) {
    t.exports = function (t) {
        try {
            return !!t()
        } catch (t) {
            return !0
        }
    }
}, function (t, e) {
    var i = {}.hasOwnProperty;
    t.exports = function (t, e) {
        return i.call(t, e)
    }
}, function (t, e, i) {
    var r = i(11),
        n = i(35);
    t.exports = i(8) ? function (t, e, i) {
        return r.f(t, e, n(1, i))
    } : function (t, e, i) {
        return t[e] = i, t
    }
}, function (t, e, i) {
    var r = i(25);
    t.exports = function (t, e, i) {
        if (r(t), void 0 === e) return t;
        switch (i) {
            case 1:
                return function (i) {
                    return t.call(e, i)
                };
            case 2:
                return function (i, r) {
                    return t.call(e, i, r)
                };
            case 3:
                return function (i, r, n) {
                    return t.call(e, i, r, n)
                }
        }
        return function () {
            return t.apply(e, arguments)
        }
    }
}, function (t, e, i) {
    var r = i(45),
        n = i(33);
    t.exports = function (t) {
        return r(n(t))
    }
}, function (t, e, i) {
    i(106);
    for (var r = i(5), n = i(15), o = i(28), a = i(7)("toStringTag"), s = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), l = 0; l < s.length; l++) {
        var h = s[l],
            c = r[h],
            u = c && c.prototype;
        u && !u[a] && n(u, a, h), o[h] = o.Array
    }
}, function (t, e, i) {
    var r = i(16),
        n = i(109),
        o = i(110),
        a = i(12),
        s = i(46),
        l = i(74),
        h = {},
        c = {},
        e = t.exports = function (t, e, i, u, p) {
            var f, d, m, g, v = p ? function () {
                    return t
                } : l(t),
                y = r(i, u, e ? 2 : 1),
                A = 0;
            if ("function" != typeof v) throw TypeError(t + " is not iterable!");
            if (o(v)) {
                for (f = s(t.length); f > A; A++)
                    if ((g = e ? y(a(d = t[A])[0], d[1]) : y(t[A])) === h || g === c) return g
            } else
                for (m = v.call(t); !(d = m.next()).done;)
                    if ((g = n(m, y, d.value, e)) === h || g === c) return g
        };
    e.BREAK = h, e.RETURN = c
}, function (t, e, i) {
    var r = i(34)("meta"),
        n = i(6),
        o = i(14),
        a = i(11).f,
        s = 0,
        l = Object.isExtensible || function () {
            return !0
        },
        h = !i(13)(function () {
            return l(Object.preventExtensions({}))
        }),
        c = function (t) {
            a(t, r, {
                value: {
                    i: "O" + ++s,
                    w: {}
                }
            })
        },
        u = function (t, e) {
            if (!n(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
            if (!o(t, r)) {
                if (!l(t)) return "F";
                if (!e) return "E";
                c(t)
            }
            return t[r].i
        },
        p = function (t, e) {
            if (!o(t, r)) {
                if (!l(t)) return !0;
                if (!e) return !1;
                c(t)
            }
            return t[r].w
        },
        f = function (t) {
            return h && d.NEED && l(t) && !o(t, r) && c(t), t
        },
        d = t.exports = {
            KEY: r,
            NEED: !1,
            fastKey: u,
            getWeak: p,
            onFreeze: f
        }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        var e = t.slice(0);
        return e = e instanceof Array ? e : [], e[0] = 20037508.34 * (0, s.default)(e[0]) / 180, e[1] = Math.log(Math.tan((90 + (0, s.default)(e[1])) * Math.PI / 360)) / (Math.PI / 180), e[1] = 20037508.34 * -(0, s.default)(e[1]) / 180, e.includes(NaN) ? (console.error("The latitude and longitude format is not correct."), []) : (e[0] = e[0].toFixed(2), e[1] = e[1].toFixed(2), e)
    }

    function n(t) {
        var e = t.mercato,
            i = t.mapCenter,
            r = void 0 === i ? [0, 0] : i,
            n = [],
            o = void 0,
            a = void 0;
        return o = (e[0] + r[0]) / 20037508.34 * 180, a = (e[1] + r[1]) / 20037508.34 * 180, a = -180 / Math.PI * (2 * Math.atan(Math.exp(a * Math.PI / 180)) - Math.PI / 2), n.push(o.toFixed(10)), n.push(a.toFixed(10)), n
    }

    function o(t) {
        var e = t.coordinates,
            i = t.mapCenter,
            n = void 0 === i ? [0, 0] : i,
            o = [],
            a = void 0;
        return e instanceof Array && (e[0] instanceof Array ? e.forEach(function (t) {
            a = r(t);
            var e = [];
            e[0] = a[0] - n[0], e[1] = a[1] - n[1], o.push(e)
        }) : (a = r(e), o[0] = a[0] - n[0], o[1] = a[1] - n[1]), o)
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var a = i(84),
        s = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(a);
    e.coordinateToMercato = r, e.mercatoToCoordinates = n, e.coordinatesToMercato = o;
    var l = i(4);
    ! function (t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (null != t)
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        e.default = t
    }(l)
}, function (t, e, i) {
    var r = i(67),
        n = i(50);
    t.exports = Object.keys || function (t) {
        return r(t, n)
    }
}, function (t, e) {
    var i = {}.toString;
    t.exports = function (t) {
        return i.call(t).slice(8, -1)
    }
}, function (t, e) {
    t.exports = !0
}, function (t, e) {
    t.exports = function (t) {
        if ("function" != typeof t) throw TypeError(t + " is not a function!");
        return t
    }
}, function (t, e) {}, function (t, e, i) {
    "use strict";
    var r = i(103)(!0);
    i(53)(String, "String", function (t) {
        this._t = String(t), this._i = 0
    }, function () {
        var t, e = this._t,
            i = this._i;
        return i >= e.length ? {
            value: void 0,
            done: !0
        } : (t = r(e, i), this._i += t.length, {
            value: t,
            done: !1
        })
    })
}, function (t, e) {
    t.exports = {}
}, function (t, e, i) {
    var r = i(11).f,
        n = i(14),
        o = i(7)("toStringTag");
    t.exports = function (t, e, i) {
        t && !n(t = i ? t : t.prototype, o) && r(t, o, {
            configurable: !0,
            value: e
        })
    }
}, function (t, e, i) {
    var r = i(6);
    t.exports = function (t, e) {
        if (!r(t) || t._t !== e) throw TypeError("Incompatible receiver, " + e + " required!");
        return t
    }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function n() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : h;
        void 0 !== t.defaultFloor && (e.mapConfig.defaultFloor = t.defaultFloor || e.mapConfig.defaultFloor), void 0 !== t.count && (e.mapConfig.count = t.count || e.mapConfig.count), void 0 !== t.defaultGap && (e.mapConfig.defaultGap = 1 * t.defaultGap || e.mapConfig.defaultGap), void 0 !== t.opacity && (e.mapConfig.opacity = 1 * t.opacity || e.mapConfig.opacity, 0 !== t.opacity && -0 !== t.opacity || (e.mapConfig.opacity = 0)), void 0 !== t.zoom && (e.mapConfig.zoom = 1 * t.zoom || e.mapConfig.zoom), void 0 !== t.showAllFloor && (!1 === t.showAllFloor ? e.mapConfig.showAllFloor = !1 : !0 === t.showAllFloor && (e.mapConfig.showAllFloor = !0)), void 0 !== t.showViewMode && (e.mapConfig.showViewMode = t.showViewMode || e.mapConfig.showViewMode), void 0 !== t.bgColor && (e.mapConfig.bgColor = t.bgColor || e.mapConfig.bgColor), void 0 !== t.theta && (e.mapConfig.theta = t.theta || e.mapConfig.theta, 0 !== t.theta && -0 !== t.theta || (e.mapConfig.theta = 0)), void 0 !== t.theta3D && (e.mapConfig.theta3D = t.theta3D || e.mapConfig.theta3D, 0 !== t.theta3D && -0 !== t.theta3D || (e.mapConfig.theta3D = 0)), void 0 !== t.defaultLight && (e.mapConfig.defaultLight = t.defaultLight || e.mapConfig.defaultLight), void 0 !== t.defaultClickModels && 0 < t.defaultClickModels.length && t.defaultClickModels instanceof Array && (e.mapConfig.defaultClickModels = t.defaultClickModels), void 0 !== t.defaultAutoModels && 0 < t.defaultAutoModels.length && t.defaultAutoModels instanceof Array && (e.mapConfig.defaultAutoModels = t.defaultAutoModels), void 0 !== t.defaultDetectModels && 0 < t.defaultDetectModels.length && t.defaultDetectModels instanceof Array && (e.mapConfig.defaultDetectModels = t.defaultDetectModels), void 0 !== t.logoWidth && (e.mapConfig.logoWidth = t.logoWidth || e.mapConfig.logoWidth), void 0 !== t.logoHeight && (e.mapConfig.logoHeight = t.logoHeight || e.mapConfig.logoHeight), void 0 !== t.defaultPriority && (e.mapConfig.defaultPriority = t.defaultPriority || e.mapConfig.defaultPriority), e.userConfig = JSON.parse((0, s.default)(e.mapConfig))
    }

    function o(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : h;
        return e.mapConfig.hasOwnProperty(t) ? e.mapConfig[t] : null
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.config = void 0;
    var a = i(9),
        s = r(a);
    e.set = n, e.get = o;
    var l = i(10),
        h = (r(l), e.config = {});
    h.mapConfig = {
        showViewMode: "MODE_2D",
        count: 10,
        showAllFloor: !1,
        defaultFloor: "F1",
        defaultGap: 30,
        opacity: 1,
        zoom: 2.5,
        logoWidth: 150,
        logoHeight: 50,
        bgColor: "#F1F2F7",
        theta: 20,
        theta3D: 20,
        mesbase: "98GHIJKLMNOPQRSTUVWXYZ76543210zyxwvutsrqponmlkjihgfedcbaABCDEF",
        defaultLight: {
            ambient: {
                color: "#ffffff",
                opacity: .4
            },
            verDir: {
                position: {
                    x: 0,
                    y: 50,
                    z: 0
                },
                color: "#ffffff",
                opacity: .5
            },
            horDir: {
                position: {
                    x: -30,
                    y: 0,
                    z: -40
                },
                color: "#ffffff",
                opacity: .4
            },
            HorDirPos: {
                position: {
                    x: 30,
                    y: 0,
                    z: 40
                },
                color: "#ffffff",
                opacity: .5
            },
            hemisphere: {
                position: {
                    x: 0,
                    y: 500,
                    z: 0
                },
                skyColor: "#ffffff",
                groundColor: "#ffffff",
                opacity: .15
            }
        },
        defaultClickModels: ["roomGroup", "bottomGroup", "otherGroup", "deskGroup", "seatGroup", "logoGroup", "nameGroup"],
        defaultPlaneModels: ["bottomGroup"],
        defaultAutoModels: ["otherGroup", "logoGroup", "nameGroup"],
        defaultDetectModels: ["logoGroup", "nameGroup"],
        defaultPriority: ["theme", "other", "map"]
    }
}, function (t, e, i) {
    var r = i(33);
    t.exports = function (t) {
        return Object(r(t))
    }
}, function (t, e) {
    t.exports = function (t) {
        if (void 0 == t) throw TypeError("Can't call method on  " + t);
        return t
    }
}, function (t, e) {
    var i = 0,
        r = Math.random();
    t.exports = function (t) {
        return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++i + r).toString(36))
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: e
        }
    }
}, function (t, e, i) {
    var r = i(12),
        n = i(70),
        o = i(50),
        a = i(48)("IE_PROTO"),
        s = function () {},
        l = function () {
            var t, e = i(51)("iframe"),
                r = o.length;
            for (e.style.display = "none", i(71).appendChild(e), e.src = "javascript:", t = e.contentWindow.document, t.open(), t.write("<script>document.F=Object<\/script>"), t.close(), l = t.F; r--;) delete l.prototype[o[r]];
            return l()
        };
    t.exports = Object.create || function (t, e) {
        var i;
        return null !== t ? (s.prototype = r(t), i = new s, s.prototype = null, i[a] = t) : i = l(), void 0 === e ? i : n(i, e)
    }
}, function (t, e, i) {
    var r = i(15);
    t.exports = function (t, e, i) {
        for (var n in e) i && t[n] ? t[n] = e[n] : r(t, n, e[n]);
        return t
    }
}, function (t, e) {
    t.exports = function (t, e, i, r) {
        if (!(t instanceof e) || void 0 !== r && r in t) throw TypeError(i + ": incorrect invocation!");
        return t
    }
}, function (t, e, i) {
    t.exports = {
        default: i(121),
        __esModule: !0
    }
}, function (t, e) {
    e.f = {}.propertyIsEnumerable
}, function (t, e, i) {
    t.exports = {
        default: i(149),
        __esModule: !0
    }
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(4),
        n = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(r),
        o = i(170),
        a = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(o),
        s = {
            drawOneFloor: function (t) {
                var e = this;
                this.config = t.config;
                var i = new n.Group,
                    r = new n.Group,
                    o = new n.Group,
                    a = new n.Group,
                    s = new n.Group,
                    l = new n.Group,
                    h = new n.Group,
                    c = new n.Group,
                    u = new n.Group,
                    p = new n.Group,
                    f = void 0,
                    d = new n.Mesh,
                    m = new n.ImageLoader,
                    g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAMAAABFaP0WAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRF////AAAAVcLTfgAAAA5JREFUeNpiYAABgAADAAAGAAHgQhFOAAAAAElFTkSuQmCC";
                return this.imageTexture = m.load(g), t.geoJson.forEach(function (d, v) {
                    switch (d.drawType.type) {
                        case "room":
                            f = e.drawRoom(d), i.add(f);
                            var y = new n.Mesh;
                            if (d.properties.name)
                                if (d.wallHeight = t.wallHeight, d.properties.logo) {
                                    h.add(y);
                                    var A = new n.ImageLoader;
                                    A.load(d.properties.logo, function (t) {
                                        (f = e.drawName(d, t)) && (y.name = f.name, y.info = f.info, y.add(f))
                                    })
                                } else h.add(y), m.load(g, function (t) {
                                    var i = e.drawName(d);
                                    y.add(i)
                                });
                            f = e.drawLine(d), c.add(f);
                            break;
                        case "seat":
                            f = e.drawRoom(d), o.add(f), f = e.drawLine(d), c.add(f);
                            break;
                        case "desk":
                            f = e.drawRoom(d), a.add(f), f = e.drawLine(d), c.add(f);
                            break;
                        case "wall":
                            f = e.drawRoom(d), f.renderOrder = 1, r.add(f), f = e.drawLine(d), c.add(f);
                            break;
                        case "plane":
                            f = e.drawRoom(d), s.add(f);
                            break;
                        case "point":
                            var x = new n.Mesh;
                            if (d.properties.name)
                                if (d.wallHeight = t.wallHeight, d.properties.logo) {
                                    h.add(x);
                                    var _ = new n.ImageLoader;
                                    _.load(d.properties.logo, function (t) {
                                        (f = e.drawName(d, t)) && (x.name = f.name, x.info = f.info, x.add(f))
                                    })
                                } else h.add(x), m.load(g, function (t) {
                                    var i = e.drawName(d);
                                    x.add(i)
                                });
                            else if (d.properties.logo) {
                                d.wallHeight = t.wallHeight, f = e.drawLogo(d);
                                var w = new n.Mesh;
                                w.name = f.name, w.info = f.info, w.add(f), l.add(w)
                            }
                            break;
                        case "floor":
                            f = e.drawRoom(d), u.add(f);
                            break;
                        case "other":
                            if (d.properties.logo) {
                                f = e.drawLogo(d, "other"), f.info.layer = "otherGroup";
                                var b = new n.Mesh;
                                b.name = f.name, b.info = f.info, b.add(f), p.add(b)
                            }
                    }
                }), i.name = "roomGroup", h.name = "nameGroup", r.name = "wallGroup", o.name = "seatGroup", a.name = "deskGroup", l.name = "logoGroup", c.name = "lineGroup", s.name = "planeGroup", u.name = "bottomGroup", p.name = "otherGroup", d.add(i), d.add(h), d.add(r), d.add(o), d.add(a), d.add(l), d.add(c), d.add(s), d.add(u), d.add(p), d.name = t.name, d
            },
            drawRoom: function (t) {
                var e = void 0,
                    i = new n.Shape,
                    r = t.properties.gap ? t.properties.gap : 1,
                    o = void 0,
                    a = void 0,
                    s = void 0,
                    l = void 0;
                console.warn(t.id), o = r * (t.line[0][0] - t.center[0]) + t.center[0], a = r * (t.line[0][1] - t.center[1]) + t.center[1], i.moveTo(o, -a);
                for (var h = 1; h < t.line.length; h++) o = r * (t.line[h][0] - t.center[0]) + t.center[0], a = r * (t.line[h][1] - t.center[1]) + t.center[1], i.lineTo(o, -a);
                return s = {
                    amount: t.properties.height,
                    bevelEnabled: !1
                }, l = new n.ExtrudeGeometry(i, s), e = new n.Mesh(l, new n.MeshLambertMaterial({
                    color: t.properties.fillcolor,
                    side: n.FrontSide,
                    transparent: !0,
                    opacity: t.properties.opacity || 1
                })), e.rotation.x = -Math.PI / 2, t.properties.eheight && t.properties.Startingheight ? e.position.setY(t.y + Number(t.properties.eheight) + Number(t.properties.Startingheight)) : t.properties.eheight ? e.position.setY(t.y + Number(t.properties.eheight)) : t.properties.Startingheight ? e.position.setY(t.y + Number(t.properties.Startingheight)) : e.position.setY(t.y), e.info = t, e.name = t.properties.name, e
            },
            drawLogo: function (t) {
                var e = t.properties.logo,
                    i = (new n.TextureLoader).load(e),
                    r = new n.SpriteMaterial({
                        map: i,
                        color: 16777215,
                        transparent: !1
                    }),
                    o = new n.Sprite(r);
                return o.scale.set(t.zoom, t.zoom, t.zoom), t.position && t.properties.Startingheight ? o.position.set(t.center[0], t.wallHeight / 2 + Number(t.properties.Startingheight) + t.y + t.zoom / 2, t.center[1]) : t.wallHeight ? o.position.set(t.center[0], t.wallHeight / 2 + t.y + t.zoom / 2, t.center[1]) : t.properties.Startingheight ? o.position.set(t.center[0], Number(t.properties.Startingheight) + t.y + t.properties.height + t.zoom / 2, t.center[1]) : o.position.set(t.center[0], t.y + t.properties.height + t.zoom / 2, t.center[1]), t.isDetectModel = !0, "other" == (arguments.length <= 1 ? void 0 : arguments[1]) && (t.position && t.properties.Startingheight ? o.position.set(t.position[0], Number(t.properties.Startingheight) + t.y + t.position[1] + t.zoom / 2, t.position[2]) : t.position ? o.position.set(t.position[0], t.y + t.position[1] + t.zoom / 2, t.position[2]) : t.properties.Startingheight ? o.position.set(t.center[0], Number(t.properties.Startingheight) + t.y + t.properties.height + t.zoom / 2, t.center[1]) : o.position.set(t.center[0], t.y + t.properties.height + t.zoom / 2, t.center[1]), o.scale.set(t.size, t.size, t.size), t.isDetectModel = !1), o.name = t.properties.name, o.info = t, o.info.properties.name = "", o.info.haveImg = 0, o.info.nameWidth = 1, o.info.isAutoModel = !0, o
            },
            drawName: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                if (1e3 === t.sType) return null;
                if (!t.properties.name) return null;
                var i = e ? 1 : 0,
                    r = t.properties.name,
                    o = document.createElement("canvas"),
                    a = o.getContext("2d");
                a.font = "40px Calibri";
                var s = a.measureText(r);
                o.style.width = s.width + 44 * i + "px", o.style.height = "40px", o.width = s.width + 44 * i, o.height = 40, a.lineWidth = 4, a.textAlign = "left", a.textBaseline = "middle", a.fillStyle = "#000";
                var l = this,
                    h = void 0;
                a.font = "40px Calibri";
                var c = a.createPattern(l.imageTexture, "repeat");
                a.strokeStyle = c, a.strokeText(r, 44 * i, o.height / 2), a.fillText(r, 44 * i, o.height / 2), e && a.drawImage(e, 0, 0, 40, 40);
                var u = new n.CanvasTexture(o),
                    p = new n.SpriteMaterial({
                        map: u,
                        transparent: !0,
                        opacity: 1
                    });
                return h = new n.Sprite(p), h.scale.set((s.width / 40 + i + 4 * i / 40) * t.zoom, 1 * t.zoom, 2 * t.zoom), h.info = t, t.wallHeight && t.properties.Startingheight ? h.position.set(t.center[0], Number(t.properties.Startingheight) + 1 * t.wallHeight + t.y + t.zoom / 2, t.center[1]) : t.wallHeight ? h.position.set(t.center[0], 1 * t.wallHeight + t.y + t.zoom / 2, t.center[1]) : t.properties.Startingheight ? h.position.set(t.center[0], Number(t.properties.Startingheight) + t.properties.height + t.y + t.zoom / 2, t.center[1]) : h.position.set(t.center[0], t.properties.height + t.y + t.zoom / 2, t.center[1]), h.name = t.properties.name, h.info.nameWidth = s.width / 40 + 4 * i / 40, h.info.haveImg = i, h.info.layer = "nameGroup", h.info.isDetectModel = !0, h.info.isAutoModel = !0, h
            },
            drawLine: function (t) {
                for (var e = new n.LineBasicMaterial({
                        color: t.properties.strokecolor
                    }), i = t.properties.gap ? t.properties.gap : 1, r = new n.Geometry, o = void 0, a = void 0, s = 0; s < t.line.length; s++) o = i * (t.line[s][0] - t.center[0]) + t.center[0], a = i * (t.line[s][1] - t.center[1]) + t.center[1], t.properties.eheight && t.properties.Startingheight ? r.vertices.push(new n.Vector3(o, t.properties.height + t.y + parseFloat(t.properties.eheight) + parseFloat(t.properties.Startingheight), a)) : t.properties.eheight ? r.vertices.push(new n.Vector3(o, t.properties.height + t.y + parseFloat(t.properties.eheight), a)) : t.properties.Startingheight ? r.vertices.push(new n.Vector3(o, t.properties.height + t.y + parseFloat(t.properties.Startingheight), a)) : r.vertices.push(new n.Vector3(o, t.properties.height + t.y, a));
                var l = new n.Line(r, e);
                return l.name = t.properties.name, l.info = t, l
            },
            drawPlane: function (t) {
                var e = void 0,
                    i = new n.Shape,
                    r = t.properties.gap ? t.properties.gap : 1,
                    o = r * (t.line[0][0] - t.center[0]) + t.center[0],
                    a = r * (t.line[0][1] - t.center[1]) + t.center[1];
                i.moveTo(o, -a);
                for (var s = 1; s < t.line.length; s++) o = r * (t.line[s][0] - t.center[0]) + t.center[0], a = r * (t.line[s][1] - t.center[1]) + t.center[1], i.lineTo(o, -a);
                var l = new n.ShapeGeometry(i);
                return e = new n.Mesh(l, new n.MeshBasicMaterial({
                    color: t.properties.fillcolor,
                    side: n.DoubleSide
                })), e.rotation.x = -Math.PI / 2, e.position.setY(t.y + t.properties.height), e.name = t.properties.name, e.info = t, e
            },
            drawFence: function (t, e) {
                var i = new n.Mesh,
                    r = new n.Shape,
                    o = new n.Geometry;
                r.moveTo(t[0][0], -t[0][1]), o.vertices.push(new n.Vector3(t[0][0], -t[0][1], 0));
                for (var a = 1; a < t.length; a++) r.lineTo(t[a][0], -t[a][1]), o.vertices.push(new n.Vector3(t[a][0], -t[a][1], 0));
                var s = {
                        amount: 0,
                        bevelEnabled: !1
                    },
                    l = new n.ExtrudeGeometry(r, s),
                    h = new n.Mesh(l, e[0]),
                    c = new n.Line(o, e[1]);
                i.add(h), i.add(c), i.rotation.x = -Math.PI / 2;
                var u = {
                    id: i.id,
                    drawType: {
                        func: "drawFence",
                        type: "fence"
                    },
                    color: e[0].color,
                    splicing: i.id,
                    opacity: e[0].opacity
                };
                return h.info = u, c.info = u, i.info = u, i
            },
            dynDrawFence: function (t, e) {
                var i = new n.Mesh,
                    r = new n.Shape;
                r.moveTo(t[0][0], -t[0][1]);
                for (var o = 1; o < t.length; o++) r.lineTo(t[o][0], -t[o][1]);
                var a = {
                        amount: 0,
                        bevelEnabled: !1
                    },
                    s = new n.ExtrudeGeometry(r, a),
                    l = new n.Mesh(s, e[0]);
                i.add(l), i.rotation.x = -Math.PI / 2;
                var h = {
                    id: i.id,
                    drawType: {
                        func: "drawFence",
                        type: "fence"
                    },
                    splicing: i.id,
                    opacity: e[0].opacity
                };
                return l.info = h, i.info = h, i
            },
            addWordsFence: function (t, e, i, r, o, a, s) {
                var l = new n.Shape,
                    h = new n.Mesh,
                    c = new n.Geometry;
                c.vertices.push(new n.Vector3(t[0][0], 0, t[0][1])), l.moveTo(t[0][0], -t[0][1]);
                for (var u = 1; u < t.length; u++) l.lineTo(t[u][0], -t[u][1]), c.vertices.push(new n.Vector3(t[u][0], 0, t[u][1]));
                var p = {
                        amount: 0,
                        bevelEnabled: !1
                    },
                    f = new n.ExtrudeGeometry(l, p),
                    d = new n.Mesh(f, i[0]);
                d.rotation.x = -Math.PI / 2, h.add(d);
                var m = void 0;
                e ? (m = new n.Line(c, i[2]), m.computeLineDistances()) : m = new n.Line(c, i[1]), h.add(m);
                var g = void 0,
                    v = void 0;
                if (a[0]) {
                    g = this.imgMap(a), g.position.setY(s), h.add(g);
                    var y = {
                        id: h.id,
                        drawType: {
                            func: "drawFence",
                            type: "fence"
                        },
                        splicing: h.id
                    };
                    g.info = y
                }
                if (o[0]) {
                    v = this.wordsMap(o), v.position.setY(s), h.add(v);
                    var A = {
                        id: h.id,
                        drawType: {
                            func: "drawFence",
                            type: "fence"
                        },
                        splicing: h.id
                    };
                    v.info = A
                }
                h.position.setY(r);
                var x = {
                    id: h.id,
                    drawType: {
                        func: "drawFence",
                        type: "fence"
                    },
                    splicing: h.id,
                    opacity: i[0].opacity
                };
                return d.info = x, m.info = x, h.info = x, h
            },
            wordsMap: function (t) {
                var e = document.createElement("canvas");
                e.width = t[0].length * t[1], e.height = t[1] + 10;
                var i = e.getContext("2d");
                i.font = t[1] + "px ", i.textAlign = "left", i.textBaseline = "middle", i.fillStyle = "#5F5D5D", i.fillText(t[0], 0, e.height / 2);
                var r = e.toDataURL(),
                    o = (new n.TextureLoader).load(r),
                    a = new n.PlaneGeometry(e.width / 10, e.height / 10, 2, 1),
                    s = new n.MeshBasicMaterial({
                        map: o,
                        color: 0,
                        side: n.DoubleSide,
                        transparent: !0
                    }),
                    l = new n.Mesh(a, s);
                return l.position.set(t[2][0], 0, t[2][1]), l.rotation.x = -Math.PI / 2, l
            },
            imgMap: function (t) {
                var e = (new n.TextureLoader).load(t[0]),
                    i = new n.PlaneGeometry(t[1], t[2], 2, 1),
                    r = new n.MeshBasicMaterial({
                        map: e,
                        transparent: !0
                    }),
                    o = new n.Mesh(i, r);
                return o.position.set(t[3][0], 0, t[3][1]), o.rotation.x = -Math.PI / 2, o
            },
            drawDirectionLine: function (t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = new n.Mesh,
                    o = {
                        id: r.id,
                        drawType: {
                            func: "drawDirectionLine",
                            type: "line"
                        },
                        splicing: r.id
                    },
                    a = new n.Geometry,
                    s = new n.Shape;
                s.moveTo(0, 0), s.lineTo(.2, .7), s.lineTo(-.2, .7), s.lineTo(0, 0);
                var l = {
                        amount: 0,
                        bevelEnabled: !1
                    },
                    h = 0;
                a.vertices.push(new n.Vector3(t[0][0], 0, t[0][1]));
                for (var c = void 0, u = 1; u < t.length; u++) {
                    a.vertices.push(new n.Vector3(t[u][0], 0, t[u][1]));
                    var p = new n.ExtrudeGeometry(s, l);
                    c = new n.Mesh(p, e[1]), h = Math.atan2(t[u][0] - t[u - 1][0], t[u][1] - t[u - 1][1]), c.rotation.x = -Math.PI / 2, c.rotation.z = h, c.position.set(t[u][0], 0, t[u][1]), c.scale.set(5, 5, 5), c.info = o, r.add(c)
                }
                var f = void 0;
                return i ? (f = new n.Line(a, e[2]), f.computeLineDistances()) : f = new n.Line(a, e[1]), r.add(f), f.info = o, r.info = o, r
            },
            dynDrawDirectionLine: function (t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = new n.Mesh,
                    o = {
                        id: r.id,
                        drawType: {
                            func: "dynDrawDirectionLine",
                            type: "line"
                        },
                        splicing: r.id
                    },
                    a = new n.Geometry,
                    s = new n.Shape;
                s.moveTo(0, 0), s.lineTo(.2, .7), s.lineTo(-.2, .7), s.lineTo(0, 0);
                a.vertices.push(new n.Vector3(t[0][0], 0, t[0][1]));
                for (var l = 1; l < t.length; l++) a.vertices.push(new n.Vector3(t[l][0], 0, t[l][1]));
                var h = void 0;
                return i ? (h = new n.Line(a, e[2]), h.computeLineDistances()) : h = new n.Line(a, e[1]), r.add(h), h.info = o, r.info = o, {
                    mesh: r,
                    geometry: a
                }
            },
            addPath: function (t, e, i, r, o, a) {
                for (var s = [], l = 0; l < t.length; l++) 3 == t[l].length ? s.push(new n.Vector3(t[l][0], t[l][1], t[l][2])) : s.push(new n.Vector3(t[l][0], e, t[l][1]));
                var h = void 0;
                h = a ? new n.CatmullRomCurve3(s, !1) : new n.CatmullRomCurve3(s, !1, "catmullrom", .01);
                var c = parseInt(h.getLength()),
                    u = new n.TubeGeometry(h, parseInt(2 * c), i, 32, !1),
                    p = (new n.TextureLoader).load(o);
                p.wrapS = p.wrapT = n.RepeatWrapping, p.repeat.set(0 == parseInt(c / r) ? 1 : parseInt(c / r), 1);
                var f = new n.MeshBasicMaterial({
                        map: p,
                        side: n.DoubleSide,
                        transparent: !0
                    }),
                    d = new n.Mesh(u, f),
                    m = {
                        id: d.id,
                        drawType: {
                            func: "path",
                            type: "Path"
                        },
                        points: t,
                        splicing: d.id,
                        radius: i,
                        length: c,
                        sinLength: r
                    };
                return d.info = m, d
            },
            addMeshLine: function (t, e, i, r, o) {
                var s = new n.Mesh,
                    l = {
                        id: s.id,
                        drawType: {
                            func: "addMeshLine",
                            type: "meshLine"
                        },
                        splicing: s.id,
                        lineWidth: i
                    },
                    h = new n.Shape;
                h.moveTo(0, 3 * i), h.lineTo(-2 * i, 3 * i), h.lineTo(0, -3 * i), h.lineTo(2 * i, 3 * i), h.lineTo(0, 3 * i);
                var c = {
                        amount: 0,
                        bevelEnabled: !1
                    },
                    u = 0,
                    p = new n.Geometry;
                p.vertices.push(new n.Vector3(t[0][0], 0, t[0][1]));
                for (var f = void 0, d = 1; d < t.length; d++)
                    if (p.vertices.push(new n.Vector3(t[d][0], 0, t[d][1])), o) {
                        var m = new n.ExtrudeGeometry(h, c);
                        f = new n.Mesh(m, new n.MeshLambertMaterial({
                            color: e
                        })), u = Math.atan2(t[d][0] - t[d - 1][0], t[d][1] - t[d - 1][1]), f.rotation.x = -Math.PI / 2, f.rotation.z = u, f.position.set(t[d][0], 0, t[d][1]), f.info = l
                    } var g = new a.default.MeshLine;
                g.setGeometry(p);
                var v = new a.default.MeshLineMaterial({
                        color: new n.Color(e),
                        sizeAttenuation: !0,
                        lineWidth: i
                    }),
                    y = new n.Mesh(g.geometry, v);
                return s.add(y), s.position.setY(r), y.info = l, s.info = l, s
            },
            drawMonitor: function (t) {
                var e = new n.Mesh;
                if (surround) {
                    var i = arc / 1,
                        r = new n.CircleGeometry(focalLength / 3, i, 0, arc * Math.PI * 2 / 360),
                        o = new n.MeshBasicMaterial({
                            color: "#ff0000",
                            side: n.DoubleSide,
                            transparent: !0,
                            opacity: opacity
                        }),
                        a = new n.Mesh(r, o),
                        s = this.drawRing(focalLength / 3, 2 * focalLength / 3, arc, 1, "#008000", opacity),
                        l = this.drawRing(2 * focalLength / 3, focalLength, arc, 1, "#ffffff", opacity),
                        h = this.drawEdge(focalLength, arc, 1);
                    e.add(a), e.add(s), e.add(l), e.add(h), e.rotation.z = direction * Math.PI * 2 / 360, e.rotation.x = Math.PI / 2
                }
                if (t.imgUrl) {
                    var c = void 0;
                    c = t.imgUrl;
                    var u = (new n.TextureLoader).load(c),
                        p = new n.SpriteMaterial({
                            map: u,
                            color: 16777215,
                            transparent: !1
                        }),
                        f = focalLength / 25;
                    f > 10 && (f = 10), f < 2 && (f = 2);
                    var d = new n.Sprite(p);
                    d.scale.set(f, f, f), d.position.setZ(f / 2), e.add(d)
                }
                return e.position.set(position[0], position[1], position[2]), e.name = "monitor", e
            },
            drawRing: function (t, e, i, r, o) {
                var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .2,
                    s = r,
                    l = Math.floor(i / s),
                    h = new n.Shape;
                360 !== i && h.moveTo(t, 0);
                for (var c = 0; c < l; c++) h.lineTo(e * Math.cos(s * c * Math.PI * 2 / 360), e * Math.sin(s * c * Math.PI * 2 / 360));
                h.lineTo(e * Math.cos(i * Math.PI * 2 / 360), e * Math.sin(i * Math.PI * 2 / 360));
                for (var c = 0; c < l; c++) h.lineTo(t * Math.cos((i - s * c) * Math.PI * 2 / 360), t * Math.sin((i - s * c) * Math.PI * 2 / 360));
                360 !== src && h.lineTo(t, 0);
                var u = new n.MeshBasicMaterial({
                        color: o,
                        side: n.DoubleSide,
                        transparent: !0,
                        opacity: a
                    }),
                    p = new n.ShapeGeometry(h);
                return new n.Mesh(p, u)
            }
        };
    e.default = s
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return new o.default(function (e, i) {
            var r = new XMLHttpRequest;
            if (r.timeout = 3e3, !r) throw new Error("XMLHttpRequest failed");
            r.onreadystatechange = function () {
                if (r.readyState === XMLHttpRequest.DONE)
                    if (200 === r.status) {
                        var t = r.responseText;
                        e(t)
                    } else i(r.status)
            }, r.open("GET", t, !0), r.send()
        })
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(88),
        o = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(n);
    i(31);
    e.default = {
        get: r
    }
}, function (t, e, i) {
    t.exports = {
        default: i(97),
        __esModule: !0
    }
}, function (t, e, i) {
    var r = i(23);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
        return "String" == r(t) ? t.split("") : Object(t)
    }
}, function (t, e, i) {
    var r = i(47),
        n = Math.min;
    t.exports = function (t) {
        return t > 0 ? n(r(t), 9007199254740991) : 0
    }
}, function (t, e) {
    var i = Math.ceil,
        r = Math.floor;
    t.exports = function (t) {
        return isNaN(t = +t) ? 0 : (t > 0 ? r : i)(t)
    }
}, function (t, e, i) {
    var r = i(49)("keys"),
        n = i(34);
    t.exports = function (t) {
        return r[t] || (r[t] = n(t))
    }
}, function (t, e, i) {
    var r = i(0),
        n = i(5),
        o = n["__core-js_shared__"] || (n["__core-js_shared__"] = {});
    (t.exports = function (t, e) {
        return o[t] || (o[t] = void 0 !== e ? e : {})
    })("versions", []).push({
        version: r.version,
        mode: i(24) ? "pure" : "global",
        copyright: " 2018 Denis Pushkarev (zloirock.ru)"
    })
}, function (t, e) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function (t, e, i) {
    var r = i(6),
        n = i(5).document,
        o = r(n) && r(n.createElement);
    t.exports = function (t) {
        return o ? n.createElement(t) : {}
    }
}, function (t, e, i) {
    var r = i(6);
    t.exports = function (t, e) {
        if (!r(t)) return t;
        var i, n;
        if (e && "function" == typeof (i = t.toString) && !r(n = i.call(t))) return n;
        if ("function" == typeof (i = t.valueOf) && !r(n = i.call(t))) return n;
        if (!e && "function" == typeof (i = t.toString) && !r(n = i.call(t))) return n;
        throw TypeError("Can't convert object to primitive value")
    }
}, function (t, e, i) {
    "use strict";
    var r = i(24),
        n = i(1),
        o = i(54),
        a = i(15),
        s = i(28),
        l = i(104),
        h = i(29),
        c = i(105),
        u = i(7)("iterator"),
        p = !([].keys && "next" in [].keys()),
        f = function () {
            return this
        };
    t.exports = function (t, e, i, d, m, g, v) {
        l(i, e, d);
        var y, A, x, _ = function (t) {
                if (!p && t in T) return T[t];
                switch (t) {
                    case "keys":
                    case "values":
                        return function () {
                            return new i(this, t)
                        }
                }
                return function () {
                    return new i(this, t)
                }
            },
            w = e + " Iterator",
            b = "values" == m,
            M = !1,
            T = t.prototype,
            S = T[u] || T["@@iterator"] || m && T[m],
            E = S || _(m),
            C = m ? b ? _("entries") : E : void 0,
            P = "Array" == e ? T.entries || S : S;
        if (P && (x = c(P.call(new t))) !== Object.prototype && x.next && (h(x, w, !0), r || "function" == typeof x[u] || a(x, u, f)), b && S && "values" !== S.name && (M = !0, E = function () {
                return S.call(this)
            }), r && !v || !p && !M && T[u] || a(T, u, E), s[e] = E, s[w] = f, m)
            if (y = {
                    values: b ? E : _("values"),
                    keys: g ? E : _("keys"),
                    entries: C
                }, v)
                for (A in y) A in T || o(T, A, y[A]);
            else n(n.P + n.F * (p || M), e, y);
        return y
    }
}, function (t, e, i) {
    t.exports = i(15)
}, function (t, e, i) {
    var r = i(23),
        n = i(7)("toStringTag"),
        o = "Arguments" == r(function () {
            return arguments
        }()),
        a = function (t, e) {
            try {
                return t[e]
            } catch (t) {}
        };
    t.exports = function (t) {
        var e, i, s;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = a(e = Object(t), n)) ? i : o ? r(e) : "Object" == (s = r(e)) && "function" == typeof e.callee ? "Arguments" : s
    }
}, function (t, e, i) {
    "use strict";
    var r = i(5),
        n = i(1),
        o = i(20),
        a = i(13),
        s = i(15),
        l = i(37),
        h = i(19),
        c = i(38),
        u = i(6),
        p = i(29),
        f = i(11).f,
        d = i(57)(0),
        m = i(8);
    t.exports = function (t, e, i, g, v, y) {
        var A = r[t],
            x = A,
            _ = v ? "set" : "add",
            w = x && x.prototype,
            b = {};
        return m && "function" == typeof x && (y || w.forEach && !a(function () {
            (new x).entries().next()
        })) ? (x = e(function (e, i) {
            c(e, x, t, "_c"), e._c = new A, void 0 != i && h(i, v, e[_], e)
        }), d("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function (t) {
            var e = "add" == t || "set" == t;
            t in w && (!y || "clear" != t) && s(x.prototype, t, function (i, r) {
                if (c(this, x, t), !e && y && !u(i)) return "get" == t && void 0;
                var n = this._c[t](0 === i ? 0 : i, r);
                return e ? this : n
            })
        }), y || f(x.prototype, "size", {
            get: function () {
                return this._c.size
            }
        })) : (x = g.getConstructor(e, t, v, _), l(x.prototype, i), o.NEED = !0), p(x, t), b[t] = x, n(n.G + n.W + n.F, b), y || g.setStrong(x, t, v), x
    }
}, function (t, e, i) {
    var r = i(16),
        n = i(45),
        o = i(32),
        a = i(46),
        s = i(111);
    t.exports = function (t, e) {
        var i = 1 == t,
            l = 2 == t,
            h = 3 == t,
            c = 4 == t,
            u = 6 == t,
            p = 5 == t || u,
            f = e || s;
        return function (e, s, d) {
            for (var m, g, v = o(e), y = n(v), A = r(s, d, 3), x = a(y.length), _ = 0, w = i ? f(e, x) : l ? f(e, 0) : void 0; x > _; _++)
                if ((p || _ in y) && (m = y[_], g = A(m, _, v), t))
                    if (i) w[_] = g;
                    else if (g) switch (t) {
                case 3:
                    return !0;
                case 5:
                    return m;
                case 6:
                    return _;
                case 2:
                    w.push(m)
            } else if (c) return !1;
            return u ? -1 : h || c ? c : w
        }
    }
}, function (t, e, i) {
    "use strict";
    var r = i(1);
    t.exports = function (t) {
        r(r.S, t, {
            of: function () {
                for (var t = arguments.length, e = new Array(t); t--;) e[t] = arguments[t];
                return new this(e)
            }
        })
    }
}, function (t, e, i) {
    "use strict";
    var r = i(1),
        n = i(25),
        o = i(16),
        a = i(19);
    t.exports = function (t) {
        r(r.S, t, {
            from: function (t) {
                var e, i, r, s, l = arguments[1];
                return n(this), e = void 0 !== l, e && n(l), void 0 == t ? new this : (i = [], e ? (r = 0, s = o(l, arguments[2], 2), a(t, !1, function (t) {
                    i.push(s(t, r++))
                })) : a(t, !1, i.push, i), new this(i))
            }
        })
    }
}, function (t, e) {
    e.f = Object.getOwnPropertySymbols
}, function (t, e, i) {
    t.exports = {
        default: i(126),
        __esModule: !0
    }
}, function (t, e, i) {
    e.f = i(7)
}, function (t, e, i) {
    var r = i(5),
        n = i(0),
        o = i(24),
        a = i(62),
        s = i(11).f;
    t.exports = function (t) {
        var e = n.Symbol || (n.Symbol = o ? {} : r.Symbol || {});
        "_" == t.charAt(0) || t in e || s(e, t, {
            value: a.f(t)
        })
    }
}, function (t, e) {
    t.exports = "\t\n\v\f\r \u2028\u2029\ufeff"
}, function (t, e, i) {
    "use strict";

    function r(t) {
        var e, i;
        this.promise = new t(function (t, r) {
            if (void 0 !== e || void 0 !== i) throw TypeError("Bad Promise constructor");
            e = t, i = r
        }), this.resolve = n(e), this.reject = n(i)
    }
    var n = i(25);
    t.exports.f = function (t) {
        return new r(t)
    }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        switch (!0) {
            case 0 == t:
                return n.floor;
            case 1 <= t && t < 500:
                return n.point;
            case 500 <= t && t < 1e3:
                return n.other;
            case 1e3 == t:
                return n.wall;
            case 1003 == t:
                return n.seat;
            case 1004 == t:
                return n.desk;
            case 1e3 < t && t < 1003 || 1004 < t && t <= 1999:
            case 2004 == t:
            case 2008 <= t && t <= 2010:
            case 2011 < t && t <= 2012:
            case 2012 <= t && t <= 2050:
                return n.room;
            case 2e3 <= t && t <= 2003:
            case 2005 <= t && t <= 2007:
            case 2010 < t && t <= 2011:
            case 2051 <= t:
                return n.plane;
            default:
                return console.error("sType error"), !1
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = r;
    var n = {
        room: {
            func: "drawRoom",
            type: "room"
        },
        seat: {
            func: "drawRoom",
            type: "seat"
        },
        desk: {
            func: "drawRoom",
            type: "desk"
        },
        point: {
            func: "drawLogo",
            type: "point"
        },
        plane: {
            func: "drawPlane",
            type: "plane"
        },
        floor: {
            func: "drawRoom",
            type: "floor"
        },
        wall: {
            func: "drawRoom",
            type: "wall"
        },
        other: {
            func: "drawLogo",
            type: "other"
        }
    }
}, function (t, e, i) {
    var r = i(14),
        n = i(17),
        o = i(99)(!1),
        a = i(48)("IE_PROTO");
    t.exports = function (t, e) {
        var i, s = n(t),
            l = 0,
            h = [];
        for (i in s) i != a && r(s, i) && h.push(i);
        for (; e.length > l;) r(s, i = e[l++]) && (~o(h, i) || h.push(i));
        return h
    }
}, function (t, e, i) {
    var r = i(1),
        n = i(0),
        o = i(13);
    t.exports = function (t, e) {
        var i = (n.Object || {})[t] || Object[t],
            a = {};
        a[t] = e(i), r(r.S + r.F * o(function () {
            i(1)
        }), "Object", a)
    }
}, function (t, e, i) {
    t.exports = !i(8) && !i(13)(function () {
        return 7 != Object.defineProperty(i(51)("div"), "a", {
            get: function () {
                return 7
            }
        }).a
    })
}, function (t, e, i) {
    var r = i(11),
        n = i(12),
        o = i(22);
    t.exports = i(8) ? Object.defineProperties : function (t, e) {
        n(t);
        for (var i, a = o(e), s = a.length, l = 0; s > l;) r.f(t, i = a[l++], e[i]);
        return t
    }
}, function (t, e, i) {
    var r = i(5).document;
    t.exports = r && r.documentElement
}, function (t, e) {
    t.exports = function (t, e) {
        return {
            value: e,
            done: !!t
        }
    }
}, function (t, e, i) {
    "use strict";
    var r = i(11).f,
        n = i(36),
        o = i(37),
        a = i(16),
        s = i(38),
        l = i(19),
        h = i(53),
        c = i(72),
        u = i(75),
        p = i(8),
        f = i(20).fastKey,
        d = i(30),
        m = p ? "_s" : "size",
        g = function (t, e) {
            var i, r = f(e);
            if ("F" !== r) return t._i[r];
            for (i = t._f; i; i = i.n)
                if (i.k == e) return i
        };
    t.exports = {
        getConstructor: function (t, e, i, h) {
            var c = t(function (t, r) {
                s(t, c, e, "_i"), t._t = e, t._i = n(null), t._f = void 0, t._l = void 0, t[m] = 0, void 0 != r && l(r, i, t[h], t)
            });
            return o(c.prototype, {
                clear: function () {
                    for (var t = d(this, e), i = t._i, r = t._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), delete i[r.i];
                    t._f = t._l = void 0, t[m] = 0
                },
                delete: function (t) {
                    var i = d(this, e),
                        r = g(i, t);
                    if (r) {
                        var n = r.n,
                            o = r.p;
                        delete i._i[r.i], r.r = !0, o && (o.n = n), n && (n.p = o), i._f == r && (i._f = n), i._l == r && (i._l = o), i[m]--
                    }
                    return !!r
                },
                forEach: function (t) {
                    d(this, e);
                    for (var i, r = a(t, arguments.length > 1 ? arguments[1] : void 0, 3); i = i ? i.n : this._f;)
                        for (r(i.v, i.k, this); i && i.r;) i = i.p
                },
                has: function (t) {
                    return !!g(d(this, e), t)
                }
            }), p && r(c.prototype, "size", {
                get: function () {
                    return d(this, e)[m]
                }
            }), c
        },
        def: function (t, e, i) {
            var r, n, o = g(t, e);
            return o ? o.v = i : (t._l = o = {
                i: n = f(e, !0),
                k: e,
                v: i,
                p: r = t._l,
                n: void 0,
                r: !1
            }, t._f || (t._f = o), r && (r.n = o), t[m]++, "F" !== n && (t._i[n] = o)), t
        },
        getEntry: g,
        setStrong: function (t, e, i) {
            h(t, e, function (t, i) {
                this._t = d(t, e), this._k = i, this._l = void 0
            }, function () {
                for (var t = this, e = t._k, i = t._l; i && i.r;) i = i.p;
                return t._t && (t._l = i = i ? i.n : t._t._f) ? "keys" == e ? c(0, i.k) : "values" == e ? c(0, i.v) : c(0, [i.k, i.v]) : (t._t = void 0, c(1))
            }, i ? "entries" : "values", !i, !0), u(e)
        }
    }
}, function (t, e, i) {
    var r = i(55),
        n = i(7)("iterator"),
        o = i(28);
    t.exports = i(0).getIteratorMethod = function (t) {
        if (void 0 != t) return t[n] || t["@@iterator"] || o[r(t)]
    }
}, function (t, e, i) {
    "use strict";
    var r = i(5),
        n = i(0),
        o = i(11),
        a = i(8),
        s = i(7)("species");
    t.exports = function (t) {
        var e = "function" == typeof n[t] ? n[t] : r[t];
        a && e && !e[s] && o.f(e, s, {
            configurable: !0,
            get: function () {
                return this
            }
        })
    }
}, function (t, e, i) {
    var r = i(23);
    t.exports = Array.isArray || function (t) {
        return "Array" == r(t)
    }
}, function (t, e, i) {
    var r = i(55),
        n = i(114);
    t.exports = function (t) {
        return function () {
            if (r(this) != t) throw TypeError(t + "#toJSON isn't generic");
            return n(this)
        }
    }
}, function (t, e, i) {
    "use strict";
    var r = i(22),
        n = i(60),
        o = i(40),
        a = i(32),
        s = i(45),
        l = Object.assign;
    t.exports = !l || i(13)(function () {
        var t = {},
            e = {},
            i = Symbol(),
            r = "abcdefghijklmnopqrst";
        return t[i] = 7, r.split("").forEach(function (t) {
            e[t] = t
        }), 7 != l({}, t)[i] || Object.keys(l({}, e)).join("") != r
    }) ? function (t, e) {
        for (var i = a(t), l = arguments.length, h = 1, c = n.f, u = o.f; l > h;)
            for (var p, f = s(arguments[h++]), d = c ? r(f).concat(c(f)) : r(f), m = d.length, g = 0; m > g;) u.call(f, p = d[g++]) && (i[p] = f[p]);
        return i
    } : l
}, function (t, e, i) {
    var r = i(67),
        n = i(50).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function (t) {
        return r(t, n)
    }
}, function (t, e, i) {
    t.exports = {
        default: i(134),
        __esModule: !0
    }
}, function (t, e, i) {
    var r = i(1),
        n = i(33),
        o = i(13),
        a = i(64),
        s = "[" + a + "]",
        l = "",
        h = RegExp("^" + s + s + "*"),
        c = RegExp(s + s + "*$"),
        u = function (t, e, i) {
            var n = {},
                s = o(function () {
                    return !!a[t]() || l[t]() != l
                }),
                h = n[t] = s ? e(p) : a[t];
            i && (n[i] = h), r(r.P + r.F * s, "String", n)
        },
        p = u.trim = function (t, e) {
            return t = String(n(t)), 1 & e && (t = t.replace(h, "")), 2 & e && (t = t.replace(c, "")), t
        };
    t.exports = u
}, function (t, e, i) {
    t.exports = {
        default: i(151),
        __esModule: !0
    }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    e.__esModule = !0;
    var n = i(164),
        o = r(n),
        a = i(61),
        s = r(a),
        l = "function" == typeof s.default && "symbol" == typeof o.default ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof s.default && t.constructor === s.default && t !== s.default.prototype ? "symbol" : typeof t
        };
    e.default = "function" == typeof s.default && "symbol" === l(o.default) ? function (t) {
        return void 0 === t ? "undefined" : l(t)
    } : function (t) {
        return t && "function" == typeof s.default && t.constructor === s.default && t !== s.default.prototype ? "symbol" : void 0 === t ? "undefined" : l(t)
    }
}, function (t, e, i) {
    t.exports = {
        default: i(167),
        __esModule: !0
    }
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(10),
        h = (r(l), i(86)),
        c = r(h),
        u = i(42),
        p = r(u),
        f = function () {
            function t(e, i) {
                (0, o.default)(this, t), this.startTime = (new Date).getTime(), e.config = i, this.object3D = this.drawObject3D(e), this.floorName = e.name, this.y = (e.floor - 1) * i.defaultGap, this.clickModels = this.setClickModels(this.object3D, i.defaultClickModels), this.palenModels = this.setClickModels(this.object3D, i.defaultPlaneModels), this.autoModels = this.setAutoModels(this.object3D, i.defaultAutoModels), this.detectModels = this.setDetectModels(this.object3D, i.defaultDetectModels), this.extremum = e.extremum, this.mapCenter = e.mapCenter, this.coordinates = e.coordinates, this.wallHeight = e.wallHeight, this.getfloorjson(e)
            }
            return (0, s.default)(t, [{
                key: "getfloorjson",
                value: function (t) {
                    var e = {},
                        i = [],
                        r = [];
                    t.geoJson.forEach(function (t) {
                        t.center = [Math.round(100 * t.center[0]) / 100, Math.round(100 * t.center[1]) / 100], t.lnglat = [Math.round(1e8 * t.lnglat[0]) / 1e8, Math.round(1e8 * t.lnglat[1]) / 1e8], t.properties.height = Math.round(100 * t.properties.height) / 100;
                        var n = [];
                        t.line && t.line.forEach(function (t) {
                            n.push(Math.round(100 * t[0]) / 100), n.push(Math.round(100 * t[1]) / 100)
                        });
                        var o = [];
                        if (o.push(n), t.line = [], t.line.push(o), 0 === t.id && (e.Outline = t.line, e.id = t.id, e.High = t.y, e.lnglat = t.lnglat, e.center = t.center, e.sType = t.sType, e.drawType = t.drawType, e.layer = t.layer, e.Brief = t.name, e.floor = t.floor, e.Name = t.floorName, e.properties = t.properties), 0 != t.id && t.line) {
                            var a = {};
                            a.Outline = t.line, a.id = t.id, a.High = t.y, a.lnglat = t.lnglat, a.center = t.center, a.sType = t.sType, a.drawType = t.drawType, a.layer = t.layer, a.Brief = t.name, a.floor = t.floor, a.Name = t.floorName, a.properties = t.properties, i.push(a)
                        }
                        if (e.FuncAreas = i, t.properties && (t.properties.logo || t.properties.name)) {
                            var s = {};
                            s.Outline = t.center, s.id = t.id, s.High = t.y, s.lnglat = t.lnglat, s.sType = t.sType, s.drawType = t.drawType, s.layer = t.layer, s.Brief = t.name, s.floor = t.floor, s.Name = t.floorName, s.properties = t.properties, r.push(s)
                        }
                    }), e.FuncAreas = i, e.PubPoint = r
                }
            }, {
                key: "consTime",
                value: function (t) {
                    var e = (new Date).getTime();
                    console.warn(t + "......" + (e - this.startTime)), this.startTime = e
                }
            }, {
                key: "drawObject3D",
                value: function (t) {
                    return p.default.drawOneFloor(t)
                }
            }, {
                key: "setClickModels",
                value: function (t) {
                    for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = [], r = (c.default.Point.between, 0); r < e.length; r++)
                        for (var n = t.getObjectByName(e[r]), o = 0; o < n.children.length; o++) i.push(n.children[o]);
                    return i
                }
            }, {
                key: "setAutoModels",
                value: function (t) {
                    for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = [], r = 0; r < e.length; r++)
                        for (var n = t.getObjectByName(e[r]), o = 0; o < n.children.length; o++) i.push(n.children[o]);
                    return i
                }
            }, {
                key: "setDetectModels",
                value: function (t) {
                    for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = [], r = 0; r < e.length; r++)
                        for (var n = t.getObjectByName(e[r]), o = 0; o < n.children.length; o++) i.push(n.children[o]);
                    return i
                }
            }, {
                key: "addClickModels",
                value: function (t) {
                    this.clickModels.push(t)
                }
            }]), t
        }();
    e.default = f
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = {
        Room: [],
        Point: {
            between: [500, 999],
            now: 500
        }
    };
    e.default = r
}, function (t, e, i) {
    "use strict";

    function r(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "3d",
            i = arguments[2],
            r = [],
            n = [],
            o = 0,
            a = 0,
            s = 0,
            l = 0;
        switch (e) {
            case "2d":
                s = t.extremum.l + t.y, r = [a, s, l], o = 1e4 / t.extremum.l / 28 * i.mapConfig.zoom;
                break;
            case "3d":
                a = t.extremum.l, s = t.extremum.l + t.y, l = t.extremum.l, r = [a, s, l], o = i.mapConfig.zoom;
                break;
            default:
                console.error("the type '" + e + "' is error!")
        }
        return n = [0, t.y, 0], {
            position: r,
            target: n,
            zoom: o,
            extremum: t.extremum
        }
    }

    function n(t, e, i) {
        var r = new a.Vector3,
            n = new a.Vector3(0, 1, 0),
            o = new a.Vector3,
            s = new a.Vector3,
            l = new a.Vector3,
            h = new a.Vector3,
            c = (new a.Vector3, new a.Vector3),
            u = (new a.Vector3, new a.Vector3);
        r.subVectors(i, e), r.normalize(), o.crossVectors(r, n).normalize(), s.crossVectors(o, r).normalize();
        var p = t.scale.x,
            f = t.scale.y;
        return l.setX(f / 2 * s.x + t.position.x), l.setY(f / 2 * s.y + t.position.y), l.setZ(f / 2 * s.z + t.position.z), h.setX(-f / 2 * s.x + t.position.x), h.setY(-f / 2 * s.y + t.position.y), h.setZ(-f / 2 * s.z + t.position.z), c.setX(-p / 2 * o.x + l.x), c.setY(-p / 2 * o.y + l.y), c.setZ(-p / 2 * o.z + l.z), u.setX(p / 2 * o.x + h.x), u.setY(p / 2 * o.y + h.y), u.setZ(p / 2 * o.z + h.z), [c, u]
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.cameraHelper = r, e.computeSpriteVertix = n;
    var o = i(4),
        a = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(o)
}, function (t, e, i) {
    t.exports = {
        default: i(178),
        __esModule: !0
    }
}, function (t, e, i) {
    var r = i(12),
        n = i(25),
        o = i(7)("species");
    t.exports = function (t, e) {
        var i, a = r(t).constructor;
        return void 0 === a || void 0 == (i = r(a)[o]) ? e : n(i)
    }
}, function (t, e, i) {
    var r, n, o, a = i(16),
        s = i(180),
        l = i(71),
        h = i(51),
        c = i(5),
        u = c.process,
        p = c.setImmediate,
        f = c.clearImmediate,
        d = c.MessageChannel,
        m = c.Dispatch,
        g = 0,
        v = {},
        y = function () {
            var t = +this;
            if (v.hasOwnProperty(t)) {
                var e = v[t];
                delete v[t], e()
            }
        },
        A = function (t) {
            y.call(t.data)
        };
    p && f || (p = function (t) {
        for (var e = [], i = 1; arguments.length > i;) e.push(arguments[i++]);
        return v[++g] = function () {
            s("function" == typeof t ? t : Function(t), e)
        }, r(g), g
    }, f = function (t) {
        delete v[t]
    }, "process" == i(23)(u) ? r = function (t) {
        u.nextTick(a(y, t, 1))
    } : m && m.now ? r = function (t) {
        m.now(a(y, t, 1))
    } : d ? (n = new d, o = n.port2, n.port1.onmessage = A, r = a(o.postMessage, o, 1)) : c.addEventListener && "function" == typeof postMessage && !c.importScripts ? (r = function (t) {
        c.postMessage(t + "", "*")
    }, c.addEventListener("message", A, !1)) : r = "onreadystatechange" in h("script") ? function (t) {
        l.appendChild(h("script")).onreadystatechange = function () {
            l.removeChild(this), y.call(t)
        }
    } : function (t) {
        setTimeout(a(y, t, 1), 0)
    }), t.exports = {
        set: p,
        clear: f
    }
}, function (t, e) {
    t.exports = function (t) {
        try {
            return {
                e: !1,
                v: t()
            }
        } catch (t) {
            return {
                e: !0,
                v: t
            }
        }
    }
}, function (t, e, i) {
    var r = i(12),
        n = i(6),
        o = i(65);
    t.exports = function (t, e) {
        if (r(t), n(e) && e.constructor === t) return e;
        var i = o.f(t);
        return (0, i.resolve)(e), i.promise
    }
}, function (t, e) {
    var i;
    i = function () {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(10),
        n = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r),
        o = n.default.verdictFence,
        a = {
            findingPath: function (t, e, i) {
                var r = void 0;
                if (r = i instanceof Array ? i : i.paths, r[0] instanceof Array) {
                    for (var n = void 0, a = void 0, s = void 0, l = void 0, h = void 0, c = 0; c < i.field.length; c++)
                        if (l = o(t, i.field[c]), h = o(e, i.field[c]), l >= 0 && h >= 0) {
                            s = c;
                            break
                        } if (l >= 0 && h >= 0) {
                        if (n = this.getNearId(t, r[s]), a = this.getNearId(e, r[s]), n == a) return alert(""), !1;
                        var u = this.getPath(n, a, r[s]),
                            p = [];
                        p.push([t[0], t[1]]);
                        for (var f = u.length - 1; f >= 0; f--) p.push(r[s][u[f]].coor);
                        return p.push([e[0], e[1]]), p
                    }
                    return alert("the startPoint cannot attach to the endPoint!"), !1
                }
                var d = this.getNearId(t, r),
                    m = this.getNearId(e, r);
                if (d == m) return alert(""), !1;
                var g = this.getPath(d, m, r),
                    v = [];
                v.push([t[0], t[1]]);
                for (var y = g.length - 1; y >= 0; y--) v.push(r[g[y]].coor);
                return v.push([e[0], e[1]]), v
            },
            getNearId: function (t, e) {
                for (var i = void 0, r = 1 / 0, n = 0; n < e.length; n++) {
                    var o = this.getdistance1(t, e[n].coor);
                    if (o < r) {
                        if (0 == o) return n;
                        r = o, i = n
                    }
                }
                return i
            },
            getdistance1: function (t, e) {
                return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
            },
            getPath: function (t, e, i) {
                console.log(t);
                var r = this.getArray(i),
                    n = this.dijkstra(r, t, i);
                console.log(r), console.log(t), console.log(e), console.log(n), console.log(i), console.log(n[e]);
                var o = new Array;
                for (o.push(e); n[e] != t;) o.push(n[e]), e = n[e];
                return o.push(t), o
            },
            getArray: function (t) {
                for (var e = t.length, i = new Array(e), r = 0; r < e; r++) {
                    i[r] = new Array(e);
                    for (var n = 0; n < e; n++) this.isAdjacent(r, n, t) ? i[r][n] = this.getDistance(r, n, t) : i[r][n] = Number.POSITIVE_INFINITY
                }
                return i
            },
            isAdjacent: function (t, e, i) {
                for (var r in i[t].nextPoint)
                    if (i[t].nextPoint[r] == e) return !0;
                return !1
            },
            getDistance: function (t, e, i) {
                return Math.sqrt((i[t].coor[0] - i[e].coor[0]) * (i[t].coor[0] - i[e].coor[0]) + (i[t].coor[1] - i[e].coor[1]) * (i[t].coor[1] - i[e].coor[1]))
            },
            dijkstra: function (t, e, i) {
                for (var r = [], n = [], o = new Array, a = 0; a < i.length; a++) o[a] = 0, r[a] = t[e][a], r[a] < Number.POSITIVE_INFINITY ? n[a] = e : n[a] = -1;
                r[e] = 0, o[e] = 1;
                for (var s = 1; s < i.length - 1; s++) {
                    for (var l = Number.POSITIVE_INFINITY, h = -1, c = 0; c < i.length; c++) 0 == o[c] && r[c] < l && (h = c, l = r[c]);
                    if (-1 == h) break;
                    o[h] = 1;
                    for (var u = 0; u < i.length; u++) 0 == o[u] && l + t[h][u] < r[u] && (r[u] = l + t[h][u], n[u] = h)
                }
                return n
            }
        };
    e.default = a
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var n = i(31),
        o = i(117),
        a = r(o),
        s = i(207),
        l = r(s),
        h = i(208),
        c = r(h),
        u = i(209),
        p = r(u),
        f = i(210),
        d = r(f),
        m = i(211),
        g = r(m),
        v = i(212),
        y = r(v),
        A = i(213),
        x = r(A),
        _ = i(214),
        w = r(_),
        b = i(215),
        M = r(b),
        T = i(216),
        S = r(T),
        E = i(217),
        C = r(E),
        P = i(218),
        L = r(P),
        D = i(10),
        R = r(D),
        I = i(94),
        O = r(I),
        B = i(21),
        N = {
            set: n.set,
            get: n.get
        },
        k = {
            Menu: l.default,
            Scale: c.default,
            InfoWindow: g.default,
            Compass: p.default,
            ModeSwitch: d.default
        },
        F = {
            PolyLine: y.default,
            Vidicon: M.default,
            ImageMarker: S.default,
            TextMarker: C.default,
            Heatmap: L.default,
            DrawLine: x.default,
            DrawFance: w.default
        },
        z = R.default.verdictFence,
        U = R.default.nearestPoint.bind(R.default),
        G = R.default.nearestPoints.bind(R.default),
        V = R.default.pointFindArea.bind(R.default),
        H = R.default.findNearPoints.bind(R.default),
        j = O.default.findingPath.bind(O.default),
        W = {
            verdictFence: z,
            nearestPoint: U,
            nearestPoints: G,
            pointFindArea: V,
            findNearPoints: H,
            findingPath: j,
            coordinatesToMercato: B.coordinatesToMercato,
            mercatoToCoordinates: B.mercatoToCoordinates
        },
        Y = {
            VERSION: "1.2.0",
            Config: N,
            Map: a.default,
            Controls: k,
            Markers: F,
            Tools: W
        };
    window.OvuRouteMap = Y
}, function (t, e, i) {
    var r = i(0),
        n = r.JSON || (r.JSON = {
            stringify: JSON.stringify
        });
    t.exports = function (t) {
        return n.stringify.apply(n, arguments)
    }
}, function (t, e, i) {
    i(98), t.exports = i(0).Object.keys
}, function (t, e, i) {
    var r = i(32),
        n = i(22);
    i(68)("keys", function () {
        return function (t) {
            return n(r(t))
        }
    })
}, function (t, e, i) {
    var r = i(17),
        n = i(46),
        o = i(100);
    t.exports = function (t) {
        return function (e, i, a) {
            var s, l = r(e),
                h = n(l.length),
                c = o(a, h);
            if (t && i != i) {
                for (; h > c;)
                    if ((s = l[c++]) != s) return !0
            } else
                for (; h > c; c++)
                    if ((t || c in l) && l[c] === i) return t || c || 0;
            return !t && -1
        }
    }
}, function (t, e, i) {
    var r = i(47),
        n = Math.max,
        o = Math.min;
    t.exports = function (t, e) {
        return t = r(t), t < 0 ? n(t + e, 0) : o(t, e)
    }
}, function (t, e, i) {
    t.exports = {
        default: i(102),
        __esModule: !0
    }
}, function (t, e, i) {
    i(26), i(27), i(18), i(108), i(113), i(115), i(116), t.exports = i(0).Set
}, function (t, e, i) {
    var r = i(47),
        n = i(33);
    t.exports = function (t) {
        return function (e, i) {
            var o, a, s = String(n(e)),
                l = r(i),
                h = s.length;
            return l < 0 || l >= h ? t ? "" : void 0 : (o = s.charCodeAt(l), o < 55296 || o > 56319 || l + 1 === h || (a = s.charCodeAt(l + 1)) < 56320 || a > 57343 ? t ? s.charAt(l) : o : t ? s.slice(l, l + 2) : a - 56320 + (o - 55296 << 10) + 65536)
        }
    }
}, function (t, e, i) {
    "use strict";
    var r = i(36),
        n = i(35),
        o = i(29),
        a = {};
    i(15)(a, i(7)("iterator"), function () {
        return this
    }), t.exports = function (t, e, i) {
        t.prototype = r(a, {
            next: n(1, i)
        }), o(t, e + " Iterator")
    }
}, function (t, e, i) {
    var r = i(14),
        n = i(32),
        o = i(48)("IE_PROTO"),
        a = Object.prototype;
    t.exports = Object.getPrototypeOf || function (t) {
        return t = n(t), r(t, o) ? t[o] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? a : null
    }
}, function (t, e, i) {
    "use strict";
    var r = i(107),
        n = i(72),
        o = i(28),
        a = i(17);
    t.exports = i(53)(Array, "Array", function (t, e) {
        this._t = a(t), this._i = 0, this._k = e
    }, function () {
        var t = this._t,
            e = this._k,
            i = this._i++;
        return !t || i >= t.length ? (this._t = void 0, n(1)) : "keys" == e ? n(0, i) : "values" == e ? n(0, t[i]) : n(0, [i, t[i]])
    }, "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries")
}, function (t, e) {
    t.exports = function () {}
}, function (t, e, i) {
    "use strict";
    var r = i(73),
        n = i(30);
    t.exports = i(56)("Set", function (t) {
        return function () {
            return t(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        add: function (t) {
            return r.def(n(this, "Set"), t = 0 === t ? 0 : t, t)
        }
    }, r)
}, function (t, e, i) {
    var r = i(12);
    t.exports = function (t, e, i, n) {
        try {
            return n ? e(r(i)[0], i[1]) : e(i)
        } catch (e) {
            var o = t.return;
            throw void 0 !== o && r(o.call(t)), e
        }
    }
}, function (t, e, i) {
    var r = i(28),
        n = i(7)("iterator"),
        o = Array.prototype;
    t.exports = function (t) {
        return void 0 !== t && (r.Array === t || o[n] === t)
    }
}, function (t, e, i) {
    var r = i(112);
    t.exports = function (t, e) {
        return new(r(t))(e)
    }
}, function (t, e, i) {
    var r = i(6),
        n = i(76),
        o = i(7)("species");
    t.exports = function (t) {
        var e;
        return n(t) && (e = t.constructor, "function" != typeof e || e !== Array && !n(e.prototype) || (e = void 0), r(e) && null === (e = e[o]) && (e = void 0)), void 0 === e ? Array : e
    }
}, function (t, e, i) {
    var r = i(1);
    r(r.P + r.R, "Set", {
        toJSON: i(77)("Set")
    })
}, function (t, e, i) {
    var r = i(19);
    t.exports = function (t, e) {
        var i = [];
        return r(t, !1, i.push, i, e), i
    }
}, function (t, e, i) {
    i(58)("Set")
}, function (t, e, i) {
    i(59)("Set")
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(118),
        o = r(n),
        a = i(39),
        s = r(a),
        l = i(9),
        h = r(l),
        c = i(2),
        u = r(c),
        p = i(3),
        f = r(p),
        d = i(61),
        m = r(d),
        g = i(133),
        v = r(g),
        y = i(173),
        A = r(y),
        x = i(87),
        _ = i(195),
        w = r(_),
        b = i(31),
        M = i(10),
        T = r(M),
        S = i(196),
        E = r(S),
        C = i(4),
        P = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(C);
    i(197);
    i(201), i(203), i(204), i(205);
    var L = i(206),
        D = r(L),
        R = (0, m.default)("Scene"),
        I = (0, m.default)("Floors"),
        O = (0, m.default)("Config"),
        B = (0, m.default)("HighLight"),
        N = (0, m.default)("MapData"),
        k = (0, m.default)("Render"),
        F = (0, m.default)("createScene"),
        z = (0, m.default)("clearHighLight"),
        U = function () {
            function t(e) {
                var i = this;
                (0, u.default)(this, t), this.THREE = P, this.dom = e.container, this[I] = [], this.floors = [], this[B] = [], this[O] = JSON.parse((0, h.default)(b.config)), void 0 === e.defaultFloor && "F1" === this[O].mapConfig.defaultFloor && e.mapList && e.mapList.length > 0 && e.mapList[0].name && (e.defaultFloor = e.mapList[0].name), (0, b.set)(e, this[O]), this.event = new w.default, this[N] = new A.default((0, s.default)({}, this[O].mapConfig, e), this.event);
                var r = function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i[O];
                    return e.mapConfig.hasOwnProperty(t) ? e.mapConfig[t] : null
                };
                this.config = {
                    set: b.set,
                    get: r
                }, this[k]()
            }
            return (0, f.default)(t, [{
                key: F,
                value: function () {
                    var t = T.default.isEmpty(this[N].commonTheme) ? 15856375 : this[N].commonTheme.bgColor.fillcolor;
                    t = T.default.isEmpty(this[O].mapConfig.bgColor) ? t : this[O].mapConfig.bgColor, this[R] = new v.default({
                        dom: this.dom,
                        bgColor: t,
                        config: this[O].mapConfig,
                        event: this.event
                    }), this.screenCoordinates = this[R].screenCoordinates.bind(this[R]), this.control = this[R].control
                }
            }, {
                key: k,
                value: function () {
                    var t = this;
                    this[N].getData().then(function (e) {
                        t[R] || t[F](), t[R].consTime(""), t[N].mapDataHandle(e), t[R].consTime(""), t[I] = t[N].mapsObj, t.floors = t[N].floors, t.loadedMap = t[N].loadedMap, t.extremum = t[N].extremum, t[R].consTime(".......");
                        var i = t[I].findIndex(function (e) {
                            return e.floorName === t[O].mapConfig.defaultFloor
                        });
                        t[R].consTime("......."), -1 === i && (i = 0);
                        var r = "2d";
                        "MODE_3D" === t[O].mapConfig.showViewMode && (r = "3d");
                        var n = (0, x.cameraHelper)(t[I][i], r, t[O]);
                        t[R].consTime("......."), t[R].changeCamera(n, r), t[R].consTime("......."), !0 === t[O].mapConfig.showAllFloor ? t.showAllFloor() : t.showOneFloor(), t[R].consTime("!"), t[N].getRemainData()
                    }).catch(function (t) {
                        return console.error(t)
                    })
                }
            }, {
                key: "getScaleSpacing",
                value: function () {
                    return this.scaleSpacing = this[R].getScaleSpacing(), this.scaleSpacing
                }
            }, {
                key: "getMapCenter",
                value: function (t) {
                    var e = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    if (e) return e.coordinates;
                    console.error("there is no floor named " + t)
                }
            }, {
                key: "resetRender",
                value: function (t) {
                    this[R].clear(), t.themeUrl && (this[N].commonTheme.length = 0, this[N].object.themeUrl = t.themeUrl), (0, b.set)(this[O].userConfig, this[O]), (0, b.set)(t, this[O]), this[O].mapConfig.defaultFloor = this[O].mapConfig.defaultFloor ? this[O].mapConfig.defaultFloor : t.mapList[0].name, this[N].maps.length = 0, this[N].maps = T.default.cloneOwn(t.mapList), this[N].object = (0, s.default)({}, t, this[O].mapConfig), this[k]()
                }
            }, {
                key: "mapTo2D",
                value: function () {
                    var t = this;
                    if ("MODE_3D" === this[O].mapConfig.showViewMode) {
                        var e = this[I].findIndex(function (e) {
                            return e.floorName === t[O].mapConfig.defaultFloor
                        });
                        e = -1 === e ? 0 : e;
                        var i = (0, x.cameraHelper)(this[I][e], "2d", this[O]);
                        this[R].changeCamera(i, "2d"), this[O].mapConfig.showViewMode = "MODE_2D", this[R].OcclusionDetection = !0, this[R].resetRnimate(), this.event.emit("changeModel", {
                            showViewMode: "2D"
                        })
                    }
                }
            }, {
                key: "mapTo3D",
                value: function () {
                    var t = this;
                    if ("MODE_2D" === this[O].mapConfig.showViewMode) {
                        var e = this[I].findIndex(function (e) {
                            return e.floorName === t[O].mapConfig.defaultFloor
                        });
                        e = -1 === e ? 0 : e;
                        var i = (0, x.cameraHelper)(this[I][e], "3d", this[O]);
                        this[R].changeCamera(i, "3d"), this[O].mapConfig.showViewMode = "MODE_3D", this[R].OcclusionDetection = !0, this[R].resetRnimate(), this.event.emit("changeModel", {
                            showViewMode: "3D"
                        })
                    }
                }
            }, {
                key: "showOneFloor",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this[O].mapConfig.defaultFloor;
                    this[R].clear();
                    var e = this[I].findIndex(function (e) {
                        return e.floorName === t
                    });
                    console.warn(".." + this[I][0]), -1 !== e ? this[R].add(this[I][e]) : this[R].add(this[I][0]), this[O].mapConfig.showAllFloor = !1, this[R].OcclusionDetection = !0, this[R].resetRnimate(), this.event.emit("loaded")
                }
            }, {
                key: "showAllFloor",
                value: function () {
                    var t = this;
                    this[R].clear(), this[R].consTime("!"), this[I].forEach(function (e) {
                        t[R].add(e)
                    }), this[R].consTime("!"), this[O].mapConfig.showAllFloor = !0, this[R].OcclusionDetection = !0, this[R].resetRnimate(), this.event.emit("loaded")
                }
            }, {
                key: "showFloor",
                value: function (t) {
                    var e = this,
                        i = this[I].find(function (e) {
                            return e.floorName === t
                        });
                    this[I].find(function (t) {
                        return t.floorName === e[O].mapConfig.defaultFloor
                    });
                    if (i) {
                        if (this[O].mapConfig.defaultFloor = t, this[O].mapConfig.showAllFloor)
                            if ("MODE_3D" === this[O].mapConfig.showViewMode) {
                                var r = (0, x.cameraHelper)(i, "3d", this[O]);
                                this[R].changeCamera(r, "3d")
                            } else {
                                var n = (0, x.cameraHelper)(i, "2d", this[O]);
                                this[R].changeCamera(n, "2d")
                            }
                        else if (this[R].clear(), this[R].add(i), "MODE_3D" === this[O].mapConfig.showViewMode) {
                            var o = (0, x.cameraHelper)(i, "3d", this[O]);
                            this[R].changeCamera(o, "3d")
                        } else {
                            var a = (0, x.cameraHelper)(i, "2d", this[O]);
                            this[R].changeCamera(a, "2d")
                        }
                        this[R].OcclusionDetection = !0, this[R].resetRnimate(), this.event.emit("changeFloor", {
                            floor: i
                        })
                    }
                }
            }, {
                key: "addControl",
                value: function (t) {
                    t.callback(this)
                }
            }, {
                key: z,
                value: function () {
                    if (this[B].length)
                        for (var t = this[B].length - 1; 0 <= t; t--) this[B][t].material.color.set(this[B][t].info.properties.fillcolor), this[B][t].material.opacity = 1, this[B].pop()
                }
            }, {
                key: "highLightById",
                value: function (t, e) {
                    var i = this;
                    if ((!(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]) && this[z](), t && e)
                        if (t instanceof Array)
                            for (var r = 0; r < t.length; r++) ! function (r) {
                                i[R].control.clickModels.forEach(function (n) {
                                    n.info.id && n.info.floorName && n.info.id == t[r] && n.info.floorName == e && (T.default.isEmpty(n.info.properties.splicing) ? (n.material.color.set("#ffc04b"), i[B].push(n)) : i[R].control.clickModels.forEach(function (t) {
                                        n.info.properties.splicing === t.info.properties.splicing && t.info.floorName === e && (t.material.color.set("#ffc04b"), i[B].push(t))
                                    }))
                                })
                            }(r);
                        else this[R].control.clickModels.forEach(function (r) {
                            r.info.id && r.info.floorName && r.info.id == t && r.info.floorName == e && (T.default.isEmpty(r.info.properties.splicing) ? (r.material.color.set("#ffc04b"), i[B].push(r)) : i[R].control.clickModels.forEach(function (t) {
                                r.info.properties.splicing === t.info.properties.splicing && t.info.floorName === e && (t.material.color.set("#ffc04b"), i[B].push(t))
                            }))
                        });
                    else console.error("piModelId or psfloor is undefined")
                }
            }, {
                key: "clearHighLight",
                value: function () {
                    this[z]()
                }
            }, {
                key: "highLightByUUID",
                value: function (t) {
                    var e = this;
                    this[z]();
                    var i = function (t) {
                        e[R].control.clickModels.forEach(function (i) {
                            i.info.properties && i.info.properties.uuid && i.info.properties.uuid === t && (i.material.color.set("#ffc04b"), e[B].push(i))
                        })
                    };
                    t instanceof Array ? t.forEach(function (t) {
                        return i(t)
                    }) : i(t)
                }
            }, {
                key: "clearFloorLayer",
                value: function (t) {
                    for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = this[I].find(function (e) {
                            return e.floorName === t
                        }), n = r.object3D.children.slice(), o = 0; o < n.length; o++) {
                        var a = n[o].name;
                        e ? this.clearLayer(t, a) : "roomGroup" !== a && "nameGroup" !== a && "wallGroup" !== a && "seatGroup" !== a && "deskGroup" !== a && "logoGroup" !== a && "lineGroup" !== a && "planeGroup" !== a && "bottomGroup" !== a && i.indexOf(a) < 0 && this.clearLayer(t, a)
                    }
                }
            }, {
                key: "clearLayer",
                value: function (t, e) {
                    var i = this,
                        r = this[I].find(function (e) {
                            return e.floorName === t
                        });
                    r ? e instanceof Array ? t.forEach(function (t) {
                        var n = r.object3D.getObjectByName(t);
                        if (n) {
                            for (; 0 != n.children.length;) {
                                var o = -1;
                                i[R].control.clickModels.forEach(function (t, e) {
                                    if (t && t.uuid == n.children[0].uuid) return void(o = e)
                                }), o > -1 && i[R].control.clickModels.splice(o, 1), n.children[0] && n.remove(n.children[0])
                            }
                            r.object3D.children = r.object3D.children.filter(function (t) {
                                return t.name != n.name
                            })
                        } else console.warn("there is no layer named " + e)
                    }) : function () {
                        var t = r.object3D.getObjectByName(e);
                        if (t) {
                            for (; 0 != t.children.length;) {
                                var n = -1;
                                i[R].control.clickModels.forEach(function (e, i) {
                                    if (e && e.uuid == t.children[0].uuid) return void(n = i)
                                }), n > -1 && i[R].control.clickModels.splice(n, 1), t.children[0] && t.remove(t.children[0])
                            }
                            r.object3D.children = r.object3D.children.filter(function (e) {
                                return e.name != t.name
                            })
                        } else console.warn("there is no layer named " + e)
                    }() : console.warn("there is no floor named " + t)
                }
            }, {
                key: "hiddenLayer",
                value: function (t, e) {
                    var i = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    i ? void 0 != i.object3D.getObjectByName(e) && (i.object3D.getObjectByName(e).visible = !1) : console.error("there is no floor named " + t)
                }
            }, {
                key: "showLayer",
                value: function (t, e) {
                    var i = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    i ? i.object3D.getObjectByName(e).visible = !0 : console.error("there is no floor named " + t)
                }
            }, {
                key: "setLayerHeight",
                value: function (t, e, i) {
                    var r = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    r ? r.object3D.getObjectByName(e).position.y += i : console.error("there is no floor named " + t)
                }
            }, {
                key: "restoreLayerHeight",
                value: function (t, e) {
                    var i = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    i ? i.object3D.getObjectByName(e).position.y = i.y : console.error("there is no floor named " + t)
                }
            }, {
                key: "getLayers",
                value: function (t) {
                    var e = [],
                        i = this[I].find(function (e) {
                            return e.floorName === t
                        });
                    return i ? i.object3D.children.forEach(function (t) {
                        return e.push(t.name)
                    }) : console.error("there is no floor named " + t), e
                }
            }, {
                key: "getFloors",
                value: function () {
                    var t = [];
                    return this[I].forEach(function (e) {
                        return t.push(e.floorName)
                    }), t
                }
            }, {
                key: "createLayer",
                value: function (t, e) {
                    var i = this[I].find(function (e) {
                        return e.floorName === t
                    });
                    if (i) {
                        if (-1 != i.object3D.children.findIndex(function (t) {
                                return t.name === e
                            })) return void console.error("the layer named '" + e + "' is exist");
                        var r = E.default.createLayer(e);
                        r.position.setY(i.y), i.object3D.add(r)
                    } else console.error("this floorName not definded")
                }
            }, {
                key: "addToLayer",
                value: function (t, e, i) {
                    var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                        n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                        o = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5],
                        a = t,
                        s = new P.Mesh,
                        l = this[I].find(function (t) {
                            return t.floorName === e
                        });
                    if (l) {
                        a.info || (a.info = {}), a.info.floor = l.floor, a.info.floorName = e, a.info.layerName = i, a.info.isclick = r, a.info.isDetectModel = n, a.info.isAutoModel = o, a.info.y = (a.info.floor - 1) * this[O].mapConfig.defaultGap, a.info.properties || (a.info.properties = {}), a.info.properties.mapCenter = l.mapCenter, a.info.properties.height = 0, a.info.layer = i, a.info.position = [a.position.x, a.position.y, a.position.z], a.info.center = [t.position.x, t.position.z], s.info || (s.info = {}), s.info.center = [t.position.x, t.position.z], s.info.floorName = e, s.info.layer = i, s.info.floor = l.floor, s.info.y = (a.info.floor - 1) * this[O].mapConfig.defaultGap, s.add(a);
                        var h = l.object3D.getObjectByName(i);
                        h || (this.createLayer(e, i), h = l.object3D.getObjectByName(i)), h.add(s), r && (l.addClickModels(s), this[R].addClickModel(s)), t instanceof P.Sprite && (o && this[R].autoModels[0].push(s), n && this[R].detectModels[0].push(s))
                    } else console.warn("there is no floor named " + e);
                    return a
                }
            }, {
                key: "getObjectById",
                value: function (t) {
                    var e = {};
                    return this[R].scene.traverse(function (i) {
                        i.id == t && (e = i)
                    }), e
                }
            }, {
                key: "getObjectByInfoId",
                value: function (t) {
                    var e = {};
                    return this[R].scene.traverse(function (i) {
                        i instanceof P.Line || !i.info || i.info.id != t || (e = i)
                    }), e
                }
            }, {
                key: "deleteObjectById",
                value: function (t) {
                    var e = this.getObjectById(t),
                        i = this[I].find(function (t) {
                            return t.floorName === e.info.floorName
                        });
                    if (i) {
                        var r = i.object3D.getObjectByName(e.info.layerName);
                        r && r.remove(e)
                    } else console.error("you can't delet the object with id = " + id + ",the reason may be as follows:1.this object is a base object.2.the object can't be found in scene")
                }
            }, {
                key: "getObjectPositionByInfoId",
                value: function (t, e) {
                    var i = void 0;
                    return i = T.default.isEmpty(e) ? this[R].control.clickModels.find(function (e) {
                        if (e.info.properties.uuid === t) return e
                    }) : this[R].control.clickModels.find(function (i) {
                        if (i.children.length > 0)
                            if (i.children[0].info.properties.id || 1 * i.children[0].info.properties.id == 0) {
                                if (i.children[0].info.properties.id == t && i.children[0].info.floor === e) return i
                            } else if (i.children[0].info.properties.userData && (i.children[0].info.properties.userData.id || 1 * i.children[0].info.properties.userData.id == 0) && i.children[0].info.properties.userData.id == t && i.children[0].info.floor === e) return i
                    }), i ? i.children[0] instanceof P.Sprite ? {
                        x: i.children[0].info.center[0],
                        y: i.children[0].position.y,
                        z: i.children[0].info.center[1]
                    } : {
                        x: i.info.center[0],
                        y: i.info.properties.height + i.info.y,
                        z: i.info.center[1]
                    } : (console.warn('Map to get the object id "' + t + '" error'), !1)
                }
            }, {
                key: "isEnablePan",
                value: function (t) {
                    "boolean" == typeof t && (this[R].control.enablePan = t)
                }
            }, {
                key: "isEnableZoom",
                value: function (t) {
                    "boolean" == typeof t && (this[R].control.enableZoom = t)
                }
            }, {
                key: "isEnableRotate",
                value: function (t) {
                    "boolean" == typeof t && (this[R].control.enableRotate = t)
                }
            }, {
                key: "getLayer",
                value: function (t, e) {
                    var i = null,
                        r = this[I].find(function (e) {
                            return e.floorName === t
                        });
                    return r ? r.object3D.children.forEach(function (t) {
                        t.name === e && (i = t)
                    }) : console.error("there is no floor named " + t), i || (console.warn("there is no layer named " + e), !1)
                }
            }, {
                key: "setMeshStyle",
                value: function (t, e) {
                    var i = this,
                        r = !0,
                        n = !1,
                        a = void 0;
                    try {
                        for (var s, l = (0, o.default)(t); !(r = (s = l.next()).done); r = !0) ! function () {
                            var t = s.value;
                            i[I].find(function (i) {
                                i.floorName === t && i.object3D.children.forEach(function (t) {
                                    for (var i in e)
                                        if (e.hasOwnProperty(i) && t.name == i)
                                            for (var r in e[i]) {
                                                var n = !0,
                                                    a = !1,
                                                    s = void 0;
                                                try {
                                                    for (var l, h = (0, o.default)(t.children); !(n = (l = h.next()).done); n = !0) {
                                                        var c = l.value;
                                                        switch (r) {
                                                            case "color":
                                                                c.material.color.set(e[i].color);
                                                                break;
                                                            case "opacity":
                                                                c.material.opacity = e[i].opacity;
                                                                break;
                                                            case "depthTest":
                                                                c.material.depthTest = e[i].depthTest;
                                                                break;
                                                            case "size":
                                                                c.scale.set(e[i].size[0], e[i].size[1], e[i].size[2]);
                                                                break;
                                                            case "position":
                                                                c.position.set(e[i].position[0], e[i].position[1], e[i].position[2]);
                                                                break;
                                                            case "renderOrder":
                                                                c.renderOrder = e[i].renderOrder
                                                        }
                                                    }
                                                } catch (t) {
                                                    a = !0, s = t
                                                } finally {
                                                    try {
                                                        !n && h.return && h.return()
                                                    } finally {
                                                        if (a) throw s
                                                    }
                                                }
                                            }
                                })
                            })
                        }()
                    } catch (t) {
                        n = !0, a = t
                    } finally {
                        try {
                            !r && l.return && l.return()
                        } finally {
                            if (n) throw a
                        }
                    }
                }
            }, {
                key: "restoreMeshStyle",
                value: function (t, e) {
                    var i = this,
                        r = !0,
                        n = !1,
                        a = void 0;
                    try {
                        for (var s, l = (0, o.default)(t); !(r = (s = l.next()).done); r = !0) ! function () {
                            var t = s.value;
                            i[I].find(function (i) {
                                i.floorName === t && i.object3D.children.forEach(function (t) {
                                    for (var i in e) e.hasOwnProperty(i) && t.name == i && e[i].forEach(function (e) {
                                        var i = !0,
                                            r = !1,
                                            n = void 0;
                                        try {
                                            for (var a, s = (0, o.default)(t.children); !(i = (a = s.next()).done); i = !0) {
                                                var l = a.value;
                                                switch (e) {
                                                    case "color":
                                                        l.material.color.set(l.info.properties.fillcolor);
                                                        break;
                                                    case "opacity":
                                                        l.material.opacity = l.info.properties.opacity || 1;
                                                        break;
                                                    case "depthTest":
                                                        l.material.depthTest = !0;
                                                        break;
                                                    case "size":
                                                        l.scale.set(1, 1, 1);
                                                        break;
                                                    case "position":
                                                        l.position.set(l.info.center[0], l.info.y, l.info.center[1]);
                                                        break;
                                                    case "renderOrder":
                                                        l.renderOrder = 0
                                                }
                                            }
                                        } catch (t) {
                                            r = !0, n = t
                                        } finally {
                                            try {
                                                !i && s.return && s.return()
                                            } finally {
                                                if (r) throw n
                                            }
                                        }
                                    })
                                })
                            })
                        }()
                    } catch (t) {
                        n = !0, a = t
                    } finally {
                        try {
                            !r && l.return && l.return()
                        } finally {
                            if (n) throw a
                        }
                    }
                }
            }, {
                key: "isLayerExist",
                value: function (t, e) {
                    var i = !1,
                        r = this[I].find(function (e) {
                            return e.floorName == t
                        });
                    return r && r.object3D.children.forEach(function (t) {
                        t.name == e && (i = !0)
                    }), i
                }
            }, {
                key: "navigation",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    t.floorName = t.floorName ? t.floorName : "F1";
                    var e = this,
                        i = void 0,
                        r = void 0;
                    return function (n) {
                        var o = void 0;
                        n.animate = function () {
                            e.isLayerExist(t.floorName, "naviLayer") && i.running ? (i.update(r), o = requestAnimationFrame(n.animate)) : cancelAnimationFrame(o)
                        }, i = new D.default(e.control, n, e.event, function (t) {
                            r = t, i.computePathSegment(r), e.addToLayer(r, n.floorName, "naviLayer", !1, !1, !1), n.animate()
                        }), i.overNavigation = function () {
                            i.running = !0, i.nowStep = 0, i.state = 1, i.prevPosition = i.startPosition, i.discrib = {
                                distance: i.totalDistance,
                                remain: 0,
                                remainTime: {
                                    hour: 0,
                                    minute: 0,
                                    second: 0
                                },
                                nextDirection: ""
                            }, n.animate()
                        }, i.stopNavigation = function () {
                            cancelAnimationFrame(o)
                        }
                    }((0, s.default)({}, t)), i
                }
            }, {
                key: "addOBJMTLModel",
                value: function (t) {
                    var e = function (t) {
                            if (t.lengthComputable) {
                                var e = t.loaded / t.total * 100;
                                console.warn(Math.round(e, 2) + "% downloaded")
                            }
                        },
                        i = function (t) {
                            console.error("addOBJMTLModel Error")
                        };
                    P.Loader.Handlers.add(/\.dds$/i, new P.DDSLoader(P)), new P.MTLLoader(P).setPath(t.modelPath).load(t.mtlName, function (r) {
                        r.preload(), new P.OBJLoader(P).setMaterials(r).setPath(t.modelPath).load(t.objName, P, function (e) {
                            e.scale.set(t.size, t.size, t.size), e.position.set(t.position[0], t.position[1], t.position[2]), t.callback.call(null, e)
                        }, e, i)
                    })
                }
            }, {
                key: "addJSONModel",
                value: function (t) {
                    t.position = t.position ? t.position : [0, 0, 0], t.size = t.size ? t.size : 1;
                    var e = this;
                    (new P.JSONLoader).load(t.src, function (i, r) {
                        for (var n = 0; n < r.length; n++) {
                            var o = r[n];
                            o.morphTargets = !0, o.skinning = !0
                        }
                        var a = void 0;
                        if (i.animations && i.animations.length > 0) {
                            a = new P.SkinnedMesh(i, new P.MeshFaceMaterial(r));
                            var s = new P.AnimationMixer(a),
                                l = s.clipAction(i.animations[0], a);
                            l.play(), a.action = l;
                            var h = new P.Clock;
                            e.event.on("animate", function () {
                                s.update(3 * h.getDelta())
                            })
                        } else a = new P.Mesh(i, new P.MultiMaterial(r));
                        a.position.set(t.position[0], t.position[1], t.position[2]), a.scale.x = a.scale.y = a.scale.z = Number(t.size), a.castShadow = !0, t.callback.call(null, a)
                    })
                }
            }, {
                key: "moveTo",
                value: function (t) {
                    var e = (new P.Vector3).subVectors(new P.Vector3(t.x, t.y, t.z), this.control.target);
                    TweenMax.to(this.control.target, .5, {
                        x: t.x,
                        y: t.y,
                        z: t.z,
                        ease: Power0.easeNone
                    });
                    var i = e.add(this.control.object.position);
                    TweenMax.to(this.control.object.position, .5, {
                        x: i.x,
                        y: i.y,
                        z: i.z,
                        ease: Power0.easeNone
                    })
                }
            }]), t
        }();
    e.default = U
}, function (t, e, i) {
    t.exports = {
        default: i(119),
        __esModule: !0
    }
}, function (t, e, i) {
    i(18), i(27), t.exports = i(120)
}, function (t, e, i) {
    var r = i(12),
        n = i(74);
    t.exports = i(0).getIterator = function (t) {
        var e = n(t);
        if ("function" != typeof e) throw TypeError(t + " is not iterable!");
        return r(e.call(t))
    }
}, function (t, e, i) {
    i(122), t.exports = i(0).Object.assign
}, function (t, e, i) {
    var r = i(1);
    r(r.S + r.F, "Object", {
        assign: i(78)
    })
}, function (t, e, i) {
    t.exports = {
        default: i(124),
        __esModule: !0
    }
}, function (t, e, i) {
    i(125);
    var r = i(0).Object;
    t.exports = function (t, e, i) {
        return r.defineProperty(t, e, i)
    }
}, function (t, e, i) {
    var r = i(1);
    r(r.S + r.F * !i(8), "Object", {
        defineProperty: i(11).f
    })
}, function (t, e, i) {
    i(127), i(26), i(131), i(132), t.exports = i(0).Symbol
}, function (t, e, i) {
    "use strict";
    var r = i(5),
        n = i(14),
        o = i(8),
        a = i(1),
        s = i(54),
        l = i(20).KEY,
        h = i(13),
        c = i(49),
        u = i(29),
        p = i(34),
        f = i(7),
        d = i(62),
        m = i(63),
        g = i(128),
        v = i(76),
        y = i(12),
        A = i(6),
        x = i(17),
        _ = i(52),
        w = i(35),
        b = i(36),
        M = i(129),
        T = i(130),
        S = i(11),
        E = i(22),
        C = T.f,
        P = S.f,
        L = M.f,
        D = r.Symbol,
        R = r.JSON,
        I = R && R.stringify,
        O = f("_hidden"),
        B = f("toPrimitive"),
        N = {}.propertyIsEnumerable,
        k = c("symbol-registry"),
        F = c("symbols"),
        z = c("op-symbols"),
        U = Object.prototype,
        G = "function" == typeof D,
        V = r.QObject,
        H = !V || !V.prototype || !V.prototype.findChild,
        j = o && h(function () {
            return 7 != b(P({}, "a", {
                get: function () {
                    return P(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }) ? function (t, e, i) {
            var r = C(U, e);
            r && delete U[e], P(t, e, i), r && t !== U && P(U, e, r)
        } : P,
        W = function (t) {
            var e = F[t] = b(D.prototype);
            return e._k = t, e
        },
        Y = G && "symbol" == typeof D.iterator ? function (t) {
            return "symbol" == typeof t
        } : function (t) {
            return t instanceof D
        },
        X = function (t, e, i) {
            return t === U && X(z, e, i), y(t), e = _(e, !0), y(i), n(F, e) ? (i.enumerable ? (n(t, O) && t[O][e] && (t[O][e] = !1), i = b(i, {
                enumerable: w(0, !1)
            })) : (n(t, O) || P(t, O, w(1, {})), t[O][e] = !0), j(t, e, i)) : P(t, e, i)
        },
        Q = function (t, e) {
            y(t);
            for (var i, r = g(e = x(e)), n = 0, o = r.length; o > n;) X(t, i = r[n++], e[i]);
            return t
        },
        J = function (t, e) {
            return void 0 === e ? b(t) : Q(b(t), e)
        },
        q = function (t) {
            var e = N.call(this, t = _(t, !0));
            return !(this === U && n(F, t) && !n(z, t)) && (!(e || !n(this, t) || !n(F, t) || n(this, O) && this[O][t]) || e)
        },
        Z = function (t, e) {
            if (t = x(t), e = _(e, !0), t !== U || !n(F, e) || n(z, e)) {
                var i = C(t, e);
                return !i || !n(F, e) || n(t, O) && t[O][e] || (i.enumerable = !0), i
            }
        },
        K = function (t) {
            for (var e, i = L(x(t)), r = [], o = 0; i.length > o;) n(F, e = i[o++]) || e == O || e == l || r.push(e);
            return r
        },
        $ = function (t) {
            for (var e, i = t === U, r = L(i ? z : x(t)), o = [], a = 0; r.length > a;) !n(F, e = r[a++]) || i && !n(U, e) || o.push(F[e]);
            return o
        };
    G || (D = function () {
        if (this instanceof D) throw TypeError("Symbol is not a constructor!");
        var t = p(arguments.length > 0 ? arguments[0] : void 0),
            e = function (i) {
                this === U && e.call(z, i), n(this, O) && n(this[O], t) && (this[O][t] = !1), j(this, t, w(1, i))
            };
        return o && H && j(U, t, {
            configurable: !0,
            set: e
        }), W(t)
    }, s(D.prototype, "toString", function () {
        return this._k
    }), T.f = Z, S.f = X, i(79).f = M.f = K, i(40).f = q, i(60).f = $, o && !i(24) && s(U, "propertyIsEnumerable", q, !0), d.f = function (t) {
        return W(f(t))
    }), a(a.G + a.W + a.F * !G, {
        Symbol: D
    });
    for (var tt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), et = 0; tt.length > et;) f(tt[et++]);
    for (var it = E(f.store), rt = 0; it.length > rt;) m(it[rt++]);
    a(a.S + a.F * !G, "Symbol", {
        for: function (t) {
            return n(k, t += "") ? k[t] : k[t] = D(t)
        },
        keyFor: function (t) {
            if (!Y(t)) throw TypeError(t + " is not a symbol!");
            for (var e in k)
                if (k[e] === t) return e
        },
        useSetter: function () {
            H = !0
        },
        useSimple: function () {
            H = !1
        }
    }), a(a.S + a.F * !G, "Object", {
        create: J,
        defineProperty: X,
        defineProperties: Q,
        getOwnPropertyDescriptor: Z,
        getOwnPropertyNames: K,
        getOwnPropertySymbols: $
    }), R && a(a.S + a.F * (!G || h(function () {
        var t = D();
        return "[null]" != I([t]) || "{}" != I({
            a: t
        }) || "{}" != I(Object(t))
    })), "JSON", {
        stringify: function (t) {
            for (var e, i, r = [t], n = 1; arguments.length > n;) r.push(arguments[n++]);
            if (i = e = r[1], (A(e) || void 0 !== t) && !Y(t)) return v(e) || (e = function (t, e) {
                if ("function" == typeof i && (e = i.call(this, t, e)), !Y(e)) return e
            }), r[1] = e, I.apply(R, r)
        }
    }), D.prototype[B] || i(15)(D.prototype, B, D.prototype.valueOf), u(D, "Symbol"), u(Math, "Math", !0), u(r.JSON, "JSON", !0)
}, function (t, e, i) {
    var r = i(22),
        n = i(60),
        o = i(40);
    t.exports = function (t) {
        var e = r(t),
            i = n.f;
        if (i)
            for (var a, s = i(t), l = o.f, h = 0; s.length > h;) l.call(t, a = s[h++]) && e.push(a);
        return e
    }
}, function (t, e, i) {
    var r = i(17),
        n = i(79).f,
        o = {}.toString,
        a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
        s = function (t) {
            try {
                return n(t)
            } catch (t) {
                return a.slice()
            }
        };
    t.exports.f = function (t) {
        return a && "[object Window]" == o.call(t) ? s(t) : n(r(t))
    }
}, function (t, e, i) {
    var r = i(40),
        n = i(35),
        o = i(17),
        a = i(52),
        s = i(14),
        l = i(69),
        h = Object.getOwnPropertyDescriptor;
    e.f = i(8) ? h : function (t, e) {
        if (t = o(t), e = a(e, !0), l) try {
            return h(t, e)
        } catch (t) {}
        if (s(t, e)) return n(!r.f.call(t, e), t[e])
    }
}, function (t, e, i) {
    i(63)("asyncIterator")
}, function (t, e, i) {
    i(63)("observable")
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(9),
        o = r(n),
        a = i(80),
        s = r(a),
        l = i(2),
        h = r(l),
        c = i(3),
        u = r(c),
        p = i(4),
        f = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(p),
        d = i(166),
        m = r(d),
        g = i(85),
        v = r(g),
        y = i(10),
        A = r(y),
        x = i(171),
        _ = r(x),
        w = i(172),
        b = r(w),
        M = i(87),
        T = function () {
            function t(e) {
                var i = e.dom,
                    r = e.bgColor,
                    n = e.config,
                    o = e.event;
                (0, h.default)(this, t), this.startTime = (new Date).getTime(), this.event = o, this.animID = 0, this.OcclusionDetection = !1, this.config = n, this.dom = i, this.domWidth = (0, s.default)(this.dom.offsetWidth), this.domHeight = (0, s.default)(this.dom.offsetHeight), this.detectModels = [], this.autoModels = [], this.defaultLightNum = 0, this.scene = new f.Scene, this.cameraSet = new _.default(this.dom), "MODE_3D" === n.showViewMode ? this.camera = this.cameraSet.perspectiveCamera : this.camera = this.cameraSet.orthographicCamera, this.renderer = new f.WebGLRenderer({
                    antialias: !0,
                    alpha: !0
                }), this.renderer.domElement.top = A.default.getOffset(this.dom, "Top"), this.renderer.domElement.left = A.default.getOffset(this.dom, "Left"), this.renderer.autoClear = !1, this.control = new m.default(this.camera, this.renderer.domElement, this.event), this.sceneOrtho = new f.Scene, this.cameraOrtho = new f.OrthographicCamera(-this.domWidth / 2, this.domWidth / 2, this.domHeight / 2, -this.domHeight / 2, 1, 1e3), this.cameraOrtho.position.y = 10, this.addWatermark(), this.init(r, n), this.animate()
            }
            return (0, u.default)(t, [{
                key: "consTime",
                value: function (t) {
                    var e = (new Date).getTime();
                    console.warn(t + "......" + (e - this.startTime)), this.startTime = e
                }
            }, {
                key: "init",
                value: function (t, e) {
                    this.renderer.setSize(this.domWidth, this.domHeight), this.renderer.setClearColor(t, e.opacity), this.renderer.setPixelRatio(window.devicePixelRatio), this.dom.appendChild(this.renderer.domElement), "MODE_3D" === e.showViewMode ? (this.camera.position.set(200, 200, 200), this.control._2d = !1) : (this.camera.position.set(0, 200, 0), this.control._2d = !0), this.createLight(e.defaultLight)
                }
            }, {
                key: "resetRnimate",
                value: function () {
                    cancelAnimationFrame(this.animID), this.animate()
                }
            }, {
                key: "animate",
                value: function () {
                    var t = this;
                    this.event.emit("animate"), this.control.update(), this.resize(), this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.event.emit("changeElement", this.scene), this.renderer.clearDepth(), this.animID = requestAnimationFrame(this.animate.bind(this)), ("MODE_3D" === this.config.showViewMode && 50 * (new f.Vector3).subVectors(new f.Vector3, this.camera.position).length() / this.extremum < 420 || "MODE_2D" == this.config.showViewMode && this.control.object.zoom > 150 / this.extremum) && this.autoChange();
                    var e = this.scene.getObjectByName("roadLayer");
                    if (e)
                        for (var i = e.children[0].children[0].info.properties.speed, r = 0; r < e.children.length; r++) e.children[r].children[0].material.map.offset.x -= i / 100, e.children[r].children[0].material.map.offset.x < 0 && (e.children[r].children[0].material.map.offset.x = 1);
                    this.OcclusionDetection && (this.detectHide(), setTimeout(function () {
                        return t.OcclusionDetection = !1
                    }, 500))
                }
            }, {
                key: "getScaleSpacing",
                value: function () {
                    var t = this.screenCoordinates({
                            x: 0,
                            y: 0,
                            z: 0
                        }),
                        e = this.screenCoordinates({
                            x: 1e3,
                            y: 0,
                            z: 0
                        });
                    return A.default.getdistance([t.x, t.y], [e.x, e.y]) / 1e3
                }
            }, {
                key: "add",
                value: function (t) {
                    var e = this;
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this.event.off("onDetect", i), t instanceof f.Object3D ? this.scene.add(t) : t instanceof v.default ? (this.scene.add(t.object3D), this.control.addIntoClickModels(t.clickModels), this.control.addIntoFloorModels(t.palenModels), this.autoModels.push(t.autoModels), this.detectModels.push(t.detectModels)) : console.error("the object of this type can't be add into scene");
                    var i = function () {
                        setTimeout(function () {
                            ("MODE_3D" === e.config.showViewMode && 50 * (new f.Vector3).subVectors(new f.Vector3, e.camera.position).length() / e.extremum < 400 || "MODE_2D" == e.config.showViewMode && e.control.object.zoom > 200 / e.extremum) && e.detectHide()
                        }, 0)
                    };
                    this.event.on("onDetect", i)
                }
            }, {
                key: "addClickModel",
                value: function (t) {
                    this.control.clickModels.push(t)
                }
            }, {
                key: "clear",
                value: function () {
                    for (var t = this.scene.children.length; t != this.defaultLightNum;) this.scene.remove(this.scene.children[this.defaultLightNum]), t = this.scene.children.length;
                    this.autoModels.splice(0, this.autoModels.length), this.detectModels.splice(0, this.detectModels.length), this.control.clearClickModels()
                }
            }, {
                key: "setCamera",
                value: function (t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "3d";
                    this.control.setCamera(t, e, i, this)
                }
            }, {
                key: "resize",
                value: function () {
                    this.domWidth = (0, s.default)(this.dom.offsetWidth), this.domHeight = (0, s.default)(this.dom.offsetHeight), this.camera.aspect = this.domWidth / this.domHeight, this.cameraOrtho.left = -this.domWidth / 2, this.cameraOrtho.right = this.domWidth / 2, this.cameraOrtho.top = this.domHeight / 2, this.cameraOrtho.bottom = -this.domHeight / 2, this.camera.left = -this.domWidth / 2, this.camera.right = this.domWidth / 2, this.camera.top = this.domHeight / 2, this.camera.bottom = -this.domHeight / 2, this.camera.updateProjectionMatrix(), this.cameraOrtho.updateProjectionMatrix();
                    var t = this.sceneOrtho.children[0].scale;
                    this.sceneOrtho.children[0].position.set(this.domWidth / 2 - t.x, 0, this.domHeight / 2 - 2 * t.y), this.renderer.domElement.top = A.default.getOffset(this.dom, "Top"), this.renderer.domElement.left = A.default.getOffset(this.dom, "Left"), this.renderer.setSize(this.domWidth, this.domHeight)
                }
            }, {
                key: "addWatermark",
                value: function () {
                    var t = new f.TextureLoader,
                        e = t.load(A.default.mapLogo()),
                        i = new f.SpriteMaterial({
                            map: e
                        }),
                        r = this.config.logoWidth,
                        n = this.config.logoHeight,
                        o = new f.Sprite(i);
                    o.scale.set(r, n, 1), this.sceneOrtho.add(o);
                    var a = this.domWidth / 2,
                        s = this.domHeight / 2;
                    o.position.set(a - r / 2 - 10, 0, s - n / 2 - 20)
                }
            }, {
                key: "createLight",
                value: function (t) {
                    this.defaultLightNum = 5;
                    var e = t.ambient,
                        i = new f.AmbientLight(e.color, e.opacity);
                    this.scene.add(i);
                    var r = t.verDir,
                        n = new f.DirectionalLight(r.color, r.opacity);
                    n.position.set(r.position.x, r.position.y, r.position.z), this.scene.add(n);
                    var o = t.horDir,
                        a = new f.DirectionalLight(o.color, o.opacity);
                    a.position.set(o.position.x, o.position.y, o.position.z), this.scene.add(a);
                    var s = t.HorDirPos,
                        l = new f.DirectionalLight(s.color, s.opacity);
                    l.position.set(s.position.x, s.position.y, s.position.z), this.scene.add(l);
                    var h = t.hemisphere,
                        c = new f.HemisphereLight(h.skyColor, h.groundColor, h.opacity);
                    if (c.position.set(h.position.x, h.position.y, h.position.z), this.scene.add(c), "undefined" != typeof dat) {
                        new function () {
                            this.hemisphere = !0, this.skyColor = "#ffffff", this.groundColor = "#ffffff", this.Ambient = .4, this.verDir = .5, this.horDir = .6, this.HorDirPos = .6, this.Hemisphere = .15
                        }
                    }
                }
            }, {
                key: "changeCamera",
                value: function (t, e) {
                    "3d" === e ? (this.camera = this.cameraSet.perspectiveCamera, this.control._2d = !1, this.control.sphericalDelta.theta = 0) : "2d" === e ? (this.camera = this.cameraSet.orthographicCamera, this.control._2d = !0, this.control.sphericalDelta.theta = this.config.theta * Math.PI / 180) : console.error("type:" + e + " is error"), this.control.object = this.camera, this.control.object.zoom = t.zoom;
                    var i = t.extremum.l > t.extremum.w ? t.extremum.l : t.extremum.w;
                    this.extremum = i, this.control.minDistance = i / 1.5 * .2, this.control.maxDistance = 20 * i, this.control.minZoom = .3 / i * 500, this.control.maxZoom = .3 / i * 500 + 50;
                    var r = (this.control.object.position, new f.Vector3(0, 0, 0).subVectors(new f.Vector3(0, 0, 0), new f.Vector3(t.position[0] / 3, t.position[1], t.position[2])).length()),
                        n = new f.Vector3(0, 0, 0).subVectors(new f.Vector3(0, 0, 0), new f.Vector3(t.position[0] / Math.tan(Math.PI / 2 - this.config.theta3D * Math.PI / 180), t.position[1], t.position[2])).length();
                    this.control.object.position.set(t.position[0] / Math.tan(Math.PI / 2 - this.config.theta3D * Math.PI / 180) * r / n, t.position[1] * r / n, t.position[2] * r / n), this.control.target = new f.Vector3(t.target[0], t.target[1], t.target[2]), this.camera.defaultPosition = JSON.parse((0, o.default)(this.control.object.position)), this.camera.defaultTarget = JSON.parse((0, o.default)(this.control.target))
                }
            }, {
                key: "screenCoordinates",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.camera,
                        i = new f.Vector3(t.x, t.y, t.z),
                        r = i.project(e),
                        n = void 0,
                        o = void 0,
                        a = this.renderer.domElement.getBoundingClientRect();
                    n = a.width / 2, o = a.height / 2;
                    return "relative" == window.getComputedStyle(this.dom, null).position ? {
                        x: Math.round(r.x * n + n),
                        y: Math.round(-r.y * o + o)
                    } : {
                        x: Math.round(r.x * n + n + A.default.getOffset(this.dom, "Left")),
                        y: Math.round(-r.y * o + o + A.default.getOffset(this.dom, "Top"))
                    }
                }
            }, {
                key: "detectHide",
                value: function () {
                    var t = this,
                        e = this.camera.clone();
                    this.detectModels.length && (this.detectModels.forEach(function (t) {
                        t.forEach(function (t) {
                            t.visible = !0
                        })
                    }), this.detectModels.forEach(function (i) {
                        if (!(i.length > 0 && i[0].children.length > 0 && "nameGroup" != i[0].children[0].info.layer && "pointGroup" != i[0].children[0].info.layer)) {
                            var r = [],
                                n = [];
                            i.forEach(function (i, o) {
                                if (i.children[0]) {
                                    var a = !0,
                                        s = i.children[0],
                                        l = t.computeSpriteVertixOnScreen(s, e),
                                        h = new b.default(l[0].x - 1, l[0].y - 1, l[1].x + 1, l[1].y + 1);
                                    r.push(h);
                                    for (var c = 0; c < r.length - 1; c++) {
                                        var u = r[c];
                                        if (h.isCollide(u)) {
                                            a = !1, r.pop();
                                            break
                                        }
                                    }
                                    s.visible = a, a && n.push(l)
                                }
                            })
                        }
                    }))
                }
            }, {
                key: "computeSpriteVertixOnScreen",
                value: function (t, e) {
                    for (var i = this.control.target, r = (0, M.computeSpriteVertix)(t, e.position, i), n = [], o = 0; o < r.length; o++) n.push(this.screenCoordinates(r[o], e));
                    return n
                }
            }, {
                key: "autoChange",
                value: function () {
                    if ("MODE_3D" == this.config.showViewMode) {
                        for (var t = new f.Vector3, e = 0; e < this.autoModels.length; e++)
                            for (var i = this.autoModels[e], r = 0; r < i.length; r++)
                                if (i[r].children[0]) {
                                    var n = i[r].children[0],
                                        o = t.subVectors(n.position, this.camera.position).length() / 70 * 2 / this.config.zoom,
                                        a = (new f.Vector3).subVectors(new f.Vector3, this.camera.position).length(),
                                        s = 50 * a / this.extremum;
                                    if (s > 400) {
                                        "imageMarker" !== n.info.drawType.func && (n.visible = !1);
                                        continue
                                    }
                                    s <= 400 && s > 100 && (o *= (1600 - s) / 1500), "pointGroup" == n.info.layer || "nameGroup" == n.info.layer ? n.scale.set((n.info.nameWidth + n.info.haveImg) * o, 1 * o, 2) : "imageMarker" == n.info.drawType.func ? n.scale.set(o * n.info.size.x / 2, o * n.info.size.y / 2, o * n.info.size.z) : "TextMarker" == n.info.drawType.func && n.scale.set(o * n.info.scale.x, o * n.info.scale.y, o * n.info.scale.z), "otherGroup" == n.info.layer && "drawLogo" == n.info.drawType.func && n.scale.set(o * n.info.size / 2, o * n.info.size / 2, 2), n.info.wallHeight ? "pointGroup" == n.info.layer ? n.position.setY(n.info.wallHeight / 2 + n.info.y + o / 2) : "nameGroup" == n.info.layer ? n.position.setY(n.info.wallHeight + n.info.y + o / 2) : n.position.setY(n.info.properties.height + n.info.y + o / 2) : n.info.position ? n.position.setY(n.info.y + n.info.position[1] + o / 2) : n.position.setY(n.info.y + n.info.properties.height + o / 2)
                                }
                    } else if ("MODE_2D" == this.config.showViewMode)
                        for (var l = 0; l < this.autoModels.length; l++)
                            for (var h = this.autoModels[l], c = 0; c < h.length; c++)
                                if (h[c].children[0]) {
                                    var u = h[c].children[0],
                                        p = 16 / this.control.object.zoom,
                                        d = 50 * p / this.extremum;
                                    if (d > 5) {
                                        "imageMarker" !== u.info.drawType.func && (u.visible = !1);
                                        continue
                                    }
                                    d <= 5 && d > 1 && (p *= (21 - d) / 20), "pointGroup" == u.info.layer || "nameGroup" == u.info.layer ? u.scale.set((u.info.nameWidth + u.info.haveImg) * p, 1 * p, 2) : "imageMarker" == u.info.drawType.func ? u.scale.set(p * u.info.size.x / 2, p * u.info.size.y / 2, p * u.info.size.z) : "TextMarker" == u.info.drawType.func && u.scale.set(p * u.info.scale.x, p * u.info.scale.y, p * u.info.scale.z), "otherGroup" == u.info.layer && "drawLogo" == u.info.drawType.func && u.scale.set(p * u.info.size / 2, p * u.info.size / 2, 2), u.info.wallHeight ? "pointGroup" == u.info.layer ? u.position.setY(u.info.wallHeight / 2 + u.info.y + p / 2) : "nameGroup" == u.info.layer ? u.position.setY(u.info.wallHeight + u.info.y + p / 2) : u.position.setY(u.info.properties.height + u.info.y + p / 2) : u.info.position ? u.position.setY(u.info.y + u.info.position[1] + p / 2) : u.position.setY(u.info.y + u.info.properties.height + p / 2)
                                }
                }
            }]), t
        }();
    e.default = T
}, function (t, e, i) {
    i(135), t.exports = i(0).Number.parseInt
}, function (t, e, i) {
    var r = i(1),
        n = i(136);
    r(r.S + r.F * (Number.parseInt != n), "Number", {
        parseInt: n
    })
}, function (t, e, i) {
    var r = i(5).parseInt,
        n = i(81).trim,
        o = i(64),
        a = /^[-+]?0[xX]/;
    t.exports = 8 !== r(o + "08") || 22 !== r(o + "0x16") ? function (t, e) {
        var i = n(String(t), 3);
        return r(i, e >>> 0 || (a.test(i) ? 16 : 10))
    } : r
}, function (t, e, i) {
    t.exports = {
        default: i(138),
        __esModule: !0
    }
}, function (t, e, i) {
    i(139), t.exports = i(0).Object.freeze
}, function (t, e, i) {
    var r = i(6),
        n = i(20).onFreeze;
    i(68)("freeze", function (t) {
        return function (e) {
            return t && r(e) ? t(n(e)) : e
        }
    })
}, function (t, e, i) {
    t.exports = {
        default: i(141),
        __esModule: !0
    }
}, function (t, e, i) {
    i(142), t.exports = i(0).Math.log2
}, function (t, e, i) {
    var r = i(1);
    r(r.S, "Math", {
        log2: function (t) {
            return Math.log(t) / Math.LN2
        }
    })
}, function (t, e, i) {
    t.exports = {
        default: i(144),
        __esModule: !0
    }
}, function (t, e, i) {
    i(26), i(18), i(145), i(147), i(148), t.exports = i(0).WeakMap
}, function (t, e, i) {
    "use strict";
    var r, n = i(57)(0),
        o = i(54),
        a = i(20),
        s = i(78),
        l = i(146),
        h = i(6),
        c = i(13),
        u = i(30),
        p = a.getWeak,
        f = Object.isExtensible,
        d = l.ufstore,
        m = {},
        g = function (t) {
            return function () {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        },
        v = {
            get: function (t) {
                if (h(t)) {
                    var e = p(t);
                    return !0 === e ? d(u(this, "WeakMap")).get(t) : e ? e[this._i] : void 0
                }
            },
            set: function (t, e) {
                return l.def(u(this, "WeakMap"), t, e)
            }
        },
        y = t.exports = i(56)("WeakMap", g, v, l, !0, !0);
    c(function () {
        return 7 != (new y).set((Object.freeze || Object)(m), 7).get(m)
    }) && (r = l.getConstructor(g, "WeakMap"), s(r.prototype, v), a.NEED = !0, n(["delete", "has", "get", "set"], function (t) {
        var e = y.prototype,
            i = e[t];
        o(e, t, function (e, n) {
            if (h(e) && !f(e)) {
                this._f || (this._f = new r);
                var o = this._f[t](e, n);
                return "set" == t ? this : o
            }
            return i.call(this, e, n)
        })
    }))
}, function (t, e, i) {
    "use strict";
    var r = i(37),
        n = i(20).getWeak,
        o = i(12),
        a = i(6),
        s = i(38),
        l = i(19),
        h = i(57),
        c = i(14),
        u = i(30),
        p = h(5),
        f = h(6),
        d = 0,
        m = function (t) {
            return t._l || (t._l = new g)
        },
        g = function () {
            this.a = []
        },
        v = function (t, e) {
            return p(t.a, function (t) {
                return t[0] === e
            })
        };
    g.prototype = {
        get: function (t) {
            var e = v(this, t);
            if (e) return e[1]
        },
        has: function (t) {
            return !!v(this, t)
        },
        set: function (t, e) {
            var i = v(this, t);
            i ? i[1] = e : this.a.push([t, e])
        },
        delete: function (t) {
            var e = f(this.a, function (e) {
                return e[0] === t
            });
            return ~e && this.a.splice(e, 1), !!~e
        }
    }, t.exports = {
        getConstructor: function (t, e, i, o) {
            var h = t(function (t, r) {
                s(t, h, e, "_i"), t._t = e, t._i = d++, t._l = void 0, void 0 != r && l(r, i, t[o], t)
            });
            return r(h.prototype, {
                delete: function (t) {
                    if (!a(t)) return !1;
                    var i = n(t);
                    return !0 === i ? m(u(this, e)).delete(t) : i && c(i, this._i) && delete i[this._i]
                },
                has: function (t) {
                    if (!a(t)) return !1;
                    var i = n(t);
                    return !0 === i ? m(u(this, e)).has(t) : i && c(i, this._i)
                }
            }), h
        },
        def: function (t, e, i) {
            var r = n(o(e), !0);
            return !0 === r ? m(t).set(e, i) : r[t._i] = i, t
        },
        ufstore: m
    }
}, function (t, e, i) {
    i(58)("WeakMap")
}, function (t, e, i) {
    i(59)("WeakMap")
}, function (t, e, i) {
    i(150);
    var r = i(0).Object;
    t.exports = function (t, e) {
        return r.create(t, e)
    }
}, function (t, e, i) {
    var r = i(1);
    r(r.S, "Object", {
        create: i(36)
    })
}, function (t, e, i) {
    i(152);
    var r = i(0).Object;
    t.exports = function (t, e) {
        return r.defineProperties(t, e)
    }
}, function (t, e, i) {
    var r = i(1);
    r(r.S + r.F * !i(8), "Object", {
        defineProperties: i(70)
    })
}, function (t, e, i) {
    t.exports = {
        default: i(154),
        __esModule: !0
    }
}, function (t, e, i) {
    i(155), t.exports = i(0).Math.sign
}, function (t, e, i) {
    var r = i(1);
    r(r.S, "Math", {
        sign: i(156)
    })
}, function (t, e) {
    t.exports = Math.sign || function (t) {
        return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
    }
}, function (t, e, i) {
    t.exports = {
        default: i(158),
        __esModule: !0
    }
}, function (t, e, i) {
    i(159), t.exports = i(0).Number.isInteger
}, function (t, e, i) {
    var r = i(1);
    r(r.S, "Number", {
        isInteger: i(160)
    })
}, function (t, e, i) {
    var r = i(6),
        n = Math.floor;
    t.exports = function (t) {
        return !r(t) && isFinite(t) && n(t) === t
    }
}, function (t, e, i) {
    t.exports = {
        default: i(162),
        __esModule: !0
    }
}, function (t, e, i) {
    i(163), t.exports = Math.pow(2, -52)
}, function (t, e, i) {
    var r = i(1);
    r(r.S, "Number", {
        EPSILON: Math.pow(2, -52)
    })
}, function (t, e, i) {
    t.exports = {
        default: i(165),
        __esModule: !0
    }
}, function (t, e, i) {
    i(27), i(18), t.exports = i(62).f("iterator")
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function n(t, e, i) {
        function r() {
            return 2 * Math.PI / 60 / 60 * z.autoRotateSpeed
        }

        function n() {
            return Math.pow(.95, z.zoomSpeed)
        }

        function o(t) {
            X.theta -= t
        }

        function a(t) {
            X.phi -= t
        }

        function s(t) {
            z.object.isPerspectiveCamera ? Q /= t : z.object.isOrthographicCamera ? (z.object.zoom = Math.max(z.minZoom, Math.min(z.maxZoom, z.object.zoom * t)), z.object.updateProjectionMatrix(), q = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), z.enableZoom = !1)
        }

        function l(t) {
            z.object.isPerspectiveCamera ? Q *= t : z.object.isOrthographicCamera ? (z.object.zoom = Math.max(z.minZoom, Math.min(z.maxZoom, z.object.zoom / t)), z.object.updateProjectionMatrix(), q = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), z.enableZoom = !1)
        }

        function h(t) {
            Z.set(t.clientX, t.clientY)
        }

        function p(t) {
            lt.set(t.clientX, t.clientY)
        }

        function f(t) {
            ot.set(t.clientX, t.clientY)
        }

        function d(t) {
            K.set(t.clientX, t.clientY), $.subVectors(K, Z);
            var e = z.domElement === document ? z.domElement.body : z.domElement;
            o(2 * Math.PI * $.x / e.clientWidth * z.rotateSpeed), a(2 * Math.PI * $.y / e.clientHeight * z.rotateSpeed), Z.copy(K), z.update()
        }

        function m(t) {
            ht.set(t.clientX, t.clientY), ct.subVectors(ht, lt), ct.y > 0 ? s(n()) : ct.y < 0 && l(n()), lt.copy(ht), z.update()
        }

        function g(t) {
            at.set(t.clientX, t.clientY), st.subVectors(at, ot), "PerspectiveCamera" === z.object.type ? ft(st.x / z.object.zoom, st.y / z.object.zoom) : ft(st.x, st.y), ot.copy(at), z.update()
        }

        function v(t) {}

        function y(t) {
            t.deltaY < 0 ? l(n()) : t.deltaY > 0 && s(n()), z.update()
        }

        function A(t) {
            switch (t.keyCode) {
                case z.keys.UP:
                    ft(0, z.keyPanSpeed), z.update();
                    break;
                case z.keys.BOTTOM:
                    ft(0, -z.keyPanSpeed), z.update();
                    break;
                case z.keys.LEFT:
                    ft(z.keyPanSpeed, 0), z.update();
                    break;
                case z.keys.RIGHT:
                    ft(-z.keyPanSpeed, 0), z.update()
            }
        }

        function x(t) {
            ot.set(t.touches[0].pageX, t.touches[0].pageY)
        }

        function _(t) {
            var e = t.touches[0].pageX - t.touches[1].pageX,
                i = t.touches[0].pageY - t.touches[1].pageY,
                r = Math.sqrt(e * e + i * i);
            lt.set(0, r), Z.set(t.touches[0].pageY - t.touches[1].pageY, t.touches[0].pageX - t.touches[1].pageX), tt.set(t.touches[0].pageX, t.touches[0].pageY), et.set(t.touches[1].pageX, t.touches[1].pageY)
        }

        function w(t) {
            at.set(t.touches[0].pageX, t.touches[0].pageY), st.subVectors(at, ot), ft(st.x, st.y), ot.copy(at), z.update()
        }

        function b(t) {
            K.set(t.touches[0].pageY - t.touches[1].pageY, t.touches[0].pageX - t.touches[1].pageX), it.set(t.touches[0].pageX, t.touches[0].pageY), rt.set(t.touches[1].pageX, t.touches[1].pageY), nt = Math.acos(Math.abs(Z.x * K.x + Z.y * K.y) / Math.sqrt((Z.x * Z.x + Z.y * Z.y) * (K.x * K.x + K.y * K.y)));
            var e = (new c.Vector2).subVectors(tt, et),
                i = (new c.Vector2).subVectors(it, rt);
            e.x * i.y - e.y * i.x > 0 && (nt = -nt), o(nt), Z.copy(K), tt.copy(it), et.copy(rt);
            var r = (z.domElement === document ? z.domElement.body : z.domElement, t.touches[0].pageX - t.touches[1].pageX),
                a = t.touches[0].pageY - t.touches[1].pageY,
                h = Math.sqrt(r * r + a * a);
            ht.set(0, h), ct.subVectors(ht, lt), ct.y > 0 ? l(n()) : ct.y < 0 && s(n()), lt.copy(ht), z.update()
        }

        function M(t) {}

        function T(t) {
            if (N = (new Date).getTime(), !1 !== z.enabled) {
                switch (t.preventDefault(), t.button) {
                    case z.mouseButtons.ORBIT:
                        if (!1 === z.enableRotate) return;
                        h(t), j = H.ROTATE;
                        break;
                    case z.mouseButtons.ZOOM:
                        if (!1 === z.enableZoom) return;
                        p(t), j = H.DOLLY;
                        break;
                    case z.mouseButtons.PAN:
                        if (!1 === z.enablePan) return;
                        f(t), j = H.PAN
                }
                j !== H.NONE && (document.addEventListener("mouseup", E, !1), z.dispatchEvent(G))
            }
        }

        function S(t) {
            if (i.emit("onMouseMove"), !1 !== z.enabled) switch (t.preventDefault(), j) {
                case H.ROTATE:
                    if (!1 === z.enableRotate) return;
                    d(t);
                    break;
                case H.DOLLY:
                    if (!1 === z.enableZoom) return;
                    m(t);
                    break;
                case H.PAN:
                    if (!1 === z.enablePan) return;
                    g(t);
                    break;
                default:
                    C(t)
            }
        }

        function E(t) {
            i.emit("onMouseUp"), k = (new Date).getTime(), !1 !== z.enabled && (v(t), document.removeEventListener("mouseup", E, !1), z.dispatchEvent(V), j = H.NONE, k - N < 200 && (F = !0))
        }

        function C(t) {
            var e = function () {
                    var t = 0,
                        e = window.screen,
                        i = navigator.userAgent.toLowerCase();
                    return void 0 !== window.devicePixelRatio ? t = window.devicePixelRatio : ~i.indexOf("msie") ? e.deviceXDPI && e.logicalXDPI && (t = e.deviceXDPI / e.logicalXDPI) : void 0 !== window.outerWidth && void 0 !== window.innerWidth && (t = window.outerWidth / window.innerWidth), t && (t = Math.round(100 * t)), t
                }(),
                r = z.domElement.width,
                n = z.domElement.height;
            t.preventDefault();
            var o = new c.Vector2;
            o.x = e * t.offsetX / r * 2 / 100 - 1, o.y = -e * t.offsetY / n * 2 / 100 + 1, new c.Vector3(o.x, o.y, 1).unproject(z.object);
            var a = new c.Raycaster;
            a.setFromCamera(o, z.object);
            var s = a.intersectObjects(z.floorModels, !0);
            if (s[0]) {
                var l = (0, u.mercatoToCoordinates)({
                    mercato: [s[0].point.x, s[0].point.z],
                    mapCenter: s[0].object.info.properties.mapCenter
                });
                i.emit("move", {
                    type: s[0].object.info.drawType.type,
                    position: {
                        x: s[0].point.x,
                        y: "Sprite" === s[0].object.type ? s[0].object.getWorldPosition().y : s[0].point.y,
                        z: s[0].point.z
                    },
                    lnglat: l,
                    target: s[0].object
                })
            }
        }

        function P(t) {
            var e = function () {
                var t = 0,
                    e = window.screen,
                    i = navigator.userAgent.toLowerCase();
                return void 0 !== window.devicePixelRatio ? t = window.devicePixelRatio : ~i.indexOf("msie") ? e.deviceXDPI && e.logicalXDPI && (t = e.deviceXDPI / e.logicalXDPI) : void 0 !== window.outerWidth && void 0 !== window.innerWidth && (t = window.outerWidth / window.innerWidth), t && (t = Math.round(100 * t)), t
            }();
            if (F) {
                var r = z.domElement.width,
                    n = z.domElement.height;
                t.preventDefault();
                var o = new c.Vector2;
                o.x = e * t.offsetX / r * 2 / 100 - 1, o.y = -e * t.offsetY / n * 2 / 100 + 1;
                var a = new c.Raycaster;
                a.setFromCamera(o, z.object);
                var s = a.intersectObjects(z.clickModels, !0);
                if (console.warn(s[0]), s[0]) {
                    var l = (0, u.mercatoToCoordinates)({
                        mercato: [s[0].point.x, s[0].point.z],
                        mapCenter: s[0].object.info.properties.mapCenter
                    });
                    console.warn(s[0].object.info.properties.name), i.emit("click", {
                        type: s[0].object.info.drawType.type,
                        position: {
                            x: s[0].point.x,
                            y: "Sprite" === s[0].object.type ? s[0].object.getWorldPosition().y : s[0].point.y,
                            z: s[0].point.z
                        },
                        lnglat: l,
                        target: s[0].object
                    })
                }
                F = !0
            }
        }

        function L(t) {
            i.emit("onMouseWheel"), !1 === z.enabled || !1 === z.enableZoom || j !== H.NONE && j !== H.ROTATE || (t.preventDefault(), t.stopPropagation(), y(t), z.dispatchEvent(G), z.dispatchEvent(V))
        }

        function D(t) {
            !1 !== z.enabled && !1 !== z.enableKeys && !1 !== z.enablePan && A(t)
        }

        function R(t) {
            if (!1 !== z.enabled) {
                switch (t.touches.length) {
                    case 1:
                        if (!1 === z.enablePan) return;
                        x(t), j = H.TOUCH_PAN;
                        break;
                    case 2:
                        if (!1 === z.enableZoom) return;
                        if (!1 === z.enableRotate) return;
                        _(t), j = H.TOUCH_ROTATE_DOLLY;
                        break;
                    default:
                        j = H.NONE
                }
                j !== H.NONE && z.dispatchEvent(G)
            }
        }

        function I(t) {
            if (!1 !== z.enabled) switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
                case 1:
                    if (!1 === z.enablePan) return;
                    if (j !== H.TOUCH_PAN) return;
                    w(t);
                    break;
                case 2:
                    if (!1 === z.enableZoom) return;
                    if (!1 === z.enableRotate) return;
                    j === H.TOUCH_ROTATE_DOLLY && b(t);
                    break;
                default:
                    j = H.NONE
            }
        }

        function O(t) {
            !1 !== z.enabled && (M(t), z.dispatchEvent(V), j = H.NONE)
        }

        function B(t) {
            !1 !== z.enabled && t.preventDefault()
        }
        this.object = t, this.domElement = void 0 !== e ? e : document, this.enabled = !0, this.target = new c.Vector3, this.minDistance = 10, this.maxDistance = 2e3, this.minZoom = .3, this.maxZoom = 100, this.minPolarAngle = 0, this.maxPolarAngle = 3 * Math.PI / 8, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        }, this.mouseButtons = {
            ORBIT: c.MOUSE.LEFT,
            ZOOM: c.MOUSE.MIDDLE,
            PAN: c.MOUSE.RIGHT
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._2d = !1, this.clickModels = [], this.floorModels = [], this.addIntoClickModels = function (t) {
            this.clickModels = this.clickModels.concat(t)
        }, this.clearClickModels = function () {
            this.clickModels.splice(0, this.clickModels.length)
        }, this.addIntoFloorModels = function (t) {
            this.floorModels = this.floorModels.concat(t)
        }, this.clearFloorModels = function () {
            this.floorModels.splice(0, this.floorModels.length)
        };
        var N, k, F = !0;
        this.getPolarAngle = function () {
            return Y.phi
        }, this.getAzimuthalAngle = function () {
            return Y.theta
        }, this.saveState = function () {
            z.target0.copy(z.target), z.position0.copy(z.object.position), z.zoom0 = z.object.zoom
        }, this.reset = function () {
            z.target.copy(z.target0), z.object.position.copy(z.position0), z.object.zoom = z.zoom0, z.object.updateProjectionMatrix(), z.dispatchEvent(U), z.update(), j = H.NONE
        }, this.update = function () {
            var e = new c.Vector3,
                n = (new c.Quaternion).setFromUnitVectors(t.up, new c.Vector3(0, 1, 0)),
                a = n.clone().inverse(),
                s = new c.Vector3,
                l = new c.Quaternion;
            return function () {
                var t = z.object.position;
                e.copy(t).sub(z.target), e.applyQuaternion(n), Y.setFromVector3(e), z.autoRotate && j === H.NONE && o(r()), Y.theta += X.theta, Y.phi += X.phi, this._2d && Y.phi > 0 && (Y.phi = 0), Y.theta = Math.max(z.minAzimuthAngle, Math.min(z.maxAzimuthAngle, Y.theta)), Y.phi = Math.max(z.minPolarAngle, Math.min(z.maxPolarAngle, Y.phi));
                var h = void 0;
                if (z.domElement.parentNode && (h = z.domElement.parentNode.getElementsByClassName("OvuRouteMapCompassp")), h)
                    if (Y.phi) {
                        if (Math.cos(Y.phi))
                            for (var c = Math.atan(Math.sin(Y.phi) * Math.sin(Y.theta) / Math.cos(Y.phi)), u = Math.atan(Math.sin(Y.phi) * Math.cos(Y.theta) / Math.cos(Y.phi)), p = 0; p < h.length; p++) h[p].style.transform = "rotateZ(" + 180 * Y.theta / Math.PI + "deg) rotateX(" + 180 * u / Math.PI + "deg) rotateY(" + 180 * -c / Math.PI + "deg)"
                    } else
                        for (var f = 0; f < h.length; f++) h[f].style.transform = "rotateZ(" + 180 * Y.theta / Math.PI + "deg)";
                return Y.makeSafe(), Y.radius *= Q, Y.radius = Math.max(z.minDistance, Math.min(z.maxDistance, Y.radius)), z.target.add(J), e.setFromSpherical(Y), e.applyQuaternion(a), t.copy(z.target).add(e), z.object.lookAt(z.target), !0 === z.enableDamping ? (X.theta *= 1 - z.dampingFactor, X.phi *= 1 - z.dampingFactor) : X.set(0, 0, 0), Q = 1, J.set(0, 0, 0), !!(q || s.distanceToSquared(z.object.position) > W || 8 * (1 - l.dot(z.object.quaternion)) > W) && (z.dispatchEvent(U), s.copy(z.object.position), l.copy(z.object.quaternion), q = !1, i.emit("onDetect"), i.emit("controlMap"), !0)
            }
        }(), this.dispose = function () {
            z.domElement.removeEventListener("contextmenu", B, !1), z.domElement.removeEventListener("mousedown", T, !1), z.domElement.removeEventListener("wheel", L, !1), z.domElement.removeEventListener("touchstart", R, !1), z.domElement.removeEventListener("touchend", O, !1), z.domElement.removeEventListener("touchmove", I, !1), z.domElement.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", E, !1), window.removeEventListener("keydown", D, !1)
        };
        var z = this,
            U = {
                type: "change"
            },
            G = {
                type: "start"
            },
            V = {
                type: "end"
            },
            H = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5,
                TOUCH_ROTATE_DOLLY: 6
            },
            j = H.NONE,
            W = 1e-6,
            Y = new c.Spherical,
            X = new c.Spherical;
        this.spherical = Y, this.sphericalDelta = X;
        var Q = 1,
            J = new c.Vector3,
            q = !1,
            Z = new c.Vector2,
            K = new c.Vector2,
            $ = new c.Vector2,
            tt = new c.Vector2,
            et = new c.Vector2,
            it = new c.Vector2,
            rt = new c.Vector2,
            nt = 0,
            ot = new c.Vector2,
            at = new c.Vector2,
            st = new c.Vector2,
            lt = new c.Vector2,
            ht = new c.Vector2,
            ct = new c.Vector2,
            ut = function () {
                var t = new c.Vector3;
                return function (e, i) {
                    t.setFromMatrixColumn(i, 0), t.multiplyScalar(-e), J.add(t)
                }
            }(),
            pt = function () {
                var t = new c.Vector3;
                return function (e, i) {
                    t.setFromMatrixColumn(i, 1), t.multiplyScalar(e), J.add(t)
                }
            }(),
            ft = function () {
                var t = new c.Vector3;
                return function (e, i) {
                    var r = z.domElement === document ? z.domElement.body : z.domElement;
                    if (z.object.isPerspectiveCamera) {
                        var n = z.object.position;
                        t.copy(n).sub(z.target);
                        var o = t.length();
                        o *= Math.tan(z.object.fov / 2 * Math.PI / 180), ut(2 * e * o / r.clientHeight, z.object.matrix), pt(2 * i * o / r.clientHeight, z.object.matrix)
                    } else z.object.isOrthographicCamera ? (ut(e * (z.object.right - z.object.left) / z.object.zoom / r.clientWidth, z.object.matrix), pt(i * (z.object.top - z.object.bottom) / z.object.zoom / r.clientHeight, z.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), z.enablePan = !1)
                }
            }();
        z.domElement.addEventListener("contextmenu", B, !1), z.domElement.addEventListener("click", P, !1), z.domElement.addEventListener("mousedown", T, !1), z.domElement.addEventListener("wheel", L, !1), z.domElement.addEventListener("touchstart", R, !1), z.domElement.addEventListener("touchend", O, !1), z.domElement.addEventListener("touchmove", I, !1), z.domElement.addEventListener("mousemove", S, !1), window.addEventListener("keydown", D, !1), this.update()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var o = i(82),
        a = r(o),
        s = i(41),
        l = r(s),
        h = i(4),
        c = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(h),
        u = i(21),
        p = i(10);
    r(p);
    n.prototype = (0, l.default)(c.EventDispatcher.prototype), n.prototype.constructor = n, (0, a.default)(n.prototype, {
        center: {
            get: function () {
                return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
            }
        },
        noZoom: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !t
            }
        },
        noRotate: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !t
            }
        },
        noPan: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !t
            }
        },
        noKeys: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !t
            }
        },
        staticMoving: {
            get: function () {
                return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !t
            }
        },
        dynamicDampingFactor: {
            get: function () {
                return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
            },
            set: function (t) {
                console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = t
            }
        }
    }), e.default = n
}, function (t, e, i) {
    i(168), t.exports = i(0).Number.parseFloat
}, function (t, e, i) {
    var r = i(1),
        n = i(169);
    r(r.S + r.F * (Number.parseFloat != n), "Number", {
        parseFloat: n
    })
}, function (t, e, i) {
    var r = i(5).parseFloat,
        n = i(81).trim;
    t.exports = 1 / r(i(64) + "-0") != -1 / 0 ? function (t) {
        var e = n(String(t), 3),
            i = r(e);
        return 0 === i && "-" == e.charAt(0) ? -0 : i
    } : r
}, function (t, e, i) {
    "use strict";
    var r = i(41),
        n = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r),
        o = i(4);
    (function () {
        function i() {
            this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this.geometry = new o.BufferGeometry, this.widthCallback = null
        }

        function r(t, e, i, r, n) {
            var o;
            if (t = t.subarray || t.slice ? t : t.buffer, i = i.subarray || i.slice ? i : i.buffer, t = e ? t.subarray ? t.subarray(e, n && e + n) : t.slice(e, n && e + n) : t, i.set) i.set(t, r);
            else
                for (o = 0; o < t.length; o++) i[o + r] = t[o];
            return i
        }

        function a(t) {
            function e(t, e) {
                return void 0 === t ? e : t
            }
            var i = ["precision highp float;", "", "attribute vec3 position;", "attribute vec3 previous;", "attribute vec3 next;", "attribute float side;", "attribute float width;", "attribute vec2 uv;", "attribute float counters;", "", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "uniform vec2 resolution;", "uniform float lineWidth;", "uniform vec3 color;", "uniform float opacity;", "uniform float near;", "uniform float far;", "uniform float sizeAttenuation;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "vec2 fix( vec4 i, float aspect ) {", "", "    vec2 res = i.xy / i.w;", "    res.x *= aspect;", "\t vCounters = counters;", "    return res;", "", "}", "", "void main() {", "", "    float aspect = resolution.x / resolution.y;", "\t float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);", "", "    vColor = vec4( color, opacity );", "    vUV = uv;", "", "    mat4 m = projectionMatrix * modelViewMatrix;", "    vec4 finalPosition = m * vec4( position, 1.0 );", "    vec4 prevPos = m * vec4( previous, 1.0 );", "    vec4 nextPos = m * vec4( next, 1.0 );", "", "    vec2 currentP = fix( finalPosition, aspect );", "    vec2 prevP = fix( prevPos, aspect );", "    vec2 nextP = fix( nextPos, aspect );", "", "\t float pixelWidth = finalPosition.w * pixelWidthRatio;", "    float w = 1.8 * pixelWidth * lineWidth * width;", "", "    if( sizeAttenuation == 1. ) {", "        w = 1.8 * lineWidth * width;", "    }", "", "    vec2 dir;", "    if( nextP == currentP ) dir = normalize( currentP - prevP );", "    else if( prevP == currentP ) dir = normalize( nextP - currentP );", "    else {", "        vec2 dir1 = normalize( currentP - prevP );", "        vec2 dir2 = normalize( nextP - currentP );", "        dir = normalize( dir1 + dir2 );", "", "        vec2 perp = vec2( -dir1.y, dir1.x );", "        vec2 miter = vec2( -dir.y, dir.x );", "        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );", "", "    }", "", "    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;", "    vec2 normal = vec2( -dir.y, dir.x );", "    normal.x /= aspect;", "    normal *= .5 * w;", "", "    vec4 offset = vec4( normal * side, 0.0, 1.0 );", "    finalPosition.xy += offset.xy;", "", "    gl_Position = finalPosition;", "", "}"],
                r = ["#extension GL_OES_standard_derivatives : enable", "precision mediump float;", "", "uniform sampler2D map;", "uniform sampler2D alphaMap;", "uniform float useMap;", "uniform float useAlphaMap;", "uniform float useDash;", "uniform vec2 dashArray;", "uniform float visibility;", "uniform float alphaTest;", "uniform vec2 repeat;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "void main() {", "", "    vec4 c = vColor;", "    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );", "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;", "\t if( c.a < alphaTest ) discard;", "\t if( useDash == 1. ){", "\t \t ", "\t }", "    gl_FragColor = c;", "\t gl_FragColor.a *= step(vCounters,visibility);", "}"];
            o.Material.call(this), t = t || {}, this.lineWidth = e(t.lineWidth, 1), this.map = e(t.map, null), this.useMap = e(t.useMap, 0), this.alphaMap = e(t.alphaMap, null), this.useAlphaMap = e(t.useAlphaMap, 0), this.color = e(t.color, new o.Color(16777215)), this.opacity = e(t.opacity, 1), this.resolution = e(t.resolution, new o.Vector2(1, 1)), this.sizeAttenuation = e(t.sizeAttenuation, 1), this.near = e(t.near, 1), this.far = e(t.far, 1), this.dashArray = e(t.dashArray, []), this.useDash = this.dashArray !== [] ? 1 : 0, this.visibility = e(t.visibility, 1), this.alphaTest = e(t.alphaTest, 0), this.repeat = e(t.repeat, new o.Vector2(1, 1));
            var n = new o.RawShaderMaterial({
                uniforms: {
                    lineWidth: {
                        type: "f",
                        value: this.lineWidth
                    },
                    map: {
                        type: "t",
                        value: this.map
                    },
                    useMap: {
                        type: "f",
                        value: this.useMap
                    },
                    alphaMap: {
                        type: "t",
                        value: this.alphaMap
                    },
                    useAlphaMap: {
                        type: "f",
                        value: this.useAlphaMap
                    },
                    color: {
                        type: "c",
                        value: this.color
                    },
                    opacity: {
                        type: "f",
                        value: this.opacity
                    },
                    resolution: {
                        type: "v2",
                        value: this.resolution
                    },
                    sizeAttenuation: {
                        type: "f",
                        value: this.sizeAttenuation
                    },
                    near: {
                        type: "f",
                        value: this.near
                    },
                    far: {
                        type: "f",
                        value: this.far
                    },
                    dashArray: {
                        type: "v2",
                        value: new o.Vector2(this.dashArray[0], this.dashArray[1])
                    },
                    useDash: {
                        type: "f",
                        value: this.useDash
                    },
                    visibility: {
                        type: "f",
                        value: this.visibility
                    },
                    alphaTest: {
                        type: "f",
                        value: this.alphaTest
                    },
                    repeat: {
                        type: "v2",
                        value: this.repeat
                    }
                },
                vertexShader: i.join("\r\n"),
                fragmentShader: r.join("\r\n")
            });
            return delete t.lineWidth, delete t.map, delete t.useMap, delete t.alphaMap, delete t.useAlphaMap, delete t.color, delete t.opacity, delete t.resolution, delete t.sizeAttenuation, delete t.near, delete t.far, delete t.dashArray, delete t.visibility, delete t.alphaTest, delete t.repeat, n.type = "MeshLineMaterial", n.setValues(t), n
        }
        if (!o) throw new Error("MeshLine requires three.js");
        i.prototype.setGeometry = function (t, e) {
            if (this.widthCallback = e, this.positions = [], this.counters = [], t instanceof o.Geometry)
                for (var i = 0; i < t.vertices.length; i++) {
                    var r = t.vertices[i],
                        e = i / t.vertices.length;
                    this.positions.push(r.x, r.y, r.z), this.positions.push(r.x, r.y, r.z), this.counters.push(e), this.counters.push(e)
                }
            if (o.BufferGeometry, t instanceof Float32Array || t instanceof Array)
                for (var i = 0; i < t.length; i += 3) {
                    var e = i / t.length;
                    this.positions.push(t[i], t[i + 1], t[i + 2]), this.positions.push(t[i], t[i + 1], t[i + 2]), this.counters.push(e), this.counters.push(e)
                }
            this.process()
        }, i.prototype.compareV3 = function (t, e) {
            var i = 6 * t,
                r = 6 * e;
            return this.positions[i] === this.positions[r] && this.positions[i + 1] === this.positions[r + 1] && this.positions[i + 2] === this.positions[r + 2]
        }, i.prototype.copyV3 = function (t) {
            var e = 6 * t;
            return [this.positions[e], this.positions[e + 1], this.positions[e + 2]]
        }, i.prototype.process = function () {
            var t = this.positions.length / 6;
            this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];
            for (var e = 0; e < t; e++) this.side.push(1), this.side.push(-1);
            for (var i, e = 0; e < t; e++) i = this.widthCallback ? this.widthCallback(e / (t - 1)) : 1, this.width.push(i), this.width.push(i);
            for (var e = 0; e < t; e++) this.uvs.push(e / (t - 1), 0), this.uvs.push(e / (t - 1), 1);
            var r;
            r = this.compareV3(0, t - 1) ? this.copyV3(t - 2) : this.copyV3(0), this.previous.push(r[0], r[1], r[2]), this.previous.push(r[0], r[1], r[2]);
            for (var e = 0; e < t - 1; e++) r = this.copyV3(e), this.previous.push(r[0], r[1], r[2]), this.previous.push(r[0], r[1], r[2]);
            for (var e = 1; e < t; e++) r = this.copyV3(e), this.next.push(r[0], r[1], r[2]), this.next.push(r[0], r[1], r[2]);
            r = this.compareV3(t - 1, 0) ? this.copyV3(1) : this.copyV3(t - 1), this.next.push(r[0], r[1], r[2]), this.next.push(r[0], r[1], r[2]);
            for (var e = 0; e < t - 1; e++) {
                var n = 2 * e;
                this.indices_array.push(n, n + 1, n + 2), this.indices_array.push(n + 2, n + 1, n + 3)
            }
            this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position.needsUpdate = !0, this.attributes.previous.copyArray(new Float32Array(this.previous)), this.attributes.previous.needsUpdate = !0, this.attributes.next.copyArray(new Float32Array(this.next)), this.attributes.next.needsUpdate = !0, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes.side.needsUpdate = !0, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width.needsUpdate = !0, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = !0, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = !0) : this.attributes = {
                position: new o.BufferAttribute(new Float32Array(this.positions), 3),
                previous: new o.BufferAttribute(new Float32Array(this.previous), 3),
                next: new o.BufferAttribute(new Float32Array(this.next), 3),
                side: new o.BufferAttribute(new Float32Array(this.side), 1),
                width: new o.BufferAttribute(new Float32Array(this.width), 1),
                uv: new o.BufferAttribute(new Float32Array(this.uvs), 2),
                index: new o.BufferAttribute(new Uint16Array(this.indices_array), 1),
                counters: new o.BufferAttribute(new Float32Array(this.counters), 1)
            }, this.geometry.addAttribute("position", this.attributes.position), this.geometry.addAttribute("previous", this.attributes.previous), this.geometry.addAttribute("next", this.attributes.next), this.geometry.addAttribute("side", this.attributes.side), this.geometry.addAttribute("width", this.attributes.width), this.geometry.addAttribute("uv", this.attributes.uv), this.geometry.addAttribute("counters", this.attributes.counters), this.geometry.setIndex(this.attributes.index)
        }, i.prototype.advance = function (t) {
            var e = this.attributes.position.array,
                i = this.attributes.previous.array,
                n = this.attributes.next.array,
                o = e.length;
            r(e, 0, i, 0, o), r(e, 6, e, 0, o - 6), e[o - 6] = t.x, e[o - 5] = t.y, e[o - 4] = t.z, e[o - 3] = t.x, e[o - 2] = t.y, e[o - 1] = t.z, r(e, 6, n, 0, o - 6), n[o - 6] = t.x, n[o - 5] = t.y, n[o - 4] = t.z, n[o - 3] = t.x, n[o - 2] = t.y, n[o - 1] = t.z, this.attributes.position.needsUpdate = !0, this.attributes.previous.needsUpdate = !0, this.attributes.next.needsUpdate = !0
        }, a.prototype = (0, n.default)(o.Material.prototype), a.prototype.constructor = a, a.prototype.copy = function (t) {
            return o.Material.prototype.copy.call(this, t), this.lineWidth = t.lineWidth, this.map = t.map, this.useMap = t.useMap, this.alphaMap = t.alphaMap, this.useAlphaMap = t.useAlphaMap, this.color.copy(t.color), this.opacity = t.opacity, this.resolution.copy(t.resolution), this.sizeAttenuation = t.sizeAttenuation, this.near = t.near, this.far = t.far, this.dashArray.copy(t.dashArray), this.useDash = t.useDash, this.visibility = t.visibility, this.alphaTest = t.alphaTest, this.repeat.copy(t.repeat), this
        }, void 0 !== t && t.exports && (e = t.exports = {
            MeshLine: i,
            MeshLineMaterial: a
        }), e.MeshLine = i, e.MeshLineMaterial = a
    }).call(void 0)
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(80),
        o = r(n),
        a = i(2),
        s = r(a),
        l = i(3),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = function () {
            function t(e) {
                (0, s.default)(this, t), this.dom = e, this.domWidth = (0, o.default)(this.dom.offsetWidth), this.domHeight = (0, o.default)(this.dom.offsetHeight), this.perspectiveCamera = this.createPerspectiveCamera(75, this.domWidth, this.domHeight, 10, 2e4), this.orthographicCamera = this.createOrthographicCamera(-this.domWidth / 2, this.domWidth / 2, this.domHeight / 2, -this.domHeight / 2, 1, 1e4)
            }
            return (0, h.default)(t, [{
                key: "createPerspectiveCamera",
                value: function (t, e, i, r, n) {
                    return new u.PerspectiveCamera(t, e / i, r, n)
                }
            }, {
                key: "createOrthographicCamera",
                value: function (t, e, i, r, n, o) {
                    return new u.OrthographicCamera(t, e, i, r, n, o)
                }
            }]), t
        }();
    e.default = p
}, function (t, e, i) {
    "use strict";

    function r(t, e, i, r) {
        this.tl = [t || 0, e || 0], this.br = [i || 0, r || 0]
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), r.prototype.isCollide = function (t) {
        return !(t.br[0] < this.tl[0] || t.tl[0] > this.br[0] || t.br[1] < this.tl[1] || t.tl[1] > this.br[1])
    }, e.default = r
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(39),
        o = r(n),
        a = i(9),
        s = r(a),
        l = i(174),
        h = r(l),
        c = i(177),
        u = r(c),
        p = i(2),
        f = r(p),
        d = i(3),
        m = r(d),
        g = i(10),
        v = r(g),
        y = i(43),
        A = r(y),
        x = i(21),
        _ = i(186),
        w = r(_),
        b = i(66),
        M = r(b),
        T = i(193),
        S = r(T),
        E = i(194),
        C = r(E),
        P = i(85),
        L = r(P),
        D = function () {
            function t(e, i) {
                (0, f.default)(this, t), this.object = e, this.maps = v.default.cloneOwn(e.mapList), this.event = i, this.commonTheme = [], this.mapObj = {}, this.mapsObj = [], this.floor = 0, this.center = [], this.floors = [], this.loadedMap = [], this.baseThemeUrl = "", this.extremum = {}, this.startTime = (new Date).getTime()
            }
            return (0, m.default)(t, [{
                key: "consTime",
                value: function (t) {
                    var e = (new Date).getTime();
                    console.warn(t + "......" + (e - this.startTime)), this.startTime = e
                }
            }, {
                key: "getData",
                value: function () {
                    function t() {
                        return e.apply(this, arguments)
                    }
                    var e = (0, u.default)(h.default.mark(function t() {
                        var e, i, r = this;
                        return h.default.wrap(function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    if (this.maps && this.maps instanceof Array || v.default.log("map list format error"), e = [], i = [], this.floor = 0, this.floors.length = 0, this.mapObj = {}, this.mapsObj.length = 0, this.extremum = {}, this.loadedMap.length = 0, e = this.getFloor(), this.object.mapList.forEach(function (t) {
                                            return r.floors.push(t.name)
                                        }), !this.object.themeUrl || !v.default.isEmpty(this.commonTheme)) {
                                        t.next = 17;
                                        break
                                    }
                                    return this.baseThemeUrl = this.getBaseThemeUrl(this.object.themeUrl), t.t0 = v.default, t.next = 15, this.getCommonTheme();
                                case 15:
                                    t.t1 = t.sent, this.commonTheme = t.t0.isJSON.call(t.t0, t.t1);
                                case 17:
                                    return t.next = 19, this.asyncMap(e);
                                case 19:
                                    return i = t.sent, t.abrupt("return", i);
                                case 21:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return t
                }()
            }, {
                key: "getFloor",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.maps,
                        i = 0,
                        r = [];
                    if (i = e.findIndex(function (e) {
                            return e.name == t.object.defaultFloor
                        }), i = -1 === i ? 0 : i, this.object.showAllFloor) {
                        if (e.length <= this.object.count) return e.length = 0, this.object.mapList;
                        r = e.splice(i, this.object.count), r.length < this.object.count && e.splice(-1, this.object.count - r.length).forEach(function (t) {
                            return r.unshift(t)
                        })
                    } else r = e.splice(i, 1);
                    return r
                }
            }, {
                key: "getCommonTheme",
                value: function () {
                    function t() {
                        return e.apply(this, arguments)
                    }
                    var e = (0, u.default)(h.default.mark(function t() {
                        return h.default.wrap(function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, A.default.get(this.object.themeUrl);
                                case 2:
                                    return t.abrupt("return", t.sent);
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return t
                }()
            }, {
                key: "asyncMap",
                value: function () {
                    function t(t) {
                        return e.apply(this, arguments)
                    }
                    var e = (0, u.default)(h.default.mark(function t(e) {
                        var i, r, n, o, a, s, l, c;
                        return h.default.wrap(function (t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    i = [], r = 0;
                                case 2:
                                    if (!(n = e[r])) {
                                        t.next = 31;
                                        break
                                    }
                                    if (o = void 0, a = void 0, s = void 0, l = void 0, c = void 0, !n.mapUrl || !n.name) {
                                        t.next = 26;
                                        break
                                    }
                                    return t.t0 = v.default, t.next = 8, A.default.get(n.mapUrl);
                                case 8:
                                    if (t.t1 = t.sent, o = t.t0.isJSON.call(t.t0, t.t1), !n.themeUrl) {
                                        t.next = 19;
                                        break
                                    }
                                    return t.t2 = v.default, t.next = 14, A.default.get(n.themeUrl);
                                case 14:
                                    t.t3 = t.sent, a = t.t2.isJSON.call(t.t2, t.t3), c = this.getBaseThemeUrl(n.themeUrl), t.next = 20;
                                    break;
                                case 19:
                                    v.default.isEmpty(this.commonTheme) || (a = this.commonTheme, c = this.baseThemeUrl);
                                case 20:
                                    n.other && (s = n.other), l = n.name, n = this.floor + 1, this.floor = n, t.next = 27;
                                    break;
                                case 26:
                                    v.default.log("map list format error");
                                case 27:
                                    i.push({
                                        mapJson: o,
                                        themeJson: a,
                                        otherJson: s,
                                        name: l,
                                        floor: n,
                                        baseUrl: c
                                    });
                                case 28:
                                    r++, t.next = 2;
                                    break;
                                case 31:
                                    return t.abrupt("return", i);
                                case 32:
                                case "end":
                                    return t.stop()
                            }
                        }, t, this)
                    }));
                    return t
                }()
            }, {
                key: "mapDataHandle",
                value: function (t) {
                    for (var e, i = 0; e = t[i]; i++) {
                        var r = this.getCenter(e.mapJson);
                        this.center = (0, x.coordinatesToMercato)({
                            coordinates: r
                        });
                        var n = this.object.defaultPriority.slice(0),
                            o = n.indexOf("other"),
                            a = n.indexOf("theme");
                        n.indexOf("map");
                        e.mapJson && (e.themeJson ? e.otherJson ? this.mapBaseHandle(e)[n[0] + "Handle"]()[n[1] + "Handle"]()[n[2] + "Handle"]() : (n.splice(o, 1), this.mapBaseHandle(e)[n[0] + "Handle"]()[n[1] + "Handle"]()) : e.otherJson ? (n.splice(a, 1), this.mapBaseHandle(e)[n[0] + "Handle"]()[n[1] + "Handle"]()) : this.mapBaseHandle(e).mapHandle()), this.mapObj = C.default.computeYH(this.mapObj, this.object.defaultGap), this.extremum[this.mapObj.name] = this.mapObj.extremum, this.event.emit("loadComplete", this.mapObj), this.mapObj.coordinates = r;
                        var l = new L.default(this.mapObj, this.object);
                        l.floor = i + 1, this.mapsObj.push(l);
                        var h = {};
                        h.Brief = "", h.ImageLayer = "", h.Area = "", h.Name = this.mapObj.name, h.Name_en = this.mapObj.name, h._id = 1, h._xLon = this.mapObj.coordinates[0], h._yLat = this.mapObj.coordinates[1];
                        for (var c = [], u = [], p = this.mapObj.geoJson, i = 0; i < p.length; i++) {
                            var f = p[i];
                            if (0 == f.id) h.Outline = this.changeNum(f.line), h.fillColor = f.properties.fillcolor, h.strokeColor = f.properties.strokecolor, h.alpha = f.properties.alpha, h.High = f.properties.height;
                            else {
                                var d = {};
                                if (f.properties.logo) {
                                    var m = {};
                                    m.Brief = "", m.Name = "", m.Name_en = "", m.Outline = this.changeNum([
                                        [f.center]
                                    ]), m.Center = this.changeCenter(f.center), m._id = "", m.Type = "", m.High = f.properties.height, m.logo = f.properties.logo, u.push(m)
                                }
                                d.Brand = "", d.Type = f.drawType.type, d._id = f.properties.uuid, d.ShopNo = "", d.Category2 = f.sType, d.dianping_id = "", d.Brief = "", d.Center = this.changeCenter(f.center), d.Category = f.sType, 0 == f.line[0][0].length && f.properties.name ? (console.log(f), d.Outline = this.changeNum([
                                    [
                                        [f.center[0] - 1, f.center[1] - 1, f.center[0], f.center[1], f.center[0] + 1, f.center[1] + 1]
                                    ]
                                ]), d.isName = 1) : (d.Outline = this.changeNum(f.line), d.isName = 0), "" != f.properties.name && "" != f.properties.name || console.log(f.properties.name, f.center), d.Name = f.properties.name, d.Name_en = f.properties.name, d.Area = "", d.High = f.properties.height, f.properties.workPosition || f.properties.workPosition ? (d.fillColor = "#F8F8FF", d.strokeColor = "#AAAAAA", d.opacity = 1, d.isOnclick = 0) : (d.fillColor = "#F6F6F6", d.strokeColor = "#D7D7D7", d.opacity = .3, d.isOnclick = 0), d.alpha = f.properties.alpha, d.workPosition = f.properties.workPosition, d.houseNo = f.properties.houseNo, d.uuid = f.properties.uuid, d.BrandShop = "", c.push(d)
                            }
                        }
                        h.PubPoint = u, h.FuncAreas = c, this.loadedMap.push(this.mapObj.name)
                    }
                }
            }, {
                key: "changeNum",
                value: function (t) {
                    for (var e = [
                            [
                                []
                            ]
                        ], i = t[0][0], r = 0; r < i.length; r += 2) e[0][0].push(i[r + 1], i[r]);
                    return e
                }
            }, {
                key: "changeCenter",
                value: function (t) {
                    var e = [];
                    return e.push(t[1], t[0]), e
                }
            }, {
                key: "getCenter",
                value: function (t) {
                    var e = t.features.find(function (t) {
                        return 1 * t.properties.id == 0
                    });
                    return e && "Point" === e.geometry.type || v.default.log("map center point type errors"), e.geometry.coordinates
                }
            }, {
                key: "mapBaseHandle",
                value: function (t) {
                    var e = this,
                        i = [],
                        r = void 0,
                        n = void 0,
                        a = void 0,
                        s = 0;
                    this.mapObj = t, this.mapObj.mapCenter = this.center, this.mapObj.mapJson.features.some(function (t) {
                        if ("Point" === t.geometry.type) {
                            if (!(r = (0, M.default)(t.properties.sType))) return console.error('sType "' + t.properties.sType + '" is error'), !1;
                            a = v.default.cloneOwn(S.default[r.type].config), n = a.find(function (e) {
                                return 1 * e.sType == 1 * t.properties.sType
                            }), n || (n = S.default[r.type].default);
                            var s = (0, x.coordinatesToMercato)({
                                coordinates: t.geometry.coordinates,
                                mapCenter: e.center
                            });
                            i[1 * t.properties.id] = {
                                id: 1 * t.properties.id,
                                lnglat: t.geometry.coordinates,
                                center: s,
                                sType: t.properties.sType,
                                drawType: r,
                                layer: r.type + "Group",
                                name: n.name,
                                floor: e.mapObj.floor,
                                floorName: e.mapObj.name
                            }, delete n.sType, delete n.name, i[1 * t.properties.id].properties = (0, o.default)({}, n, t.properties, {
                                mapCenter: e.center
                            })
                        } else "LineString" === t.geometry.type && i[1 * t.properties.id - 1e3] && (i[1 * t.properties.id - 1e3].line = (0, x.coordinatesToMercato)({
                            coordinates: t.geometry.coordinates,
                            mapCenter: e.center
                        }))
                    }), this.mapObj.geoJson = [];
                    for (var l in i) i.hasOwnProperty(l) && (this.mapObj.geoJson[s] = i[l], s++);
                    return this.mapObj.geoJson.sort(function (t, e) {
                        return t.id - e.id
                    }), this.mapObj.extremum = v.default.getExtremum(t.geoJson[0].line), this
                }
            }, {
                key: "mapHandle",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.mapObj;
                    if (!v.default.isEmpty(e.geoJson)) {
                        var i = void 0;
                        e.mapJson.features.some(function (r) {
                            if (-1 === (i = e.geoJson.findIndex(function (t) {
                                    return 1 * r.properties.id == 1 * t.id
                                }))) return !0;
                            r.properties.logo && (r.properties.logo = t.baseThemeUrl + r.properties.logo), e.geoJson[i].properties = (0, o.default)({}, e.geoJson[i].properties, r.properties), delete e.geoJson[i].properties.id, delete e.geoJson[i].properties.sType
                        })
                    }
                    return this
                }
            }, {
                key: "themeHandle",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.mapObj;
                    if (!v.default.isEmpty(t.geoJson) && !v.default.isEmpty(t.themeJson)) {
                        var e = {};
                        try {
                            t.geoJson.forEach(function (i, r) {
                                var n = {};
                                e = t.themeJson.modelStyle.find(function (t) {
                                    return 1 * t.sType == 1 * i.sType
                                }), e && (n = JSON.parse((0, s.default)(e))), n.logo && (n.logo = t.baseUrl + "/" + n.logo), t.geoJson[r].properties = (0, o.default)({}, i.properties, n), delete t.geoJson[r].properties.sType
                            })
                        } catch (t) {
                            console.error("Theme file format is not correct")
                        }
                    }
                    return this
                }
            }, {
                key: "otherHandle",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.mapObj;
                    if (!v.default.isEmpty(e.geoJson) && !v.default.isEmpty(e.otherJson)) {
                        var i = [],
                            r = void 0,
                            n = new w.default;
                        e.otherJson.forEach(function (a) {
                            try {
                                i = n[a.type]({
                                    otherObj: a,
                                    mapCenter: t.center,
                                    floor: t.floor
                                }), "Room" === a.otherType ? (delete a.otherType, r = e.geoJson.findIndex(function (t) {
                                    return 1 * t.id == 1 * a.id
                                }), -1 === r ? v.default.log("Room id error") : (e.geoJson[r].properties = (0, o.default)({}, e.geoJson[r].properties, i[0]), delete e.geoJson[r].properties.id)) : e.geoJson = e.geoJson.concat(i)
                            } catch (t) {
                                "TypeError" === t.name ? v.default.log("the type '" + a.type + "' in other list that you input is not correct") : console.error(t)
                            }
                        })
                    }
                    return this
                }
            }, {
                key: "getRemainData",
                value: function () {
                    var t = this;
                    0 < this.maps.length && this.asyncMap(this.maps).then(function (e) {
                        t.mapDataHandle(e)
                    })
                }
            }, {
                key: "getBaseThemeUrl",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.object.themeUrl;
                    if (t) {
                        var e = t.split("/");
                        e.pop();
                        return e.join("/")
                    }
                    return ""
                }
            }]), t
        }();
    e.default = D
}, function (t, e, i) {
    t.exports = i(175)
}, function (t, e, i) {
    var r = function () {
            return this
        }() || Function("return this")(),
        n = r.regeneratorRuntime && Object.getOwnPropertyNames(r).indexOf("regeneratorRuntime") >= 0,
        o = n && r.regeneratorRuntime;
    if (r.regeneratorRuntime = void 0, t.exports = i(176), n) r.regeneratorRuntime = o;
    else try {
        delete r.regeneratorRuntime
    } catch (t) {
        r.regeneratorRuntime = void 0
    }
}, function (t, e) {
    ! function (e) {
        "use strict";

        function i(t, e, i, r) {
            var o = e && e.prototype instanceof n ? e : n,
                a = Object.create(o.prototype),
                s = new f(r || []);
            return a._invoke = h(t, i, s), a
        }

        function r(t, e, i) {
            try {
                return {
                    type: "normal",
                    arg: t.call(e, i)
                }
            } catch (t) {
                return {
                    type: "throw",
                    arg: t
                }
            }
        }

        function n() {}

        function o() {}

        function a() {}

        function s(t) {
            ["next", "throw", "return"].forEach(function (e) {
                t[e] = function (t) {
                    return this._invoke(e, t)
                }
            })
        }

        function l(t) {
            function e(i, n, o, a) {
                var s = r(t[i], t, n);
                if ("throw" !== s.type) {
                    var l = s.arg,
                        h = l.value;
                    return h && "object" == typeof h && y.call(h, "__await") ? Promise.resolve(h.__await).then(function (t) {
                        e("next", t, o, a)
                    }, function (t) {
                        e("throw", t, o, a)
                    }) : Promise.resolve(h).then(function (t) {
                        l.value = t, o(l)
                    }, a)
                }
                a(s.arg)
            }

            function i(t, i) {
                function r() {
                    return new Promise(function (r, n) {
                        e(t, i, r, n)
                    })
                }
                return n = n ? n.then(r, r) : r()
            }
            var n;
            this._invoke = i
        }

        function h(t, e, i) {
            var n = T;
            return function (o, a) {
                if (n === E) throw new Error("Generator is already running");
                if (n === C) {
                    if ("throw" === o) throw a;
                    return m()
                }
                for (i.method = o, i.arg = a;;) {
                    var s = i.delegate;
                    if (s) {
                        var l = c(s, i);
                        if (l) {
                            if (l === P) continue;
                            return l
                        }
                    }
                    if ("next" === i.method) i.sent = i._sent = i.arg;
                    else if ("throw" === i.method) {
                        if (n === T) throw n = C, i.arg;
                        i.dispatchException(i.arg)
                    } else "return" === i.method && i.abrupt("return", i.arg);
                    n = E;
                    var h = r(t, e, i);
                    if ("normal" === h.type) {
                        if (n = i.done ? C : S, h.arg === P) continue;
                        return {
                            value: h.arg,
                            done: i.done
                        }
                    }
                    "throw" === h.type && (n = C, i.method = "throw", i.arg = h.arg)
                }
            }
        }

        function c(t, e) {
            var i = t.iterator[e.method];
            if (i === g) {
                if (e.delegate = null, "throw" === e.method) {
                    if (t.iterator.return && (e.method = "return", e.arg = g, c(t, e), "throw" === e.method)) return P;
                    e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return P
            }
            var n = r(i, t.iterator, e.arg);
            if ("throw" === n.type) return e.method = "throw", e.arg = n.arg, e.delegate = null, P;
            var o = n.arg;
            return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = g), e.delegate = null, P) : o : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, P)
        }

        function u(t) {
            var e = {
                tryLoc: t[0]
            };
            1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
        }

        function p(t) {
            var e = t.completion || {};
            e.type = "normal", delete e.arg, t.completion = e
        }

        function f(t) {
            this.tryEntries = [{
                tryLoc: "root"
            }], t.forEach(u, this), this.reset(!0)
        }

        function d(t) {
            if (t) {
                var e = t[x];
                if (e) return e.call(t);
                if ("function" == typeof t.next) return t;
                if (!isNaN(t.length)) {
                    var i = -1,
                        r = function e() {
                            for (; ++i < t.length;)
                                if (y.call(t, i)) return e.value = t[i], e.done = !1, e;
                            return e.value = g, e.done = !0, e
                        };
                    return r.next = r
                }
            }
            return {
                next: m
            }
        }

        function m() {
            return {
                value: g,
                done: !0
            }
        }
        var g, v = Object.prototype,
            y = v.hasOwnProperty,
            A = "function" == typeof Symbol ? Symbol : {},
            x = A.iterator || "@@iterator",
            _ = A.asyncIterator || "@@asyncIterator",
            w = A.toStringTag || "@@toStringTag",
            b = "object" == typeof t,
            M = e.regeneratorRuntime;
        if (M) return void(b && (t.exports = M));
        M = e.regeneratorRuntime = b ? t.exports : {}, M.wrap = i;
        var T = "suspendedStart",
            S = "suspendedYield",
            E = "executing",
            C = "completed",
            P = {},
            L = {};
        L[x] = function () {
            return this
        };
        var D = Object.getPrototypeOf,
            R = D && D(D(d([])));
        R && R !== v && y.call(R, x) && (L = R);
        var I = a.prototype = n.prototype = Object.create(L);
        o.prototype = I.constructor = a, a.constructor = o, a[w] = o.displayName = "GeneratorFunction", M.isGeneratorFunction = function (t) {
            var e = "function" == typeof t && t.constructor;
            return !!e && (e === o || "GeneratorFunction" === (e.displayName || e.name))
        }, M.mark = function (t) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(t, a) : (t.__proto__ = a, w in t || (t[w] = "GeneratorFunction")), t.prototype = Object.create(I), t
        }, M.awrap = function (t) {
            return {
                __await: t
            }
        }, s(l.prototype), l.prototype[_] = function () {
            return this
        }, M.AsyncIterator = l, M.async = function (t, e, r, n) {
            var o = new l(i(t, e, r, n));
            return M.isGeneratorFunction(e) ? o : o.next().then(function (t) {
                return t.done ? t.value : o.next()
            })
        }, s(I), I[w] = "Generator", I[x] = function () {
            return this
        }, I.toString = function () {
            return "[object Generator]"
        }, M.keys = function (t) {
            var e = [];
            for (var i in t) e.push(i);
            return e.reverse(),
                function i() {
                    for (; e.length;) {
                        var r = e.pop();
                        if (r in t) return i.value = r, i.done = !1, i
                    }
                    return i.done = !0, i
                }
        }, M.values = d, f.prototype = {
            constructor: f,
            reset: function (t) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = g, this.done = !1, this.delegate = null, this.method = "next", this.arg = g, this.tryEntries.forEach(p), !t)
                    for (var e in this) "t" === e.charAt(0) && y.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = g)
            },
            stop: function () {
                this.done = !0;
                var t = this.tryEntries[0],
                    e = t.completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval
            },
            dispatchException: function (t) {
                function e(e, r) {
                    return o.type = "throw", o.arg = t, i.next = e, r && (i.method = "next", i.arg = g), !!r
                }
                if (this.done) throw t;
                for (var i = this, r = this.tryEntries.length - 1; r >= 0; --r) {
                    var n = this.tryEntries[r],
                        o = n.completion;
                    if ("root" === n.tryLoc) return e("end");
                    if (n.tryLoc <= this.prev) {
                        var a = y.call(n, "catchLoc"),
                            s = y.call(n, "finallyLoc");
                        if (a && s) {
                            if (this.prev < n.catchLoc) return e(n.catchLoc, !0);
                            if (this.prev < n.finallyLoc) return e(n.finallyLoc)
                        } else if (a) {
                            if (this.prev < n.catchLoc) return e(n.catchLoc, !0)
                        } else {
                            if (!s) throw new Error("try statement without catch or finally");
                            if (this.prev < n.finallyLoc) return e(n.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function (t, e) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var r = this.tryEntries[i];
                    if (r.tryLoc <= this.prev && y.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                        var n = r;
                        break
                    }
                }
                n && ("break" === t || "continue" === t) && n.tryLoc <= e && e <= n.finallyLoc && (n = null);
                var o = n ? n.completion : {};
                return o.type = t, o.arg = e, n ? (this.method = "next", this.next = n.finallyLoc, P) : this.complete(o)
            },
            complete: function (t, e) {
                if ("throw" === t.type) throw t.arg;
                return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), P
            },
            finish: function (t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                    var i = this.tryEntries[e];
                    if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), p(i), P
                }
            },
            catch: function (t) {
                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                    var i = this.tryEntries[e];
                    if (i.tryLoc === t) {
                        var r = i.completion;
                        if ("throw" === r.type) {
                            var n = r.arg;
                            p(i)
                        }
                        return n
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function (t, e, i) {
                return this.delegate = {
                    iterator: d(t),
                    resultName: e,
                    nextLoc: i
                }, "next" === this.method && (this.arg = g), P
            }
        }
    }(function () {
        return this
    }() || Function("return this")())
}, function (t, e, i) {
    "use strict";
    e.__esModule = !0;
    var r = i(88),
        n = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r);
    e.default = function (t) {
        return function () {
            var e = t.apply(this, arguments);
            return new n.default(function (t, i) {
                function r(o, a) {
                    try {
                        var s = e[o](a),
                            l = s.value
                    } catch (t) {
                        return void i(t)
                    }
                    if (!s.done) return n.default.resolve(l).then(function (t) {
                        r("next", t)
                    }, function (t) {
                        r("throw", t)
                    });
                    t(l)
                }
                return r("next")
            })
        }
    }
}, function (t, e, i) {
    i(26), i(27), i(18), i(179), i(184), i(185), t.exports = i(0).Promise
}, function (t, e, i) {
    "use strict";
    var r, n, o, a, s = i(24),
        l = i(5),
        h = i(16),
        c = i(55),
        u = i(1),
        p = i(6),
        f = i(25),
        d = i(38),
        m = i(19),
        g = i(89),
        v = i(90).set,
        y = i(181)(),
        A = i(65),
        x = i(91),
        _ = i(182),
        w = i(92),
        b = l.TypeError,
        M = l.process,
        T = M && M.versions,
        S = T && T.v8 || "",
        E = l.Promise,
        C = "process" == c(M),
        P = function () {},
        L = n = A.f,
        D = !! function () {
            try {
                var t = E.resolve(1),
                    e = (t.constructor = {})[i(7)("species")] = function (t) {
                        t(P, P)
                    };
                return (C || "function" == typeof PromiseRejectionEvent) && t.then(P) instanceof e && 0 !== S.indexOf("6.6") && -1 === _.indexOf("Chrome/66")
            } catch (t) {}
        }(),
        R = function (t) {
            var e;
            return !(!p(t) || "function" != typeof (e = t.then)) && e
        },
        I = function (t, e) {
            if (!t._n) {
                t._n = !0;
                var i = t._c;
                y(function () {
                    for (var r = t._v, n = 1 == t._s, o = 0; i.length > o;) ! function (e) {
                        var i, o, a, s = n ? e.ok : e.fail,
                            l = e.resolve,
                            h = e.reject,
                            c = e.domain;
                        try {
                            s ? (n || (2 == t._h && N(t), t._h = 1), !0 === s ? i = r : (c && c.enter(), i = s(r), c && (c.exit(), a = !0)), i === e.promise ? h(b("Promise-chain cycle")) : (o = R(i)) ? o.call(i, l, h) : l(i)) : h(r)
                        } catch (t) {
                            c && !a && c.exit(), h(t)
                        }
                    }(i[o++]);
                    t._c = [], t._n = !1, e && !t._h && O(t)
                })
            }
        },
        O = function (t) {
            v.call(l, function () {
                var e, i, r, n = t._v,
                    o = B(t);
                if (o && (e = x(function () {
                        C ? M.emit("unhandledRejection", n, t) : (i = l.onunhandledrejection) ? i({
                            promise: t,
                            reason: n
                        }) : (r = l.console) && r.error && r.error("Unhandled promise rejection", n)
                    }), t._h = C || B(t) ? 2 : 1), t._a = void 0, o && e.e) throw e.v
            })
        },
        B = function (t) {
            return 1 !== t._h && 0 === (t._a || t._c).length
        },
        N = function (t) {
            v.call(l, function () {
                var e;
                C ? M.emit("rejectionHandled", t) : (e = l.onrejectionhandled) && e({
                    promise: t,
                    reason: t._v
                })
            })
        },
        k = function (t) {
            var e = this;
            e._d || (e._d = !0, e = e._w || e, e._v = t, e._s = 2, e._a || (e._a = e._c.slice()), I(e, !0))
        },
        F = function (t) {
            var e, i = this;
            if (!i._d) {
                i._d = !0, i = i._w || i;
                try {
                    if (i === t) throw b("Promise can't be resolved itself");
                    (e = R(t)) ? y(function () {
                        var r = {
                            _w: i,
                            _d: !1
                        };
                        try {
                            e.call(t, h(F, r, 1), h(k, r, 1))
                        } catch (t) {
                            k.call(r, t)
                        }
                    }): (i._v = t, i._s = 1, I(i, !1))
                } catch (t) {
                    k.call({
                        _w: i,
                        _d: !1
                    }, t)
                }
            }
        };
    D || (E = function (t) {
        d(this, E, "Promise", "_h"), f(t), r.call(this);
        try {
            t(h(F, this, 1), h(k, this, 1))
        } catch (t) {
            k.call(this, t)
        }
    }, r = function (t) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
    }, r.prototype = i(37)(E.prototype, {
        then: function (t, e) {
            var i = L(g(this, E));
            return i.ok = "function" != typeof t || t, i.fail = "function" == typeof e && e, i.domain = C ? M.domain : void 0, this._c.push(i), this._a && this._a.push(i), this._s && I(this, !1), i.promise
        },
        catch: function (t) {
            return this.then(void 0, t)
        }
    }), o = function () {
        var t = new r;
        this.promise = t, this.resolve = h(F, t, 1), this.reject = h(k, t, 1)
    }, A.f = L = function (t) {
        return t === E || t === a ? new o(t) : n(t)
    }), u(u.G + u.W + u.F * !D, {
        Promise: E
    }), i(29)(E, "Promise"), i(75)("Promise"), a = i(0).Promise, u(u.S + u.F * !D, "Promise", {
        reject: function (t) {
            var e = L(this);
            return (0, e.reject)(t), e.promise
        }
    }), u(u.S + u.F * (s || !D), "Promise", {
        resolve: function (t) {
            return w(s && this === a ? E : this, t)
        }
    }), u(u.S + u.F * !(D && i(183)(function (t) {
        E.all(t).catch(P)
    })), "Promise", {
        all: function (t) {
            var e = this,
                i = L(e),
                r = i.resolve,
                n = i.reject,
                o = x(function () {
                    var i = [],
                        o = 0,
                        a = 1;
                    m(t, !1, function (t) {
                        var s = o++,
                            l = !1;
                        i.push(void 0), a++, e.resolve(t).then(function (t) {
                            l || (l = !0, i[s] = t, --a || r(i))
                        }, n)
                    }), --a || r(i)
                });
            return o.e && n(o.v), i.promise
        },
        race: function (t) {
            var e = this,
                i = L(e),
                r = i.reject,
                n = x(function () {
                    m(t, !1, function (t) {
                        e.resolve(t).then(i.resolve, r)
                    })
                });
            return n.e && r(n.v), i.promise
        }
    })
}, function (t, e) {
    t.exports = function (t, e, i) {
        var r = void 0 === i;
        switch (e.length) {
            case 0:
                return r ? t() : t.call(i);
            case 1:
                return r ? t(e[0]) : t.call(i, e[0]);
            case 2:
                return r ? t(e[0], e[1]) : t.call(i, e[0], e[1]);
            case 3:
                return r ? t(e[0], e[1], e[2]) : t.call(i, e[0], e[1], e[2]);
            case 4:
                return r ? t(e[0], e[1], e[2], e[3]) : t.call(i, e[0], e[1], e[2], e[3])
        }
        return t.apply(i, e)
    }
}, function (t, e, i) {
    var r = i(5),
        n = i(90).set,
        o = r.MutationObserver || r.WebKitMutationObserver,
        a = r.process,
        s = r.Promise,
        l = "process" == i(23)(a);
    t.exports = function () {
        var t, e, i, h = function () {
            var r, n;
            for (l && (r = a.domain) && r.exit(); t;) {
                n = t.fn, t = t.next;
                try {
                    n()
                } catch (r) {
                    throw t ? i() : e = void 0, r
                }
            }
            e = void 0, r && r.enter()
        };
        if (l) i = function () {
            a.nextTick(h)
        };
        else if (!o || r.navigator && r.navigator.standalone)
            if (s && s.resolve) {
                var c = s.resolve(void 0);
                i = function () {
                    c.then(h)
                }
            } else i = function () {
                n.call(r, h)
            };
        else {
            var u = !0,
                p = document.createTextNode("");
            new o(h).observe(p, {
                characterData: !0
            }), i = function () {
                p.data = u = !u
            }
        }
        return function (r) {
            var n = {
                fn: r,
                next: void 0
            };
            e && (e.next = n), t || (t = n, i()), e = n
        }
    }
}, function (t, e, i) {
    var r = i(5),
        n = r.navigator;
    t.exports = n && n.userAgent || ""
}, function (t, e, i) {
    var r = i(7)("iterator"),
        n = !1;
    try {
        var o = [7][r]();
        o.return = function () {
            n = !0
        }, Array.from(o, function () {
            throw 2
        })
    } catch (t) {}
    t.exports = function (t, e) {
        if (!e && !n) return !1;
        var i = !1;
        try {
            var o = [7],
                a = o[r]();
            a.next = function () {
                return {
                    done: i = !0
                }
            }, o[r] = function () {
                return a
            }, t(o)
        } catch (t) {}
        return i
    }
}, function (t, e, i) {
    "use strict";
    var r = i(1),
        n = i(0),
        o = i(5),
        a = i(89),
        s = i(92);
    r(r.P + r.R, "Promise", {
        finally: function (t) {
            var e = a(this, n.Promise || o.Promise),
                i = "function" == typeof t;
            return this.then(i ? function (i) {
                return s(e, t()).then(function () {
                    return i
                })
            } : t, i ? function (i) {
                return s(e, t()).then(function () {
                    throw i
                })
            } : t)
        }
    })
}, function (t, e, i) {
    "use strict";
    var r = i(1),
        n = i(65),
        o = i(91);
    r(r.S, "Promise", {
        try: function (t) {
            var e = n.f(this),
                i = o(t);
            return (i.e ? e.reject : e.resolve)(i.v), e.promise
        }
    })
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(9),
        o = r(n),
        a = i(187),
        s = r(a),
        l = i(2),
        h = r(l),
        c = i(3),
        u = r(c),
        p = i(10),
        f = r(p),
        d = i(86),
        m = r(d),
        g = i(21),
        v = i(66),
        y = r(v),
        A = function () {
            function t() {
                (0, h.default)(this, t), this.otherType = new s.default, this.maxId = 1e5
            }
            return (0, u.default)(t, [{
                key: "Room",
                value: function (t) {
                    var e = t.otherObj,
                        i = ["id"],
                        r = f.default.hasOwn(e, i);
                    return 0 < r.length && (errMsg = "'" + r.join("','") + "'", f.default.log("the attributes " + errMsg + " must be in your object")), e.otherType = e.type, e.type = e.sType, delete e.sType, [e]
                }
            }, {
                key: "Point",
                value: function (t) {
                    var e = t.otherObj,
                        i = t.mapCenter,
                        r = t.floor,
                        n = ["sType", "logo", "x", "y", "z"],
                        o = [],
                        a = {},
                        s = void 0;
                    return o = f.default.hasOwn(e, n), 0 < o.length ? (s = "'" + o.join("','") + "'", f.default.log("the attributes " + s + " must be in your object")) : (this.otherType.has(e.sType) || (this.otherType.set(e.sType, m.default.Point.now), m.default.Point.now++), e.type = e.sType, e.sType = this.otherType.get(e.type), e.mapCenter = i, e.size = e.size ? e.size : 3, e.id = e.id), a = {
                        id: e.id,
                        center: [e.x, e.z],
                        sType: e.sType,
                        y: e.y,
                        drawType: (0, y.default)(e.sType),
                        floor: r,
                        properties: e,
                        position: [e.x, e.y, e.z],
                        size: e.size,
                        isDetectModel: !1,
                        isAutoModel: !0
                    }, delete a.properties.sType, delete a.properties.x, delete a.properties.y, delete a.properties.z, [a]
                }
            }, {
                key: "Position",
                value: function (t) {
                    var e = t.otherObj,
                        i = t.mapCenter,
                        r = t.floor,
                        n = ["logo", "coordinates", "sType", "id"],
                        a = [],
                        s = [],
                        l = void 0,
                        h = void 0,
                        c = void 0;
                    if (a = f.default.hasOwn(e, n), 0 < a.length) c = "'" + a.join("','") + "'", f.default.log("the attributes " + c + " must be in your object");
                    else {
                        this.otherType.has(e.sType) || (this.otherType.set(e.sType, m.default.Point.now), m.default.Point.now++), e.type = e.sType, e.sType = this.otherType.get(e.type), e.mapCenter = i, e.height = e.height ? e.height : 1, e.id = e.id, e.size = e.size ? e.size : 3;
                        var u = (0, g.coordinatesToMercato)({
                            coordinates: e.coordinates,
                            mapCenter: i
                        });
                        u[0] instanceof Array ? u.forEach(function (t) {
                            0 < t.length && (l = JSON.parse((0, o.default)(e)), h = {
                                id: l.id,
                                center: t,
                                sType: l.sType,
                                drawType: (0, y.default)(e.sType),
                                floor: r,
                                properties: l,
                                size: e.size,
                                isDetectModel: !1,
                                isAutoModel: !0
                            }, delete h.properties.coordinates, delete h.properties.sType, s.push(h))
                        }) : 0 < u.length && (h = {
                            id: e.id,
                            center: u,
                            sType: e.sType,
                            floor: r,
                            drawType: (0, y.default)(e.sType),
                            properties: e,
                            size: e.size
                        }, delete h.properties.coordinates, delete h.properties.sType, s.push(h))
                    }
                    return s
                }
            }]), t
        }();
    e.default = A
}, function (t, e, i) {
    t.exports = {
        default: i(188),
        __esModule: !0
    }
}, function (t, e, i) {
    i(26), i(27), i(18), i(189), i(190), i(191), i(192), t.exports = i(0).Map
}, function (t, e, i) {
    "use strict";
    var r = i(73),
        n = i(30);
    t.exports = i(56)("Map", function (t) {
        return function () {
            return t(this, arguments.length > 0 ? arguments[0] : void 0)
        }
    }, {
        get: function (t) {
            var e = r.getEntry(n(this, "Map"), t);
            return e && e.v
        },
        set: function (t, e) {
            return r.def(n(this, "Map"), 0 === t ? 0 : t, e)
        }
    }, r, !0)
}, function (t, e, i) {
    var r = i(1);
    r(r.P + r.R, "Map", {
        toJSON: i(77)("Map")
    })
}, function (t, e, i) {
    i(58)("Map")
}, function (t, e, i) {
    i(59)("Map")
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = {
        room: {
            default: {
                name: "default-room",
                fillcolor: "#FFA07A",
                strokecolor: "#38AEBA",
                alpha: 1
            },
            config: [{
                name: "",
                sType: "0",
                fillcolor: "#F1F7F9",
                alpha: 1
            }, {
                name: "",
                sType: "1000",
                height: "2",
                fillcolor: "#E5EBEE",
                alpha: 1,
                strokecolor: "#87A8B8"
            }, {
                name: "",
                sType: "2012",
                height: "0.1",
                fillcolor: "#64C1EB",
                alpha: 1,
                strokecolor: "#87A8B8"
            }, {
                name: "",
                sType: "1002",
                fillcolor: "#faf8dc",
                alpha: "1",
                height: "10",
                strokecolor: "#faf8dc",
                fontSize: "14"
            }, {
                name: "",
                sType: "1001",
                fillcolor: "#faf8dc",
                alpha: "1",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "1004",
                fillcolor: "#C4E3E7",
                alpha: "1",
                height: "1",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "1003",
                fillcolor: "#C4E3E7",
                alpha: "1",
                height: "0.5",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: ",",
                sType: "2001",
                fillcolor: "#ffffff",
                alpha: "1",
                height: "2",
                strokecolor: "#38AEBA",
                fontSize: "1"
            }, {
                name: "",
                sType: "2002",
                fillcolor: "#B9B9B9",
                alpha: "1",
                height: "2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2003",
                fillcolor: "#A2FAB9",
                alpha: "1",
                height: "2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2004",
                fillcolor: "#F8DFCC",
                alpha: "1",
                height: "0.2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2005",
                fillcolor: "#DBB46F",
                alpha: "1",
                height: "2",
                strokecolor: "#DBB46F",
                fontSize: "14"
            }, {
                name: "",
                sType: "2006",
                fillcolor: "#50C4F0",
                alpha: "1",
                height: "2",
                strokecolor: "#50C4F0",
                fontSize: "14"
            }, {
                name: "",
                sType: "2007",
                fillcolor: "#FFFCEA",
                alpha: "1",
                height: "2",
                strokecolor: "#FFFCEA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2008",
                fillcolor: "#D3DEE3",
                alpha: "1",
                height: "0.2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2009",
                fillcolor: "#DDD0E7",
                alpha: "1",
                height: "0.2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }, {
                name: "",
                sType: "2010",
                fillcolor: "#87CBD2",
                alpha: "1",
                height: "0.2",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }]
        },
        seat: {
            default: {
                name: "default-seat",
                fillcolor: "#C4E3E7",
                strokecolor: "#38AEBA",
                alpha: 1
            },
            config: [{
                sType: "1003",
                fillcolor: "#C4E3E7",
                alpha: "1",
                height: "0.5",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }]
        },
        desk: {
            default: {
                name: "default-desk",
                fillcolor: "#C4E3E7",
                strokecolor: "#38AEBA",
                alpha: 1
            },
            config: [{
                sType: "1004",
                fillcolor: "#C4E3E7",
                alpha: "1",
                height: "1",
                strokecolor: "#38AEBA",
                fontSize: "14"
            }]
        },
        point: {
            default: {
                name: "default-point",
                alpha: 1,
                height: 1
            },
            config: []
        },
        plane: {
            default: {
                name: "default-plane",
                fillcolor: "#FFA07A",
                strokecolor: "#FFA07A",
                alpha: 1
            },
            config: []
        },
        floor: {
            default: {
                name: "",
                sType: 0,
                fillcolor: "#F1F7F9",
                strokecolor: "#FFD6B9",
                alpha: 1
            },
            config: [{
                name: "",
                sType: 0,
                fillcolor: "#F1F7F9",
                strokecolor: "#FFD6B9",
                alpha: 1
            }]
        },
        wall: {
            default: {
                name: "",
                sType: 1e3,
                height: 4,
                fillcolor: "#E5EBEE",
                strokecolor: "#38AEBA",
                alpha: 1
            },
            config: [{
                name: "",
                sType: 1e3,
                height: 4,
                fillcolor: "#E5EBEE",
                strokecolor: "#38AEBA",
                alpha: 1
            }]
        },
        other: {
            default: {
                name: "other-point",
                alpha: 1
            },
            config: []
        }
    };
    e.default = r
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(66),
        n = (function (t) {
            t && t.__esModule
        }(r), {
            computeYH: function (t, e) {
                var i = this,
                    r = t.extremum,
                    n = r.l;
                r.w;
                return t.geoJson.forEach(function (r, o) {
                    t.geoJson[o] = i[r.drawType.type](n / 20, r), "wall" === r.drawType.type && 1 * r.sType == 1e3 && (t.wallHeight = 1 * t.geoJson[o].properties.height), 0 == r.sType ? t.geoJson[o].y = (t.floor - 1) * e - t.geoJson[o].properties.height : t.geoJson[o].y = (t.floor - 1) * e, t.geoJson[o].id = Number(t.geoJson[o].id), t.geoJson[o].sType = Number(t.geoJson[o].sType), t.geoJson[o].properties.height = Number(t.geoJson[o].properties.height)
                }), t
            },
            floor: function (t, e) {
                if (!e.properties.height) {
                    var i = t / 50,
                        r = Math.log(t);
                    e.properties.height = i < r ? i : r
                }
                return e
            },
            point: function (t, e) {
                return e.properties.height, e.properties.height = 0, e.zoom = t / 50, e
            },
            other: function (t, e) {
                return e.properties.height ? e.zoom = t / 2 : (e.properties.height = 0, e.zoom = t / 2), e.layer = "otherGroup", e
            },
            room: function (t, e) {
                if (e.properties.height) {
                    var i = t / 40,
                        r = Math.log(t),
                        n = i < r ? i : r;
                    e.zoom = n
                } else if (1e3 == e.sType) e.properties.height = t / 25;
                else {
                    e.properties.height = t / 30;
                    var o = t / 40,
                        a = Math.log(t),
                        s = o < a ? o : a;
                    e.zoom = s
                }
                return e
            },
            seat: function (t, e) {
                if (e.properties.height) {
                    var i = t / 40,
                        r = Math.log(t),
                        n = i < r ? i : r;
                    e.zoom = n
                } else if (1e3 == e.sType) e.properties.height = t / 25;
                else {
                    e.properties.height = t / 30;
                    var o = t / 40,
                        a = Math.log(t),
                        s = o < a ? o : a;
                    e.zoom = s
                }
                return e
            },
            desk: function (t, e) {
                if (e.properties.height) {
                    var i = t / 40,
                        r = Math.log(t),
                        n = i < r ? i : r;
                    e.zoom = n
                } else if (1e3 == e.sType) e.properties.height = t / 25;
                else {
                    e.properties.height = t / 30;
                    var o = t / 40,
                        a = Math.log(t),
                        s = o < a ? o : a;
                    e.zoom = s
                }
                return e
            },
            plane: function (t, e) {
                return e.properties.height || (e.properties.height = t / 100), e
            },
            wall: function (t, e) {
                if (e.properties.height) {
                    var i = t / 40,
                        r = Math.log(t),
                        n = i < r ? i : r;
                    e.zoom = n
                } else if (1e3 == e.sType) e.properties.height = t / 30;
                else {
                    e.properties.height = t / 25;
                    var o = t / 40,
                        a = Math.log(t),
                        s = o < a ? o : a;
                    e.zoom = s
                }
                return e
            }
        });
    e.default = n
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(61),
        h = r(l),
        c = (0, h.default)(),
        u = function () {
            function t() {
                (0, o.default)(this, t), this[c] = {}
            }
            return (0, s.default)(t, [{
                key: "on",
                value: function (t, e) {
                    this[c][t] || (this[c][t] = []), this[c][t].push(e)
                }
            }, {
                key: "emit",
                value: function () {
                    for (var t = arguments.length, e = Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    var r = Array.prototype.shift.call(e),
                        n = this[c][r];
                    if (!n || 0 === n.length) return !1;
                    for (var o, a = 0; o = n[a++];) o.apply(this, e)
                }
            }, {
                key: "off",
                value: function (t, e) {
                    var i = this[c][t];
                    if (!i) return !1;
                    if (e)
                        for (var r = i.length - 1; r >= 0; r--) {
                            var n = i[r];
                            n === e && i.splice(r, 1)
                        } else i && (i.length = 0)
                }
            }, {
                key: "once",
                value: function (t, e) {
                    var i = this,
                        r = function r() {
                            for (var n = arguments.length, o = Array(n), a = 0; a < n; a++) o[a] = arguments[a];
                            i.off(t, r), e.apply(null, o)
                        };
                    return this.on(t, r)
                }
            }]), t
        }();
    e.default = u
}, function (t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(4),
        n = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(r),
        o = {
            createLayer: function (t) {
                var e = new n.Group;
                return e.create = "new", e.name = t, e
            }
        };
    e.default = o
}, function (t, e, i) {
    (function (t, r) {
        function n(t, i) {
            var r = {
                seen: [],
                stylize: a
            };
            return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), m(i) ? r.showHidden = i : i && e._extend(r, i), _(r.showHidden) && (r.showHidden = !1), _(r.depth) && (r.depth = 2), _(r.colors) && (r.colors = !1), _(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = o), l(r, t, r.depth)
        }

        function o(t, e) {
            var i = n.styles[e];
            return i ? "[" + n.colors[i][0] + "m" + t + "[" + n.colors[i][1] + "m" : t
        }

        function a(t, e) {
            return t
        }

        function s(t) {
            var e = {};
            return t.forEach(function (t, i) {
                e[t] = !0
            }), e
        }

        function l(t, i, r) {
            if (t.customInspect && i && S(i.inspect) && i.inspect !== e.inspect && (!i.constructor || i.constructor.prototype !== i)) {
                var n = i.inspect(r, t);
                return A(n) || (n = l(t, n, r)), n
            }
            var o = h(t, i);
            if (o) return o;
            var a = Object.keys(i),
                m = s(a);
            if (t.showHidden && (a = Object.getOwnPropertyNames(i)), T(i) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0)) return c(i);
            if (0 === a.length) {
                if (S(i)) {
                    var g = i.name ? ": " + i.name : "";
                    return t.stylize("[Function" + g + "]", "special")
                }
                if (w(i)) return t.stylize(RegExp.prototype.toString.call(i), "regexp");
                if (M(i)) return t.stylize(Date.prototype.toString.call(i), "date");
                if (T(i)) return c(i)
            }
            var v = "",
                y = !1,
                x = ["{", "}"];
            if (d(i) && (y = !0, x = ["[", "]"]), S(i)) {
                v = " [Function" + (i.name ? ": " + i.name : "") + "]"
            }
            if (w(i) && (v = " " + RegExp.prototype.toString.call(i)), M(i) && (v = " " + Date.prototype.toUTCString.call(i)), T(i) && (v = " " + c(i)), 0 === a.length && (!y || 0 == i.length)) return x[0] + v + x[1];
            if (r < 0) return w(i) ? t.stylize(RegExp.prototype.toString.call(i), "regexp") : t.stylize("[Object]", "special");
            t.seen.push(i);
            var _;
            return _ = y ? u(t, i, r, m, a) : a.map(function (e) {
                return p(t, i, r, m, e, y)
            }), t.seen.pop(), f(_, v, x)
        }

        function h(t, e) {
            if (_(e)) return t.stylize("undefined", "undefined");
            if (A(e)) {
                var i = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return t.stylize(i, "string")
            }
            return y(e) ? t.stylize("" + e, "number") : m(e) ? t.stylize("" + e, "boolean") : g(e) ? t.stylize("null", "null") : void 0
        }

        function c(t) {
            return "[" + Error.prototype.toString.call(t) + "]"
        }

        function u(t, e, i, r, n) {
            for (var o = [], a = 0, s = e.length; a < s; ++a) D(e, String(a)) ? o.push(p(t, e, i, r, String(a), !0)) : o.push("");
            return n.forEach(function (n) {
                n.match(/^\d+$/) || o.push(p(t, e, i, r, n, !0))
            }), o
        }

        function p(t, e, i, r, n, o) {
            var a, s, h;
            if (h = Object.getOwnPropertyDescriptor(e, n) || {
                    value: e[n]
                }, h.get ? s = h.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : h.set && (s = t.stylize("[Setter]", "special")), D(r, n) || (a = "[" + n + "]"), s || (t.seen.indexOf(h.value) < 0 ? (s = g(i) ? l(t, h.value, null) : l(t, h.value, i - 1), s.indexOf("\n") > -1 && (s = o ? s.split("\n").map(function (t) {
                    return "  " + t
                }).join("\n").substr(2) : "\n" + s.split("\n").map(function (t) {
                    return "   " + t
                }).join("\n"))) : s = t.stylize("[Circular]", "special")), _(a)) {
                if (o && n.match(/^\d+$/)) return s;
                a = JSON.stringify("" + n), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = t.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = t.stylize(a, "string"))
            }
            return a + ": " + s
        }

        function f(t, e, i) {
            var r = 0;
            return t.reduce(function (t, e) {
                return r++, e.indexOf("\n") >= 0 && r++, t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0) > 60 ? i[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + i[1] : i[0] + e + " " + t.join(", ") + " " + i[1]
        }

        function d(t) {
            return Array.isArray(t)
        }

        function m(t) {
            return "boolean" == typeof t
        }

        function g(t) {
            return null === t
        }

        function v(t) {
            return null == t
        }

        function y(t) {
            return "number" == typeof t
        }

        function A(t) {
            return "string" == typeof t
        }

        function x(t) {
            return "symbol" == typeof t
        }

        function _(t) {
            return void 0 === t
        }

        function w(t) {
            return b(t) && "[object RegExp]" === C(t)
        }

        function b(t) {
            return "object" == typeof t && null !== t
        }

        function M(t) {
            return b(t) && "[object Date]" === C(t)
        }

        function T(t) {
            return b(t) && ("[object Error]" === C(t) || t instanceof Error)
        }

        function S(t) {
            return "function" == typeof t
        }

        function E(t) {
            return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t
        }

        function C(t) {
            return Object.prototype.toString.call(t)
        }

        function P(t) {
            return t < 10 ? "0" + t.toString(10) : t.toString(10)
        }

        function L() {
            var t = new Date,
                e = [P(t.getHours()), P(t.getMinutes()), P(t.getSeconds())].join(":");
            return [t.getDate(), B[t.getMonth()], e].join(" ")
        }

        function D(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
        var R = /%[sdj%]/g;
        e.format = function (t) {
            if (!A(t)) {
                for (var e = [], i = 0; i < arguments.length; i++) e.push(n(arguments[i]));
                return e.join(" ")
            }
            for (var i = 1, r = arguments, o = r.length, a = String(t).replace(R, function (t) {
                    if ("%%" === t) return "%";
                    if (i >= o) return t;
                    switch (t) {
                        case "%s":
                            return String(r[i++]);
                        case "%d":
                            return Number(r[i++]);
                        case "%j":
                            try {
                                return JSON.stringify(r[i++])
                            } catch (t) {
                                return "[Circular]"
                            }
                            default:
                                return t
                    }
                }), s = r[i]; i < o; s = r[++i]) g(s) || !b(s) ? a += " " + s : a += " " + n(s);
            return a
        }, e.deprecate = function (i, n) {
            function o() {
                if (!a) {
                    if (r.throwDeprecation) throw new Error(n);
                    r.traceDeprecation ? console.trace(n) : console.error(n), a = !0
                }
                return i.apply(this, arguments)
            }
            if (_(t.process)) return function () {
                return e.deprecate(i, n).apply(this, arguments)
            };
            if (!0 === r.noDeprecation) return i;
            var a = !1;
            return o
        };
        var I, O = {};
        e.debuglog = function (t) {
            if (_(I) && (I = r.env.NODE_DEBUG || ""), t = t.toUpperCase(), !O[t])
                if (new RegExp("\\b" + t + "\\b", "i").test(I)) {
                    var i = r.pid;
                    O[t] = function () {
                        var r = e.format.apply(e, arguments);
                        console.error("%s %d: %s", t, i, r)
                    }
                } else O[t] = function () {};
            return O[t]
        }, e.inspect = n, n.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        }, n.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        }, e.isArray = d, e.isBoolean = m, e.isNull = g, e.isNullOrUndefined = v, e.isNumber = y, e.isString = A, e.isSymbol = x, e.isUndefined = _, e.isRegExp = w, e.isObject = b, e.isDate = M, e.isError = T, e.isFunction = S, e.isPrimitive = E, e.isBuffer = i(199);
        var B = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        e.log = function () {
            console.log("%s - %s", L(), e.format.apply(e, arguments))
        }, e.inherits = i(200), e._extend = function (t, e) {
            if (!e || !b(e)) return t;
            for (var i = Object.keys(e), r = i.length; r--;) t[i[r]] = e[i[r]];
            return t
        }
    }).call(e, i(93), i(198))
}, function (t, e) {
    function i() {
        throw new Error("setTimeout has not been defined")
    }

    function r() {
        throw new Error("clearTimeout has not been defined")
    }

    function n(t) {
        if (c === setTimeout) return setTimeout(t, 0);
        if ((c === i || !c) && setTimeout) return c = setTimeout, setTimeout(t, 0);
        try {
            return c(t, 0)
        } catch (e) {
            try {
                return c.call(null, t, 0)
            } catch (e) {
                return c.call(this, t, 0)
            }
        }
    }

    function o(t) {
        if (u === clearTimeout) return clearTimeout(t);
        if ((u === r || !u) && clearTimeout) return u = clearTimeout, clearTimeout(t);
        try {
            return u(t)
        } catch (e) {
            try {
                return u.call(null, t)
            } catch (e) {
                return u.call(this, t)
            }
        }
    }

    function a() {
        m && f && (m = !1, f.length ? d = f.concat(d) : g = -1, d.length && s())
    }

    function s() {
        if (!m) {
            var t = n(a);
            m = !0;
            for (var e = d.length; e;) {
                for (f = d, d = []; ++g < e;) f && f[g].run();
                g = -1, e = d.length
            }
            f = null, m = !1, o(t)
        }
    }

    function l(t, e) {
        this.fun = t, this.array = e
    }

    function h() {}
    var c, u, p = t.exports = {};
    ! function () {
        try {
            c = "function" == typeof setTimeout ? setTimeout : i
        } catch (t) {
            c = i
        }
        try {
            u = "function" == typeof clearTimeout ? clearTimeout : r
        } catch (t) {
            u = r
        }
    }();
    var f, d = [],
        m = !1,
        g = -1;
    p.nextTick = function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        d.push(new l(t, e)), 1 !== d.length || m || n(s)
    }, l.prototype.run = function () {
        this.fun.apply(null, this.array)
    }, p.title = "browser", p.browser = !0, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = h, p.addListener = h, p.once = h, p.off = h, p.removeListener = h, p.removeAllListeners = h, p.emit = h, p.prependListener = h, p.prependOnceListener = h, p.listeners = function (t) {
        return []
    }, p.binding = function (t) {
        throw new Error("process.binding is not supported")
    }, p.cwd = function () {
        return "/"
    }, p.chdir = function (t) {
        throw new Error("process.chdir is not supported")
    }, p.umask = function () {
        return 0
    }
}, function (t, e) {
    t.exports = function (t) {
        return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8
    }
}, function (t, e) {
    "function" == typeof Object.create ? t.exports = function (t, e) {
        t.super_ = e, t.prototype = Object.create(e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        })
    } : t.exports = function (t, e) {
        t.super_ = e;
        var i = function () {};
        i.prototype = e.prototype, t.prototype = new i, t.prototype.constructor = t
    }
}, function (t, e, i) {
    "use strict";
    (function (r) {
        var n, o, a = i(83),
            s = function (t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }(a),
            l = void 0 !== t && t.exports && void 0 !== r ? r : window;
        (l._gsQueue || (l._gsQueue = [])).push(function () {
                l._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
                        var r = function (t) {
                                var e, i = [],
                                    r = t.length;
                                for (e = 0; e !== r; i.push(t[e++]));
                                return i
                            },
                            n = function (t, e, i) {
                                var r, n, o = t.cycle;
                                for (r in o) n = o[r], t[r] = "function" == typeof n ? n(i, e[i]) : n[i % n.length];
                                delete t.cycle
                            },
                            o = function t(e, r, n) {
                                i.call(this, e, r, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = t.prototype.render
                            },
                            a = 1e-10,
                            s = i._internals,
                            l = s.isSelector,
                            h = s.isArray,
                            c = o.prototype = i.to({}, .1, {}),
                            u = [];
                        o.version = "2.0.1", c.constructor = o, c.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, c.invalidate = function () {
                            return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
                        }, c.updateTo = function (t, e) {
                            var r, n = this.ratio,
                                o = this.vars.immediateRender || t.immediateRender;
                            e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                            for (r in t) this.vars[r] = t[r];
                            if (this._initted || o)
                                if (e) this._initted = !1, o && this.render(0, !0, !0);
                                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                var a = this._totalTime;
                                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                for (var s, l = 1 / (1 - n), h = this._firstPT; h;) s = h.s + h.c, h.c *= l, h.s = s - h.c, h = h._next;
                            return this
                        }, c.render = function (t, e, r) {
                            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                            var n, o, l, h, c, u, p, f, d, m = this._dirty ? this.totalDuration() : this._totalDuration,
                                g = this._time,
                                v = this._totalTime,
                                y = this._cycle,
                                A = this._duration,
                                x = this._rawPrevTime;
                            if (t >= m - 1e-7 && t >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = A, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (n = !0, o = "onComplete", r = r || this._timeline.autoRemoveChildren), 0 === A && (this._initted || !this.vars.lazy || r) && (this._startTime === this._timeline._duration && (t = 0), (0 > x || 0 >= t && t >= -1e-7 || x === a && "isPause" !== this.data) && x !== t && (r = !0, x > a && (o = "onReverseComplete")), this._rawPrevTime = f = !e || t || x === t ? t : a)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === A && x > 0) && (o = "onReverseComplete", n = this._reversed), 0 > t && (this._active = !1, 0 === A && (this._initted || !this.vars.lazy || r) && (x >= 0 && (r = !0), this._rawPrevTime = f = !e || t || x === t ? t : a)), this._initted || (r = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = A + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && t >= v && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 != (1 & this._cycle) && (this._time = A - this._time, (d = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== d || this._initted ? this._yoyoEase = d = !0 === d ? this._ease : d instanceof Ease ? d : Ease.map[d] : (d = this.vars.ease, this._yoyoEase = d = d ? d instanceof Ease ? d : "function" == typeof d ? new Ease(d, this.vars.easeParams) : Ease.map[d] || i.defaultEase : i.defaultEase)), this.ratio = d ? 1 - d.getRatio((A - this._time) / A) : 0)), this._time > A ? this._time = A : this._time < 0 && (this._time = 0)), this._easeType && !d ? (c = this._time / A, u = this._easeType, p = this._easePower, (1 === u || 3 === u && c >= .5) && (c = 1 - c), 3 === u && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), 1 === u ? this.ratio = 1 - c : 2 === u ? this.ratio = c : this._time / A < .5 ? this.ratio = c / 2 : this.ratio = 1 - c / 2) : d || (this.ratio = this._ease.getRatio(this._time / A))), g === this._time && !r && y === this._cycle) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!r && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = g, this._totalTime = v, this._rawPrevTime = x, this._cycle = y, s.lazyTweens.push(this), void(this._lazy = [t, e]);
                                !this._time || n || d ? n && this._ease._calcEnd && !d && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / A)
                            }
                            for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== g && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, r) : o || (o = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === A) && (e || this._callback("onStart"))), l = this._firstPT; l;) l.f ? l.t[l.p](l.c * this.ratio + l.s) : l.t[l.p] = l.c * this.ratio + l.s, l = l._next;
                            this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, !0, r), e || (this._totalTime !== v || o) && this._callback("onUpdate")), this._cycle !== y && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (!this._gc || r) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, r), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o), 0 === A && this._rawPrevTime === a && f !== a && (this._rawPrevTime = 0))
                        }, o.to = function (t, e, i) {
                            return new o(t, e, i)
                        }, o.from = function (t, e, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
                        }, o.fromTo = function (t, e, i, r) {
                            return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new o(t, e, r)
                        }, o.staggerTo = o.allTo = function (t, e, a, s, c, p, f) {
                            s = s || 0;
                            var d, m, g, v, y = 0,
                                A = [],
                                x = function () {
                                    a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), c.apply(f || a.callbackScope || this, p || u)
                                },
                                _ = a.cycle,
                                w = a.startAt && a.startAt.cycle;
                            for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = r(t))), t = t || [], 0 > s && (t = r(t), t.reverse(), s *= -1), d = t.length - 1, g = 0; d >= g; g++) {
                                m = {};
                                for (v in a) m[v] = a[v];
                                if (_ && (n(m, t, g), null != m.duration && (e = m.duration, delete m.duration)), w) {
                                    w = m.startAt = {};
                                    for (v in a.startAt) w[v] = a.startAt[v];
                                    n(m.startAt, t, g)
                                }
                                m.delay = y + (m.delay || 0), g === d && c && (m.onComplete = x), A[g] = new o(t[g], e, m), y += s
                            }
                            return A
                        }, o.staggerFrom = o.allFrom = function (t, e, i, r, n, a, s) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, r, n, a, s)
                        }, o.staggerFromTo = o.allFromTo = function (t, e, i, r, n, a, s, l) {
                            return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, r, n, a, s, l)
                        }, o.delayedCall = function (t, e, i, r, n) {
                            return new o(e, 0, {
                                delay: t,
                                onComplete: e,
                                onCompleteParams: i,
                                callbackScope: r,
                                onReverseComplete: e,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                useFrames: n,
                                overwrite: 0
                            })
                        }, o.set = function (t, e) {
                            return new o(t, 0, e)
                        }, o.isTweening = function (t) {
                            return i.getTweensOf(t, !0).length > 0
                        };
                        var p = function t(e, r) {
                                for (var n = [], o = 0, a = e._first; a;) a instanceof i ? n[o++] = a : (r && (n[o++] = a), n = n.concat(t(a, r)), o = n.length), a = a._next;
                                return n
                            },
                            f = o.getAllTweens = function (e) {
                                return p(t._rootTimeline, e).concat(p(t._rootFramesTimeline, e))
                            };
                        o.killAll = function (t, i, r, n) {
                            null == i && (i = !0), null == r && (r = !0);
                            var o, a, s, l = f(0 != n),
                                h = l.length,
                                c = i && r && n;
                            for (s = 0; h > s; s++) a = l[s], (c || a instanceof e || (o = a.target === a.vars.onComplete) && r || i && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                        }, o.killChildTweensOf = function (t, e) {
                            if (null != t) {
                                var n, a, c, u, p, f = s.tweenLookup;
                                if ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = r(t)), h(t))
                                    for (u = t.length; --u > -1;) o.killChildTweensOf(t[u], e);
                                else {
                                    n = [];
                                    for (c in f)
                                        for (a = f[c].target.parentNode; a;) a === t && (n = n.concat(f[c].tweens)), a = a.parentNode;
                                    for (p = n.length, u = 0; p > u; u++) e && n[u].totalTime(n[u].totalDuration()), n[u]._enabled(!1, !1)
                                }
                            }
                        };
                        var d = function (t, i, r, n) {
                            i = !1 !== i, r = !1 !== r, n = !1 !== n;
                            for (var o, a, s = f(n), l = i && r && n, h = s.length; --h > -1;) a = s[h], (l || a instanceof e || (o = a.target === a.vars.onComplete) && r || i && !o) && a.paused(t)
                        };
                        return o.pauseAll = function (t, e, i) {
                            d(!0, t, e, i)
                        }, o.resumeAll = function (t, e, i) {
                            d(!1, t, e, i)
                        }, o.globalTimeScale = function (e) {
                            var r = t._rootTimeline,
                                n = i.ticker.time;
                            return arguments.length ? (e = e || a, r._startTime = n - (n - r._startTime) * r._timeScale / e, r = t._rootFramesTimeline, n = i.ticker.frame, r._startTime = n - (n - r._startTime) * r._timeScale / e, r._timeScale = t._rootTimeline._timeScale = e, e) : r._timeScale
                        }, c.progress = function (t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, c.totalProgress = function (t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, c.time = function (t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, c.duration = function (e) {
                            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                        }, c.totalDuration = function (t) {
                            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                        }, c.repeat = function (t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, c.repeatDelay = function (t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, c.yoyo = function (t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, o
                    }, !0), l._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
                        var r = function (t) {
                                e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                var i, r, n = this.vars;
                                for (r in n) i = n[r], h(i) && -1 !== i.join("").indexOf("{self}") && (n[r] = this._swapSelfInParams(i));
                                h(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
                            },
                            n = 1e-10,
                            o = i._internals,
                            a = r._internals = {},
                            s = o.isSelector,
                            h = o.isArray,
                            c = o.lazyTweens,
                            u = o.lazyRender,
                            p = l._gsDefine.globals,
                            f = function (t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            },
                            d = function (t, e, i) {
                                var r, n, o = t.cycle;
                                for (r in o) n = o[r], t[r] = "function" == typeof n ? n(i, e[i]) : n[i % n.length];
                                delete t.cycle
                            },
                            m = a.pauseCallback = function () {},
                            g = function (t) {
                                var e, i = [],
                                    r = t.length;
                                for (e = 0; e !== r; i.push(t[e++]));
                                return i
                            },
                            v = r.prototype = new e;
                        return r.version = "2.0.1", v.constructor = r, v.kill()._gc = v._forcingPlayhead = v._hasPause = !1, v.to = function (t, e, r, n) {
                            var o = r.repeat && p.TweenMax || i;
                            return e ? this.add(new o(t, e, r), n) : this.set(t, r, n)
                        }, v.from = function (t, e, r, n) {
                            return this.add((r.repeat && p.TweenMax || i).from(t, e, r), n)
                        }, v.fromTo = function (t, e, r, n, o) {
                            var a = n.repeat && p.TweenMax || i;
                            return e ? this.add(a.fromTo(t, e, r, n), o) : this.set(t, n, o)
                        }, v.staggerTo = function (t, e, n, o, a, l, h, c) {
                            var u, p, m = new r({
                                    onComplete: l,
                                    onCompleteParams: h,
                                    callbackScope: c,
                                    smoothChildTiming: this.smoothChildTiming
                                }),
                                v = n.cycle;
                            for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], s(t) && (t = g(t)), o = o || 0, 0 > o && (t = g(t), t.reverse(), o *= -1), p = 0; p < t.length; p++) u = f(n), u.startAt && (u.startAt = f(u.startAt), u.startAt.cycle && d(u.startAt, t, p)), v && (d(u, t, p), null != u.duration && (e = u.duration, delete u.duration)), m.to(t[p], e, u, p * o);
                            return this.add(m, a)
                        }, v.staggerFrom = function (t, e, i, r, n, o, a, s) {
                            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, r, n, o, a, s)
                        }, v.staggerFromTo = function (t, e, i, r, n, o, a, s, l) {
                            return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, r, n, o, a, s, l)
                        }, v.call = function (t, e, r, n) {
                            return this.add(i.delayedCall(0, t, e, r), n)
                        }, v.set = function (t, e, r) {
                            return r = this._parseTimeOrLabel(r, 0, !0), null == e.immediateRender && (e.immediateRender = r === this._time && !this._paused), this.add(new i(t, 0, e), r)
                        }, r.exportRoot = function (t, e) {
                            t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
                            var n, o, a, s, l = new r(t),
                                h = l._timeline;
                            for (null == e && (e = !0), h._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = h._time, a = h._first; a;) s = a._next, e && a instanceof i && a.target === a.vars.onComplete || (o = a._startTime - a._delay, 0 > o && (n = 1), l.add(a, o)), a = s;
                            return h.add(l, 0), n && l.totalDuration(), l
                        }, v.add = function (n, o, a, s) {
                            var l, c, u, p, f, d;
                            if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, n)), !(n instanceof t)) {
                                if (n instanceof Array || n && n.push && h(n)) {
                                    for (a = a || "normal", s = s || 0, l = o, c = n.length, u = 0; c > u; u++) h(p = n[u]) && (p = new r({
                                        tweens: p
                                    })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === a ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), l += s;
                                    return this._uncache(!0)
                                }
                                if ("string" == typeof n) return this.addLabel(n, o);
                                if ("function" != typeof n) throw "Cannot add " + n + " into the timeline; it is not a tween, timeline, function, or string.";
                                n = i.delayedCall(0, n)
                            }
                            if (e.prototype.add.call(this, n, o), n._time && n.render((this.rawTime() - n._startTime) * n._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                for (f = this, d = f.rawTime() > n._startTime; f._timeline;) d && f._timeline.smoothChildTiming ? f.totalTime(f._totalTime, !0) : f._gc && f._enabled(!0, !1), f = f._timeline;
                            return this
                        }, v.remove = function (e) {
                            if (e instanceof t) {
                                this._remove(e, !1);
                                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                            }
                            if (e instanceof Array || e && e.push && h(e)) {
                                for (var r = e.length; --r > -1;) this.remove(e[r]);
                                return this
                            }
                            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                        }, v._remove = function (t, i) {
                            return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                        }, v.append = function (t, e) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                        }, v.insert = v.insertMultiple = function (t, e, i, r) {
                            return this.add(t, e || 0, i, r)
                        }, v.appendMultiple = function (t, e, i, r) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, r)
                        }, v.addLabel = function (t, e) {
                            return this._labels[t] = this._parseTimeOrLabel(e), this
                        }, v.addPause = function (t, e, r, n) {
                            var o = i.delayedCall(0, m, r, n || this);
                            return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                        }, v.removeLabel = function (t) {
                            return delete this._labels[t], this
                        }, v.getLabelTime = function (t) {
                            return null != this._labels[t] ? this._labels[t] : -1
                        }, v._parseTimeOrLabel = function (e, i, r, n) {
                            var o, a;
                            if (n instanceof t && n.timeline === this) this.remove(n);
                            else if (n && (n instanceof Array || n.push && h(n)))
                                for (a = n.length; --a > -1;) n[a] instanceof t && n[a].timeline === this && this.remove(n[a]);
                            if (o = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, r && "number" == typeof e && null == this._labels[i] ? e - o : 0, r);
                            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o);
                            else {
                                if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? r ? this._labels[e] = o + i : i : this._labels[e] + i;
                                i = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, r) : o
                            }
                            return Number(e) + i
                        }, v.seek = function (t, e) {
                            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                        }, v.stop = function () {
                            return this.paused(!0)
                        }, v.gotoAndPlay = function (t, e) {
                            return this.play(t, e)
                        }, v.gotoAndStop = function (t, e) {
                            return this.pause(t, e)
                        }, v.render = function (t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var r, o, a, s, l, h, p, f = this._time,
                                d = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._startTime,
                                g = this._timeScale,
                                v = this._paused;
                            if (f !== this._time && (t += this._time - f), t >= d - 1e-7 && t >= 0) this._totalTime = this._time = d, this._reversed || this._hasPausedChild() || (o = !0, s = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= t && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === n) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > n && (s = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : n, t = d + 1e-4;
                            else if (1e-7 > t)
                                if (this._totalTime = this._time = 0, (0 !== f || 0 === this._duration && this._rawPrevTime !== n && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (s = "onReverseComplete", o = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = o = !0, s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : n, 0 === t && o)
                                        for (r = this._first; r && 0 === r._startTime;) r._duration || (o = !1), r = r._next;
                                    t = 0, this._initted || (l = !0)
                                }
                            else {
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t >= f)
                                        for (r = this._first; r && r._startTime <= t && !h;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (h = r), r = r._next;
                                    else
                                        for (r = this._last; r && r._startTime >= t && !h;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (h = r), r = r._prev;
                                    h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                this._totalTime = this._time = this._rawPrevTime = t
                            }
                            if (this._time !== f && this._first || i || l || h) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== f && t > 0 && (this._active = !0), 0 === f && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (p = this._time) >= f)
                                    for (r = this._first; r && (a = r._next, p === this._time && (!this._paused || v));)(r._active || r._startTime <= p && !r._paused && !r._gc) && (h === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = a;
                                else
                                    for (r = this._last; r && (a = r._prev, p === this._time && (!this._paused || v));) {
                                        if (r._active || r._startTime <= f && !r._paused && !r._gc) {
                                            if (h === r) {
                                                for (h = r._prev; h && h.endTime() > this._time;) h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev;
                                                h = null, this.pause()
                                            }
                                            r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)
                                        }
                                        r = a
                                    }
                                this._onUpdate && (e || (c.length && u(), this._callback("onUpdate"))), s && (this._gc || (m === this._startTime || g !== this._timeScale) && (0 === this._time || d >= this.totalDuration()) && (o && (c.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s)))
                            }
                        }, v._hasPausedChild = function () {
                            for (var t = this._first; t;) {
                                if (t._paused || t instanceof r && t._hasPausedChild()) return !0;
                                t = t._next
                            }
                            return !1
                        }, v.getChildren = function (t, e, r, n) {
                            n = n || -9999999999;
                            for (var o = [], a = this._first, s = 0; a;) a._startTime < n || (a instanceof i ? !1 !== e && (o[s++] = a) : (!1 !== r && (o[s++] = a), !1 !== t && (o = o.concat(a.getChildren(!0, e, r)), s = o.length))), a = a._next;
                            return o
                        }, v.getTweensOf = function (t, e) {
                            var r, n, o = this._gc,
                                a = [],
                                s = 0;
                            for (o && this._enabled(!0, !0), r = i.getTweensOf(t), n = r.length; --n > -1;)(r[n].timeline === this || e && this._contains(r[n])) && (a[s++] = r[n]);
                            return o && this._enabled(!1, !0), a
                        }, v.recent = function () {
                            return this._recent
                        }, v._contains = function (t) {
                            for (var e = t.timeline; e;) {
                                if (e === this) return !0;
                                e = e.timeline
                            }
                            return !1
                        }, v.shiftChildren = function (t, e, i) {
                            i = i || 0;
                            for (var r, n = this._first, o = this._labels; n;) n._startTime >= i && (n._startTime += t), n = n._next;
                            if (e)
                                for (r in o) o[r] >= i && (o[r] += t);
                            return this._uncache(!0)
                        }, v._kill = function (t, e) {
                            if (!t && !e) return this._enabled(!1, !1);
                            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), r = i.length, n = !1; --r > -1;) i[r]._kill(t, e) && (n = !0);
                            return n
                        }, v.clear = function (t) {
                            var e = this.getChildren(!1, !0, !0),
                                i = e.length;
                            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                            return !1 !== t && (this._labels = {}), this._uncache(!0)
                        }, v.invalidate = function () {
                            for (var e = this._first; e;) e.invalidate(), e = e._next;
                            return t.prototype.invalidate.call(this)
                        }, v._enabled = function (t, i) {
                            if (t === this._gc)
                                for (var r = this._first; r;) r._enabled(t, !0), r = r._next;
                            return e.prototype._enabled.call(this, t, i)
                        }, v.totalTime = function (e, i, r) {
                            this._forcingPlayhead = !0;
                            var n = t.prototype.totalTime.apply(this, arguments);
                            return this._forcingPlayhead = !1, n
                        }, v.duration = function (t) {
                            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                        }, v.totalDuration = function (t) {
                            if (!arguments.length) {
                                if (this._dirty) {
                                    for (var e, i, r = 0, n = this._last, o = 999999999999; n;) e = n._prev, n._dirty && n.totalDuration(), n._startTime > o && this._sortChildren && !n._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(n, n._startTime - n._delay), this._calculatingDuration = 0) : o = n._startTime, n._startTime < 0 && !n._paused && (r -= n._startTime, this._timeline.smoothChildTiming && (this._startTime += n._startTime / this._timeScale, this._time -= n._startTime, this._totalTime -= n._startTime, this._rawPrevTime -= n._startTime), this.shiftChildren(-n._startTime, !1, -9999999999), o = 0), i = n._startTime + n._totalDuration / n._timeScale, i > r && (r = i), n = e;
                                    this._duration = this._totalDuration = r, this._dirty = !1
                                }
                                return this._totalDuration
                            }
                            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                        }, v.paused = function (e) {
                            if (!e)
                                for (var i = this._first, r = this._time; i;) i._startTime === r && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                            return t.prototype.paused.apply(this, arguments)
                        }, v.usesFrames = function () {
                            for (var e = this._timeline; e._timeline;) e = e._timeline;
                            return e === t._rootFramesTimeline
                        }, v.rawTime = function (t) {
                            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                        }, r
                    }, !0), l._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) {
                        var r = function (e) {
                                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
                            },
                            n = 1e-10,
                            o = e._internals,
                            a = o.lazyTweens,
                            s = o.lazyRender,
                            h = l._gsDefine.globals,
                            c = new i(null, null, 1, 0),
                            u = r.prototype = new t;
                        return u.constructor = r, u.kill()._gc = !1, r.version = "2.0.1", u.invalidate = function () {
                            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                        }, u.addCallback = function (t, i, r, n) {
                            return this.add(e.delayedCall(0, t, r, n), i)
                        }, u.removeCallback = function (t, e) {
                            if (t)
                                if (null == e) this._kill(null, t);
                                else
                                    for (var i = this.getTweensOf(t, !1), r = i.length, n = this._parseTimeOrLabel(e); --r > -1;) i[r]._startTime === n && i[r]._enabled(!1, !1);
                            return this
                        }, u.removePause = function (e) {
                            return this.removeCallback(t._internals.pauseCallback, e)
                        }, u.tweenTo = function (t, i) {
                            i = i || {};
                            var r, n, o, a = {
                                    ease: c,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1,
                                    lazy: !1
                                },
                                s = i.repeat && h.TweenMax || e;
                            for (n in i) a[n] = i[n];
                            return a.time = this._parseTimeOrLabel(t), r = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new s(this, r, a), a.onStart = function () {
                                o.target.paused(!0), o.vars.time === o.target.time() || r !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || o, i.onStartParams || [])
                            }, o
                        }, u.tweenFromTo = function (t, e, i) {
                            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                                onComplete: this.seek,
                                onCompleteParams: [t],
                                callbackScope: this
                            }, i.immediateRender = !1 !== i.immediateRender;
                            var r = this.tweenTo(e, i);
                            return r.isFromTo = 1, r.duration(Math.abs(r.vars.time - t) / this._timeScale || .001)
                        }, u.render = function (t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var r, o, l, h, c, u, p, f, d = this._time,
                                m = this._dirty ? this.totalDuration() : this._totalDuration,
                                g = this._duration,
                                v = this._totalTime,
                                y = this._startTime,
                                A = this._timeScale,
                                x = this._rawPrevTime,
                                _ = this._paused,
                                w = this._cycle;
                            if (d !== this._time && (t += this._time - d), t >= m - 1e-7 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, h = "onComplete", c = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= t && t >= -1e-7 || 0 > x || x === n) && x !== t && this._first && (c = !0, x > n && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : n, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = g, t = g + 1e-4);
                            else if (1e-7 > t)
                                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== d || 0 === g && x !== n && (x > 0 || 0 > t && x >= 0) && !this._locked) && (h = "onReverseComplete", o = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (c = o = !0, h = "onReverseComplete") : x >= 0 && this._first && (c = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = g || !e || t || this._rawPrevTime === t ? t : n, 0 === t && o)
                                        for (r = this._first; r && 0 === r._startTime;) r._duration || (o = !1), r = r._next;
                                    t = 0, this._initted || (c = !0)
                                }
                            else if (0 === g && 0 > x && (c = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = g + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && t >= v && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 != (1 & this._cycle) && (this._time = g - this._time), this._time > g ? (this._time = g, t = g + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                                if ((t = this._time) >= d || this._repeat && w !== this._cycle)
                                    for (r = this._first; r && r._startTime <= t && !p;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (p = r), r = r._next;
                                else
                                    for (r = this._last; r && r._startTime >= t && !p;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (p = r), r = r._prev;
                                p && p._startTime < g && (this._time = t = p._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            if (this._cycle !== w && !this._locked) {
                                var b = this._yoyo && 0 != (1 & w),
                                    M = b === (this._yoyo && 0 != (1 & this._cycle)),
                                    T = this._totalTime,
                                    S = this._cycle,
                                    E = this._rawPrevTime,
                                    C = this._time;
                                if (this._totalTime = w * g, this._cycle < w ? b = !b : this._totalTime += g, this._time = d, this._rawPrevTime = 0 === g ? x - 1e-4 : x, this._cycle = w, this._locked = !0, d = b ? 0 : g, this.render(d, e, 0 === g), e || this._gc || this.vars.onRepeat && (this._cycle = S, this._locked = !1, this._callback("onRepeat")), d !== this._time) return;
                                if (M && (this._cycle = w, this._locked = !0, d = b ? g + 1e-4 : -1e-4, this.render(d, !0, !1)), this._locked = !1, this._paused && !_) return;
                                this._time = C, this._totalTime = T, this._cycle = S, this._rawPrevTime = E
                            }
                            if (!(this._time !== d && this._first || i || c || p)) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (f = this._time) >= d)
                                for (r = this._first; r && (l = r._next, f === this._time && (!this._paused || _));)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (p === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = l;
                            else
                                for (r = this._last; r && (l = r._prev, f === this._time && (!this._paused || _));) {
                                    if (r._active || r._startTime <= d && !r._paused && !r._gc) {
                                        if (p === r) {
                                            for (p = r._prev; p && p.endTime() > this._time;) p.render(p._reversed ? p.totalDuration() - (t - p._startTime) * p._timeScale : (t - p._startTime) * p._timeScale, e, i), p = p._prev;
                                            p = null, this.pause()
                                        }
                                        r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)
                                    }
                                    r = l
                                }
                            this._onUpdate && (e || (a.length && s(), this._callback("onUpdate"))), h && (this._locked || this._gc || (y === this._startTime || A !== this._timeScale) && (0 === this._time || m >= this.totalDuration()) && (o && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this._callback(h)))
                        }, u.getActive = function (t, e, i) {
                            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                            var r, n, o = [],
                                a = this.getChildren(t, e, i),
                                s = 0,
                                l = a.length;
                            for (r = 0; l > r; r++) n = a[r], n.isActive() && (o[s++] = n);
                            return o
                        }, u.getLabelAfter = function (t) {
                            t || 0 !== t && (t = this._time);
                            var e, i = this.getLabelsArray(),
                                r = i.length;
                            for (e = 0; r > e; e++)
                                if (i[e].time > t) return i[e].name;
                            return null
                        }, u.getLabelBefore = function (t) {
                            null == t && (t = this._time);
                            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                                if (e[i].time < t) return e[i].name;
                            return null
                        }, u.getLabelsArray = function () {
                            var t, e = [],
                                i = 0;
                            for (t in this._labels) e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                            return e.sort(function (t, e) {
                                return t.time - e.time
                            }), e
                        }, u.invalidate = function () {
                            return this._locked = !1, t.prototype.invalidate.call(this)
                        }, u.progress = function (t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                        }, u.totalProgress = function (t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                        }, u.totalDuration = function (e) {
                            return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                        }, u.time = function (t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, u.repeat = function (t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, u.repeatDelay = function (t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, u.yoyo = function (t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, u.currentLabel = function (t) {
                            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                        }, r
                    }, !0),
                    function () {
                        var t = 180 / Math.PI,
                            e = [],
                            i = [],
                            r = [],
                            n = {},
                            o = l._gsDefine.globals,
                            a = function (t, e, i, r) {
                                i === r && (i = r - (r - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = r, this.da = r - t, this.ca = i - t, this.ba = e - t
                            },
                            s = function (t, e, i, r) {
                                var n = {
                                        a: t
                                    },
                                    o = {},
                                    a = {},
                                    s = {
                                        c: r
                                    },
                                    l = (t + e) / 2,
                                    h = (e + i) / 2,
                                    c = (i + r) / 2,
                                    u = (l + h) / 2,
                                    p = (h + c) / 2,
                                    f = (p - u) / 8;
                                return n.b = l + (t - l) / 4, o.b = u + f, n.c = o.a = (n.b + o.b) / 2, o.c = a.a = (u + p) / 2, a.b = p - f, s.b = c + (r - c) / 4, a.c = s.a = (a.b + s.b) / 2, [n, o, a, s]
                            },
                            h = function (t, n, o, a, l) {
                                var h, c, u, p, f, d, m, g, v, y, A, x, _, w = t.length - 1,
                                    b = 0,
                                    M = t[0].a;
                                for (h = 0; w > h; h++) f = t[b], c = f.a, u = f.d, p = t[b + 1].d, l ? (A = e[h], x = i[h], _ = (x + A) * n * .25 / (a ? .5 : r[h] || .5), d = u - (u - c) * (a ? .5 * n : 0 !== A ? _ / A : 0), m = u + (p - u) * (a ? .5 * n : 0 !== x ? _ / x : 0), g = u - (d + ((m - d) * (3 * A / (A + x) + .5) / 4 || 0))) : (d = u - (u - c) * n * .5, m = u + (p - u) * n * .5, g = u - (d + m) / 2), d += g, m += g, f.c = v = d, f.b = 0 !== h ? M : M = f.a + .6 * (f.c - f.a), f.da = u - c, f.ca = v - c, f.ba = M - c, o ? (y = s(c, M, v, u), t.splice(b, 1, y[0], y[1], y[2], y[3]), b += 4) : b++, M = m;
                                f = t[b], f.b = M, f.c = M + .4 * (f.d - M), f.da = f.d - f.a, f.ca = f.c - f.a, f.ba = M - f.a, o && (y = s(f.a, M, f.c, f.d), t.splice(b, 1, y[0], y[1], y[2], y[3]))
                            },
                            c = function (t, r, n, o) {
                                var s, l, h, c, u, p, f = [];
                                if (o)
                                    for (t = [o].concat(t), l = t.length; --l > -1;) "string" == typeof (p = t[l][r]) && "=" === p.charAt(1) && (t[l][r] = o[r] + Number(p.charAt(0) + p.substr(2)));
                                if (0 > (s = t.length - 2)) return f[0] = new a(t[0][r], 0, 0, t[0][r]), f;
                                for (l = 0; s > l; l++) h = t[l][r], c = t[l + 1][r], f[l] = new a(h, 0, 0, c), n && (u = t[l + 2][r], e[l] = (e[l] || 0) + (c - h) * (c - h), i[l] = (i[l] || 0) + (u - c) * (u - c));
                                return f[l] = new a(t[l][r], 0, 0, t[l + 1][r]), f
                            },
                            u = function (t, o, a, s, l, u) {
                                var p, f, d, m, g, v, y, A, x = {},
                                    _ = [],
                                    w = u || t[0];
                                l = "string" == typeof l ? "," + l + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == o && (o = 1);
                                for (f in t[0]) _.push(f);
                                if (t.length > 1) {
                                    for (A = t[t.length - 1], y = !0, p = _.length; --p > -1;)
                                        if (f = _[p], Math.abs(w[f] - A[f]) > .05) {
                                            y = !1;
                                            break
                                        } y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                                }
                                for (e.length = i.length = r.length = 0, p = _.length; --p > -1;) f = _[p], n[f] = -1 !== l.indexOf("," + f + ","), x[f] = c(t, f, n[f], u);
                                for (p = e.length; --p > -1;) e[p] = Math.sqrt(e[p]), i[p] = Math.sqrt(i[p]);
                                if (!s) {
                                    for (p = _.length; --p > -1;)
                                        if (n[f])
                                            for (d = x[_[p]], v = d.length - 1, m = 0; v > m; m++) g = d[m + 1].da / i[m] + d[m].da / e[m] || 0, r[m] = (r[m] || 0) + g * g;
                                    for (p = r.length; --p > -1;) r[p] = Math.sqrt(r[p])
                                }
                                for (p = _.length, m = a ? 4 : 1; --p > -1;) f = _[p], d = x[f], h(d, o, a, s, n[f]), y && (d.splice(0, m), d.splice(d.length - m, m));
                                return x
                            },
                            p = function (t, e, i) {
                                e = e || "soft";
                                var r, n, o, s, l, h, c, u, p, f, d, m = {},
                                    g = "cubic" === e ? 3 : 2,
                                    v = "soft" === e,
                                    y = [];
                                if (v && i && (t = [i].concat(t)), null == t || t.length < g + 1) throw "invalid Bezier data";
                                for (p in t[0]) y.push(p);
                                for (h = y.length; --h > -1;) {
                                    for (p = y[h], m[p] = l = [], f = 0, u = t.length, c = 0; u > c; c++) r = null == i ? t[c][p] : "string" == typeof (d = t[c][p]) && "=" === d.charAt(1) ? i[p] + Number(d.charAt(0) + d.substr(2)) : Number(d), v && c > 1 && u - 1 > c && (l[f++] = (r + l[f - 2]) / 2), l[f++] = r;
                                    for (u = f - g + 1, f = 0, c = 0; u > c; c += g) r = l[c], n = l[c + 1], o = l[c + 2], s = 2 === g ? 0 : l[c + 3], l[f++] = d = 3 === g ? new a(r, n, o, s) : new a(r, (2 * n + r) / 3, (2 * n + o) / 3, o);
                                    l.length = f
                                }
                                return m
                            },
                            f = function (t, e, i) {
                                for (var r, n, o, a, s, l, h, c, u, p, f, d = 1 / i, m = t.length; --m > -1;)
                                    for (p = t[m], o = p.a, a = p.d - o, s = p.c - o, l = p.b - o, r = n = 0, c = 1; i >= c; c++) h = d * c, u = 1 - h, r = n - (n = (h * h * a + 3 * u * (h * s + u * l)) * h), f = m * i + c - 1, e[f] = (e[f] || 0) + r * r
                            },
                            d = function (t, e) {
                                e = e >> 0 || 6;
                                var i, r, n, o, a = [],
                                    s = [],
                                    l = 0,
                                    h = 0,
                                    c = e - 1,
                                    u = [],
                                    p = [];
                                for (i in t) f(t[i], a, e);
                                for (n = a.length, r = 0; n > r; r++) l += Math.sqrt(a[r]), o = r % e, p[o] = l, o === c && (h += l, o = r / e >> 0, u[o] = p, s[o] = h, l = 0, p = []);
                                return {
                                    length: h,
                                    lengths: s,
                                    segments: u
                                }
                            },
                            m = l._gsDefine.plugin({
                                propName: "bezier",
                                priority: -1,
                                version: "1.3.8",
                                API: 2,
                                global: !0,
                                init: function (t, e, i) {
                                    this._target = t, e instanceof Array && (e = {
                                        values: e
                                    }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                                    var r, n, o, a, s, l = e.values || [],
                                        h = {},
                                        c = l[0],
                                        f = e.autoRotate || i.vars.orientToBezier;
                                    this._autoRotate = f ? f instanceof Array ? f : [
                                        ["x", "y", "rotation", !0 === f ? 0 : Number(f) || 0]
                                    ] : null;
                                    for (r in c) this._props.push(r);
                                    for (o = this._props.length; --o > -1;) r = this._props[o], this._overwriteProps.push(r), n = this._func[r] = "function" == typeof t[r], h[r] = n ? t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(t[r]), s || h[r] !== l[0][r] && (s = h);
                                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : p(l, e.type, h), this._segCount = this._beziers[r].length, this._timeRes) {
                                        var m = d(this._beziers, this._timeRes);
                                        this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                    }
                                    if (f = this._autoRotate)
                                        for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), o = f.length; --o > -1;) {
                                            for (a = 0; 3 > a; a++) r = f[o][a], this._func[r] = "function" == typeof t[r] && t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)];
                                            r = f[o][2], this._initialRotations[o] = (this._func[r] ? this._func[r].call(this._target) : this._target[r]) || 0, this._overwriteProps.push(r)
                                        }
                                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                                },
                                set: function (e) {
                                    var i, r, n, o, a, s, l, h, c, u, p = this._segCount,
                                        f = this._func,
                                        d = this._target,
                                        m = e !== this._startRatio;
                                    if (this._timeRes) {
                                        if (c = this._lengths, u = this._curSeg, e *= this._length, n = this._li, e > this._l2 && p - 1 > n) {
                                            for (h = p - 1; h > n && (this._l2 = c[++n]) <= e;);
                                            this._l1 = c[n - 1], this._li = n, this._curSeg = u = this._segments[n], this._s2 = u[this._s1 = this._si = 0]
                                        } else if (e < this._l1 && n > 0) {
                                            for (; n > 0 && (this._l1 = c[--n]) >= e;);
                                            0 === n && e < this._l1 ? this._l1 = 0 : n++, this._l2 = c[n], this._li = n, this._curSeg = u = this._segments[n], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                        }
                                        if (i = n, e -= this._l1, n = this._si, e > this._s2 && n < u.length - 1) {
                                            for (h = u.length - 1; h > n && (this._s2 = u[++n]) <= e;);
                                            this._s1 = u[n - 1], this._si = n
                                        } else if (e < this._s1 && n > 0) {
                                            for (; n > 0 && (this._s1 = u[--n]) >= e;);
                                            0 === n && e < this._s1 ? this._s1 = 0 : n++, this._s2 = u[n], this._si = n
                                        }
                                        s = (n + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                    } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, s = (e - i * (1 / p)) * p;
                                    for (r = 1 - s, n = this._props.length; --n > -1;) o = this._props[n], a = this._beziers[o][i], l = (s * s * a.da + 3 * r * (s * a.ca + r * a.ba)) * s + a.a, this._mod[o] && (l = this._mod[o](l, d)), f[o] ? d[o](l) : d[o] = l;
                                    if (this._autoRotate) {
                                        var g, v, y, A, x, _, w, b = this._autoRotate;
                                        for (n = b.length; --n > -1;) o = b[n][2], _ = b[n][3] || 0, w = !0 === b[n][4] ? 1 : t, a = this._beziers[b[n][0]], g = this._beziers[b[n][1]], a && g && (a = a[i], g = g[i], v = a.a + (a.b - a.a) * s, A = a.b + (a.c - a.b) * s, v += (A - v) * s, A += (a.c + (a.d - a.c) * s - A) * s, y = g.a + (g.b - g.a) * s, x = g.b + (g.c - g.b) * s, y += (x - y) * s, x += (g.c + (g.d - g.c) * s - x) * s, l = m ? Math.atan2(x - y, A - v) * w + _ : this._initialRotations[n], this._mod[o] && (l = this._mod[o](l, d)), f[o] ? d[o](l) : d[o] = l)
                                    }
                                }
                            }),
                            g = m.prototype;
                        m.bezierThrough = u, m.cubicToQuadratic = s, m._autoCSS = !0, m.quadraticToCubic = function (t, e, i) {
                            return new a(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                        }, m._cssRegister = function () {
                            var t = o.CSSPlugin;
                            if (t) {
                                var e = t._internals,
                                    i = e._parseToProxy,
                                    r = e._setPluginRatio,
                                    n = e.CSSPropTween;
                                e._registerComplexSpecialProp("bezier", {
                                    parser: function (t, e, o, a, s, l) {
                                        e instanceof Array && (e = {
                                            values: e
                                        }), l = new m;
                                        var h, c, u, p = e.values,
                                            f = p.length - 1,
                                            d = [],
                                            g = {};
                                        if (0 > f) return s;
                                        for (h = 0; f >= h; h++) u = i(t, p[h], a, s, l, f !== h), d[h] = u.end;
                                        for (c in e) g[c] = e[c];
                                        return g.values = d, s = new n(t, "bezier", 0, 0, u.pt, 2), s.data = u, s.plugin = l, s.setRatio = r, 0 === g.autoRotate && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (h = !0 === g.autoRotate ? 0 : Number(g.autoRotate), g.autoRotate = null != u.end.left ? [
                                            ["left", "top", "rotation", h, !1]
                                        ] : null != u.end.x && [
                                            ["x", "y", "rotation", h, !1]
                                        ]), g.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), l._onInitTween(u.proxy, g, a._tween), s
                                    }
                                })
                            }
                        }, g._mod = function (t) {
                            for (var e, i = this._overwriteProps, r = i.length; --r > -1;)(e = t[i[r]]) && "function" == typeof e && (this._mod[i[r]] = e)
                        }, g._kill = function (t) {
                            var e, i, r = this._props;
                            for (e in this._beziers)
                                if (e in t)
                                    for (delete this._beziers[e], delete this._func[e], i = r.length; --i > -1;) r[i] === e && r.splice(i, 1);
                            if (r = this._autoRotate)
                                for (i = r.length; --i > -1;) t[r[i][2]] && r.splice(i, 1);
                            return this._super._kill.call(this, t)
                        }
                    }(), l._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
                        var i, r, n, o, a = function e() {
                                t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = e.prototype.setRatio
                            },
                            h = l._gsDefine.globals,
                            c = {},
                            u = a.prototype = new t("css");
                        u.constructor = a, a.version = "1.20.5", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", a.defaultSmoothOrigin = !0, u = "px", a.suffixMap = {
                            top: u,
                            right: u,
                            bottom: u,
                            left: u,
                            width: u,
                            height: u,
                            fontSize: u,
                            padding: u,
                            margin: u,
                            perspective: u,
                            lineHeight: ""
                        };
                        var p, f, d, m, g, v, y, A, x = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            _ = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            w = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            b = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            M = /(?:\d|\-|\+|=|#|\.)*/g,
                            T = /opacity *= *([^)]*)/i,
                            S = /opacity:([^;]*)/i,
                            E = /alpha\(opacity *=.+?\)/i,
                            C = /^(rgb|hsl)/,
                            P = /([A-Z])/g,
                            L = /-([a-z])/gi,
                            D = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            R = function (t, e) {
                                return e.toUpperCase()
                            },
                            I = /(?:Left|Right|Width)/i,
                            O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            B = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            N = /,(?=[^\)]*(?:\(|$))/gi,
                            k = /[\s,\(]/i,
                            F = Math.PI / 180,
                            z = 180 / Math.PI,
                            U = {},
                            G = {
                                style: {}
                            },
                            V = l.document || {
                                createElement: function () {
                                    return G
                                }
                            },
                            H = function (t, e) {
                                return V.createElementNS ? V.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : V.createElement(t)
                            },
                            j = H("div"),
                            W = H("img"),
                            Y = a._internals = {
                                _specialProps: c
                            },
                            X = (l.navigator || {}).userAgent || "",
                            Q = function () {
                                var t = X.indexOf("Android"),
                                    e = H("a");
                                return d = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === t || parseFloat(X.substr(t + 8, 2)) > 3), g = d && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, m = -1 !== X.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (v = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                            }(),
                            J = function (t) {
                                return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            },
                            q = function (t) {
                                l.console && console.warn(t)
                            },
                            Z = "",
                            K = "",
                            $ = function (t, e) {
                                e = e || j;
                                var i, r, n = e.style;
                                if (void 0 !== n[t]) return t;
                                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === n[i[r] + t];);
                                return r >= 0 ? (K = 3 === r ? "ms" : i[r], Z = "-" + K.toLowerCase() + "-", K + t) : null
                            },
                            tt = ("undefined" != typeof window ? window : V.defaultView || {
                                getComputedStyle: function () {}
                            }).getComputedStyle,
                            et = a.getStyle = function (t, e, i, r, n) {
                                var o;
                                return Q || "opacity" !== e ? (!r && t.style[e] ? o = t.style[e] : (i = i || tt(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(P, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == n || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : n) : J(t)
                            },
                            it = Y.convertToPixels = function (t, i, r, n, o) {
                                if ("px" === n || !n && "lineHeight" !== i) return r;
                                if ("auto" === n || !r) return 0;
                                var s, l, h, c = I.test(i),
                                    u = t,
                                    p = j.style,
                                    f = 0 > r,
                                    d = 1 === r;
                                if (f && (r = -r), d && (r *= 100), "lineHeight" !== i || n)
                                    if ("%" === n && -1 !== i.indexOf("border")) s = r / 100 * (c ? t.clientWidth : t.clientHeight);
                                    else {
                                        if (p.cssText = "border:0 solid red;position:" + et(t, "position") + ";line-height:0;", "%" !== n && u.appendChild && "v" !== n.charAt(0) && "rem" !== n) p[c ? "borderLeftWidth" : "borderTopWidth"] = r + n;
                                        else {
                                            if (u = t.parentNode || V.body, -1 !== et(u, "display").indexOf("flex") && (p.position = "absolute"), l = u._gsCache, h = e.ticker.frame, l && c && l.time === h) return l.width * r / 100;
                                            p[c ? "width" : "height"] = r + n
                                        }
                                        u.appendChild(j), s = parseFloat(j[c ? "offsetWidth" : "offsetHeight"]), u.removeChild(j), c && "%" === n && !1 !== a.cacheWidths && (l = u._gsCache = u._gsCache || {}, l.time = h, l.width = s / r * 100), 0 !== s || o || (s = it(t, i, r, n, !0))
                                    }
                                else l = tt(t).lineHeight, t.style.lineHeight = r, s = parseFloat(tt(t).lineHeight), t.style.lineHeight = l;
                                return d && (s /= 100), f ? -s : s
                            },
                            rt = Y.calculateOffset = function (t, e, i) {
                                if ("absolute" !== et(t, "position", i)) return 0;
                                var r = "left" === e ? "Left" : "Top",
                                    n = et(t, "margin" + r, i);
                                return t["offset" + r] - (it(t, e, parseFloat(n), n.replace(M, "")) || 0)
                            },
                            nt = function (t, e) {
                                var i, r, n, o = {};
                                if (e = e || tt(t, null))
                                    if (i = e.length)
                                        for (; --i > -1;) n = e[i], (-1 === n.indexOf("-transform") || Dt === n) && (o[n.replace(L, R)] = e.getPropertyValue(n));
                                    else
                                        for (i in e)(-1 === i.indexOf("Transform") || Lt === i) && (o[i] = e[i]);
                                else if (e = t.currentStyle || t.style)
                                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(L, R)] = e[i]);
                                return Q || (o.opacity = J(t)), r = Wt(t, e, !1), o.rotation = r.rotation, o.skewX = r.skewX, o.scaleX = r.scaleX, o.scaleY = r.scaleY, o.x = r.x, o.y = r.y, It && (o.z = r.z, o.rotationX = r.rotationX, o.rotationY = r.rotationY, o.scaleZ = r.scaleZ), o.filters && delete o.filters, o
                            },
                            ot = function (t, e, i, r, n) {
                                var o, a, s, l = {},
                                    h = t.style;
                                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || n && n[a]) && -1 === a.indexOf("Origin") && ("number" == typeof o || "string" == typeof o) && (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(b, "") ? o : 0 : rt(t, a), void 0 !== h[a] && (s = new xt(h, a, h[a], s)));
                                if (r)
                                    for (a in r) "className" !== a && (l[a] = r[a]);
                                return {
                                    difs: l,
                                    firstMPT: s
                                }
                            },
                            at = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            },
                            st = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            lt = function (t, e, i) {
                                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || tt(t))[e] || 0;
                                if (t.getCTM && Vt(t)) return t.getBBox()[e] || 0;
                                var r = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                    n = at[e],
                                    o = n.length;
                                for (i = i || tt(t, null); --o > -1;) r -= parseFloat(et(t, "padding" + n[o], i, !0)) || 0, r -= parseFloat(et(t, "border" + n[o] + "Width", i, !0)) || 0;
                                return r
                            },
                            ht = function t(e, i) {
                                if ("contain" === e || "auto" === e || "auto auto" === e) return e + " ";
                                (null == e || "" === e) && (e = "0 0");
                                var r, n = e.split(" "),
                                    o = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : n[0],
                                    a = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : n[1];
                                if (n.length > 3 && !i) {
                                    for (n = e.split(", ").join(",").split(","), e = [], r = 0; r < n.length; r++) e.push(t(n[r]));
                                    return e.join(",")
                                }
                                return null == a ? a = "center" === o ? "50%" : "0" : "center" === a && (a = "50%"), ("center" === o || isNaN(parseFloat(o)) && -1 === (o + "").indexOf("=")) && (o = "50%"), e = o + " " + a + (n.length > 2 ? " " + n[2] : ""), i && (i.oxp = -1 !== o.indexOf("%"), i.oyp = -1 !== a.indexOf("%"), i.oxr = "=" === o.charAt(1), i.oyr = "=" === a.charAt(1), i.ox = parseFloat(o.replace(b, "")), i.oy = parseFloat(a.replace(b, "")), i.v = e), i || e
                            },
                            ct = function (t, e) {
                                return "function" == typeof t && (t = t(A, y)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                            },
                            ut = function (t, e) {
                                return "function" == typeof t && (t = t(A, y)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                            },
                            pt = function (t, e, i, r) {
                                var n, o, a, s, l;
                                return "function" == typeof t && (t = t(A, y)), null == t ? s = e : "number" == typeof t ? s = t : (n = 360, o = t.split("_"), l = "=" === t.charAt(1), a = (l ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : z) - (l ? 0 : e), o.length && (r && (r[i] = e + a), -1 !== t.indexOf("short") && (a %= n) !== a % (n / 2) && (a = 0 > a ? a + n : a - n), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * n) % n - (a / n | 0) * n : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * n) % n - (a / n | 0) * n)), s = e + a), 1e-6 > s && s > -1e-6 && (s = 0), s
                            },
                            ft = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            },
                            dt = function (t, e, i) {
                                return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 255 * (1 > 6 * t ? e + (i - e) * t * 6 : .5 > t ? i : 2 > 3 * t ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                            },
                            mt = a.parseColor = function (t, e) {
                                var i, r, n, o, a, s, l, h, c, u, p;
                                if (t)
                                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                                    else {
                                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ft[t]) i = ft[t];
                                        else if ("#" === t.charAt(0)) 4 === t.length && (r = t.charAt(1), n = t.charAt(2), o = t.charAt(3), t = "#" + r + r + n + n + o + o), t = parseInt(t.substr(1), 16), i = [t >> 16, t >> 8 & 255, 255 & t];
                                        else if ("hsl" === t.substr(0, 3))
                                            if (i = p = t.match(x), e) {
                                                if (-1 !== t.indexOf("=")) return t.match(_)
                                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, l = Number(i[2]) / 100, n = .5 >= l ? l * (s + 1) : l + s - l * s, r = 2 * l - n, i.length > 3 && (i[3] = Number(i[3])), i[0] = dt(a + 1 / 3, r, n), i[1] = dt(a, r, n), i[2] = dt(a - 1 / 3, r, n);
                                        else i = t.match(x) || ft.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                    }
                                else i = ft.black;
                                return e && !p && (r = i[0] / 255, n = i[1] / 255, o = i[2] / 255, h = Math.max(r, n, o), c = Math.min(r, n, o), l = (h + c) / 2, h === c ? a = s = 0 : (u = h - c, s = l > .5 ? u / (2 - h - c) : u / (h + c), a = h === r ? (n - o) / u + (o > n ? 6 : 0) : h === n ? (o - r) / u + 2 : (r - n) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
                            },
                            gt = function (t, e) {
                                var i, r, n, o = t.match(vt) || [],
                                    a = 0,
                                    s = "";
                                if (!o.length) return t;
                                for (i = 0; i < o.length; i++) r = o[i], n = t.substr(a, t.indexOf(r, a) - a), a += n.length + r.length, r = mt(r, e), 3 === r.length && r.push(1), s += n + (e ? "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + r[3] : "rgba(" + r.join(",")) + ")";
                                return s + t.substr(a)
                            },
                            vt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (u in ft) vt += "|" + u + "\\b";
                        vt = new RegExp(vt + ")", "gi"), a.colorStringFilter = function (t) {
                            var e, i = t[0] + " " + t[1];
                            vt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = gt(t[0], e), t[1] = gt(t[1], e)), vt.lastIndex = 0
                        }, e.defaultStringFilter || (e.defaultStringFilter = a.colorStringFilter);
                        var yt = function (t, e, i, r) {
                                if (null == t) return function (t) {
                                    return t
                                };
                                var n, o = e ? (t.match(vt) || [""])[0] : "",
                                    a = t.split(o).join("").match(w) || [],
                                    s = t.substr(0, t.indexOf(a[0])),
                                    l = ")" === t.charAt(t.length - 1) ? ")" : "",
                                    h = -1 !== t.indexOf(" ") ? " " : ",",
                                    c = a.length,
                                    u = c > 0 ? a[0].replace(x, "") : "";
                                return c ? n = e ? function (t) {
                                    var e, p, f, d;
                                    if ("number" == typeof t) t += u;
                                    else if (r && N.test(t)) {
                                        for (d = t.replace(N, "|").split("|"), f = 0; f < d.length; f++) d[f] = n(d[f]);
                                        return d.join(",")
                                    }
                                    if (e = (t.match(vt) || [o])[0], p = t.split(e).join("").match(w) || [], f = p.length, c > f--)
                                        for (; ++f < c;) p[f] = i ? p[(f - 1) / 2 | 0] : a[f];
                                    return s + p.join(h) + h + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
                                } : function (t) {
                                    var e, o, p;
                                    if ("number" == typeof t) t += u;
                                    else if (r && N.test(t)) {
                                        for (o = t.replace(N, "|").split("|"), p = 0; p < o.length; p++) o[p] = n(o[p]);
                                        return o.join(",")
                                    }
                                    if (e = t.match(w) || [], p = e.length, c > p--)
                                        for (; ++p < c;) e[p] = i ? e[(p - 1) / 2 | 0] : a[p];
                                    return s + e.join(h) + l
                                } : function (t) {
                                    return t
                                }
                            },
                            At = function (t) {
                                return t = t.split(","),
                                    function (e, i, r, n, o, a, s) {
                                        var l, h = (i + "").split(" ");
                                        for (s = {}, l = 0; 4 > l; l++) s[t[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0];
                                        return n.parse(e, s, o, a)
                                    }
                            },
                            xt = (Y._setPluginRatio = function (t) {
                                this.plugin.setRatio(t);
                                for (var e, i, r, n, o, a = this.data, s = a.proxy, l = a.firstMPT; l;) e = s[l.v], l.r ? e = l.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next;
                                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                                    for (l = a.firstMPT, o = 1 === t ? "e" : "b"; l;) {
                                        if (i = l.t, i.type) {
                                            if (1 === i.type) {
                                                for (n = i.xs0 + i.s + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                                                i[o] = n
                                            }
                                        } else i[o] = i.s + i.xs0;
                                        l = l._next
                                    }
                            }, function (t, e, i, r, n) {
                                this.t = t, this.p = e, this.v = i, this.r = n, r && (r._prev = this, this._next = r)
                            }),
                            _t = (Y._parseToProxy = function (t, e, i, r, n, o) {
                                var a, s, l, h, c, u = r,
                                    p = {},
                                    f = {},
                                    d = i._transform,
                                    m = U;
                                for (i._transform = null, U = e, r = c = i.parse(t, e, r, n), U = m, o && (i._transform = d, u && (u._prev = null, u._prev && (u._prev._next = null))); r && r !== u;) {
                                    if (r.type <= 1 && (s = r.p, f[s] = r.s + r.c, p[s] = r.s, o || (h = new xt(r, "s", s, h, r.r), r.c = 0), 1 === r.type))
                                        for (a = r.l; --a > 0;) l = "xn" + a, s = r.p + "_" + l, f[s] = r.data[l], p[s] = r[l], o || (h = new xt(r, l, s, h, r.rxp[l]));
                                    r = r._next
                                }
                                return {
                                    proxy: p,
                                    end: f,
                                    firstMPT: h,
                                    pt: c
                                }
                            }, Y.CSSPropTween = function (t, e, r, n, a, s, l, h, c, u, p) {
                                this.t = t, this.p = e, this.s = r, this.c = n, this.n = l || e, t instanceof _t || o.push(this.n), this.r = h ? "function" == typeof h ? h : Math.round : h, this.type = s || 0, c && (this.pr = c, i = !0), this.b = void 0 === u ? r : u, this.e = void 0 === p ? r + n : p, a && (this._next = a, a._prev = this)
                            }),
                            wt = function (t, e, i, r, n, o) {
                                var a = new _t(t, e, i, r - i, n, -1, o);
                                return a.b = i, a.e = a.xs0 = r, a
                            },
                            bt = a.parseComplex = function (t, e, i, r, n, o, s, l, h, c) {
                                i = i || o || "", "function" == typeof r && (r = r(A, y)), s = new _t(t, e, 0, 0, s, c ? 2 : 1, null, !1, l, i, r), r += "", n && vt.test(r + i) && (r = [i, r], a.colorStringFilter(r), i = r[0], r = r[1]);
                                var u, f, d, m, g, v, w, b, M, T, S, E, C, P = i.split(", ").join(",").split(" "),
                                    L = r.split(", ").join(",").split(" "),
                                    D = P.length,
                                    R = !1 !== p;
                                for ((-1 !== r.indexOf(",") || -1 !== i.indexOf(",")) && (-1 !== (r + i).indexOf("rgb") || -1 !== (r + i).indexOf("hsl") ? (P = P.join(" ").replace(N, ", ").split(" "), L = L.join(" ").replace(N, ", ").split(" ")) : (P = P.join(" ").split(",").join(", ").split(" "), L = L.join(" ").split(",").join(", ").split(" ")), D = P.length), D !== L.length && (P = (o || "").split(" "), D = P.length), s.plugin = h, s.setRatio = c, vt.lastIndex = 0, u = 0; D > u; u++)
                                    if (m = P[u], g = L[u] + "", (b = parseFloat(m)) || 0 === b) s.appendXtra("", b, ct(g, b), g.replace(_, ""), !(!R || -1 === g.indexOf("px")) && Math.round, !0);
                                    else if (n && vt.test(m)) E = g.indexOf(")") + 1, E = ")" + (E ? g.substr(E) : ""), C = -1 !== g.indexOf("hsl") && Q, T = g, m = mt(m, C), g = mt(g, C), M = m.length + g.length > 6, M && !Q && 0 === g[3] ? (s["xs" + s.l] += s.l ? " transparent" : "transparent", s.e = s.e.split(L[u]).join("transparent")) : (Q || (M = !1), C ? s.appendXtra(T.substr(0, T.indexOf("hsl")) + (M ? "hsla(" : "hsl("), m[0], ct(g[0], m[0]), ",", !1, !0).appendXtra("", m[1], ct(g[1], m[1]), "%,", !1).appendXtra("", m[2], ct(g[2], m[2]), M ? "%," : "%" + E, !1) : s.appendXtra(T.substr(0, T.indexOf("rgb")) + (M ? "rgba(" : "rgb("), m[0], g[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], g[1] - m[1], ",", Math.round).appendXtra("", m[2], g[2] - m[2], M ? "," : E, Math.round), M && (m = m.length < 4 ? 1 : m[3], s.appendXtra("", m, (g.length < 4 ? 1 : g[3]) - m, E, !1))), vt.lastIndex = 0;
                                else if (v = m.match(x)) {
                                    if (!(w = g.match(_)) || w.length !== v.length) return s;
                                    for (d = 0, f = 0; f < v.length; f++) S = v[f], T = m.indexOf(S, d), s.appendXtra(m.substr(d, T - d), Number(S), ct(w[f], S), "", !(!R || "px" !== m.substr(T + S.length, 2)) && Math.round, 0 === f), d = T + S.length;
                                    s["xs" + s.l] += m.substr(d)
                                } else s["xs" + s.l] += s.l || s["xs" + s.l] ? " " + g : g;
                                if (-1 !== r.indexOf("=") && s.data) {
                                    for (E = s.xs0 + s.data.s, u = 1; u < s.l; u++) E += s["xs" + u] + s.data["xn" + u];
                                    s.e = E + s["xs" + u]
                                }
                                return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s
                            },
                            Mt = 9;
                        for (u = _t.prototype, u.l = u.pr = 0; --Mt > 0;) u["xn" + Mt] = 0, u["xs" + Mt] = "";
                        u.xs0 = "", u._next = u._prev = u.xfirst = u.data = u.plugin = u.setRatio = u.rxp = null, u.appendXtra = function (t, e, i, r, n, o) {
                            var a = this,
                                s = a.l;
                            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = r || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = n, a["xn" + s] = e, a.plugin || (a.xfirst = new _t(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, n, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                s: e + i
                            }, a.rxp = {}, a.s = e, a.c = i, a.r = n, a)) : (a["xs" + s] += e + (r || ""), a)
                        };
                        var Tt = function (t, e) {
                                e = e || {}, this.p = e.prefix ? $(t) || t : t, c[t] = c[this.p] = this, this.format = e.formatter || yt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                            },
                            St = Y._registerComplexSpecialProp = function (t, e, i) {
                                "object" != (void 0 === e ? "undefined" : (0, s.default)(e)) && (e = {
                                    parser: i
                                });
                                var r, n = t.split(","),
                                    o = e.defaultValue;
                                for (i = i || [o], r = 0; r < n.length; r++) e.prefix = 0 === r && e.prefix, e.defaultValue = i[r] || o, new Tt(n[r], e)
                            },
                            Et = Y._registerPluginProp = function (t) {
                                if (!c[t]) {
                                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                    St(t, {
                                        parser: function (t, i, r, n, o, a, s) {
                                            var l = h.com.greensock.plugins[e];
                                            return l ? (l._cssRegister(), c[r].parse(t, i, r, n, o, a, s)) : (q("Error: " + e + " js file not loaded."), o)
                                        }
                                    })
                                }
                            };
                        u = Tt.prototype, u.parseComplex = function (t, e, i, r, n, o) {
                            var a, s, l, h, c, u, p = this.keyword;
                            if (this.multi && (N.test(i) || N.test(e) ? (s = e.replace(N, "|").split("|"), l = i.replace(N, "|").split("|")) : p && (s = [e], l = [i])), l) {
                                for (h = l.length > s.length ? l.length : s.length, a = 0; h > a; a++) e = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (c = e.indexOf(p), u = i.indexOf(p), c !== u && (-1 === u ? s[a] = s[a].split(p).join("") : -1 === c && (s[a] += " " + p)));
                                e = s.join(", "), i = l.join(", ")
                            }
                            return bt(t, this.p, e, i, this.clrs, this.dflt, r, this.pr, n, o)
                        }, u.parse = function (t, e, i, r, o, a, s) {
                            return this.parseComplex(t.style, this.format(et(t, this.p, n, !1, this.dflt)), this.format(e), o, a)
                        }, a.registerSpecialProp = function (t, e, i) {
                            St(t, {
                                parser: function (t, r, n, o, a, s, l) {
                                    var h = new _t(t, n, 0, 0, a, 2, n, !1, i);
                                    return h.plugin = s, h.setRatio = e(t, r, o._tween, n), h
                                },
                                priority: i
                            })
                        }, a.useSVGTransformAttr = !0;
                        var Ct, Pt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Lt = $("transform"),
                            Dt = Z + "transform",
                            Rt = $("transformOrigin"),
                            It = null !== $("perspective"),
                            Ot = Y.Transform = function () {
                                this.perspective = parseFloat(a.defaultTransformPerspective) || 0, this.force3D = !(!1 === a.defaultForce3D || !It) && (a.defaultForce3D || "auto")
                            },
                            Bt = l.SVGElement,
                            Nt = function (t, e, i) {
                                var r, n = V.createElementNS("http://www.w3.org/2000/svg", t),
                                    o = /([a-z])([A-Z])/g;
                                for (r in i) n.setAttributeNS(null, r.replace(o, "$1-$2").toLowerCase(), i[r]);
                                return e.appendChild(n), n
                            },
                            kt = V.documentElement || {},
                            Ft = function () {
                                var t, e, i, r = v || /Android/i.test(X) && !l.chrome;
                                return V.createElementNS && !r && (t = Nt("svg", kt), e = Nt("rect", t, {
                                    width: 100,
                                    height: 50,
                                    x: 100
                                }), i = e.getBoundingClientRect().width, e.style[Rt] = "50% 50%", e.style[Lt] = "scaleX(0.5)", r = i === e.getBoundingClientRect().width && !(m && It), kt.removeChild(t)), r
                            }(),
                            zt = function (t, e, i, r, n, o) {
                                var s, l, h, c, u, p, f, d, m, g, v, y, A, x, _ = t._gsTransform,
                                    w = jt(t, !0);
                                _ && (A = _.xOrigin, x = _.yOrigin), (!r || (s = r.split(" ")).length < 2) && (f = t.getBBox(), 0 === f.x && 0 === f.y && f.width + f.height === 0 && (f = {
                                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                    width: 0,
                                    height: 0
                                }), e = ht(e).split(" "), s = [(-1 !== e[0].indexOf("%") ? parseFloat(e[0]) / 100 * f.width : parseFloat(e[0])) + f.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * f.height : parseFloat(e[1])) + f.y]), i.xOrigin = c = parseFloat(s[0]), i.yOrigin = u = parseFloat(s[1]), r && w !== Ht && (p = w[0], f = w[1], d = w[2], m = w[3], g = w[4], v = w[5], (y = p * m - f * d) && (l = c * (m / y) + u * (-d / y) + (d * v - m * g) / y, h = c * (-f / y) + u * (p / y) - (p * v - f * g) / y, c = i.xOrigin = s[0] = l, u = i.yOrigin = s[1] = h)), _ && (o && (i.xOffset = _.xOffset, i.yOffset = _.yOffset, _ = i), n || !1 !== n && !1 !== a.defaultSmoothOrigin ? (l = c - A, h = u - x, _.xOffset += l * w[0] + h * w[2] - l, _.yOffset += l * w[1] + h * w[3] - h) : _.xOffset = _.yOffset = 0), o || t.setAttribute("data-svg-origin", s.join(" "))
                            },
                            Ut = function t(e) {
                                var i, r = H("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    n = this.parentNode,
                                    o = this.nextSibling,
                                    a = this.style.cssText;
                                if (kt.appendChild(r), r.appendChild(this), this.style.display = "block", e) try {
                                    i = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = t
                                } catch (t) {} else this._originalGetBBox && (i = this._originalGetBBox());
                                return o ? n.insertBefore(this, o) : n.appendChild(this), kt.removeChild(r), this.style.cssText = a, i
                            },
                            Gt = function (t) {
                                try {
                                    return t.getBBox()
                                } catch (e) {
                                    return Ut.call(t, !0)
                                }
                            },
                            Vt = function (t) {
                                return !(!Bt || !t.getCTM || t.parentNode && !t.ownerSVGElement || !Gt(t))
                            },
                            Ht = [1, 0, 0, 1, 0, 0],
                            jt = function (t, e) {
                                var i, r, n, o, a, s, l = t._gsTransform || new Ot,
                                    h = t.style;
                                if (Lt ? r = et(t, Dt, null, !0) : t.currentStyle && (r = t.currentStyle.filter.match(O), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, !Lt || !(s = !tt(t) || "none" === tt(t).display) && t.parentNode || (s && (o = h.display, h.display = "block"), t.parentNode || (a = 1, kt.appendChild(t)), r = et(t, Dt, null, !0), i = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, o ? h.display = o : s && Jt(h, "display"), a && kt.removeChild(t)), (l.svg || t.getCTM && Vt(t)) && (i && -1 !== (h[Lt] + "").indexOf("matrix") && (r = h[Lt], i = 0), n = t.getAttribute("transform"), i && n && (n = t.transform.baseVal.consolidate().matrix, r = "matrix(" + n.a + "," + n.b + "," + n.c + "," + n.d + "," + n.e + "," + n.f + ")", i = 0)), i) return Ht;
                                for (n = (r || "").match(x) || [], Mt = n.length; --Mt > -1;) o = Number(n[Mt]), n[Mt] = (a = o - (o |= 0)) ? (1e5 * a + (0 > a ? -.5 : .5) | 0) / 1e5 + o : o;
                                return e && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n
                            },
                            Wt = Y.getTransform = function (t, i, r, n) {
                                if (t._gsTransform && r && !n) return t._gsTransform;
                                var o, s, l, h, c, u, p = r ? t._gsTransform || new Ot : new Ot,
                                    f = p.scaleX < 0,
                                    d = 2e-5,
                                    m = 1e5,
                                    g = It ? parseFloat(et(t, Rt, i, !1, "0 0 0").split(" ")[2]) || p.zOrigin || 0 : 0,
                                    v = parseFloat(a.defaultTransformPerspective) || 0;
                                if (p.svg = !(!t.getCTM || !Vt(t)), p.svg && (zt(t, et(t, Rt, i, !1, "50% 50%") + "", p, t.getAttribute("data-svg-origin")), Ct = a.useSVGTransformAttr || Ft), (o = jt(t)) !== Ht) {
                                    if (16 === o.length) {
                                        var y, A, x, _, w, b = o[0],
                                            M = o[1],
                                            T = o[2],
                                            S = o[3],
                                            E = o[4],
                                            C = o[5],
                                            P = o[6],
                                            L = o[7],
                                            D = o[8],
                                            R = o[9],
                                            I = o[10],
                                            O = o[12],
                                            B = o[13],
                                            N = o[14],
                                            k = o[11],
                                            F = Math.atan2(P, I);
                                        p.zOrigin && (N = -p.zOrigin, O = D * N - o[12], B = R * N - o[13], N = I * N + p.zOrigin - o[14]), p.rotationX = F * z, F && (_ = Math.cos(-F), w = Math.sin(-F), y = E * _ + D * w, A = C * _ + R * w, x = P * _ + I * w, D = E * -w + D * _, R = C * -w + R * _, I = P * -w + I * _, k = L * -w + k * _, E = y, C = A, P = x), F = Math.atan2(-T, I), p.rotationY = F * z, F && (_ = Math.cos(-F), w = Math.sin(-F), y = b * _ - D * w, A = M * _ - R * w, x = T * _ - I * w, R = M * w + R * _, I = T * w + I * _, k = S * w + k * _, b = y, M = A, T = x), F = Math.atan2(M, b), p.rotation = F * z, F && (_ = Math.cos(F), w = Math.sin(F), y = b * _ + M * w, A = E * _ + C * w, x = D * _ + R * w, M = M * _ - b * w, C = C * _ - E * w, R = R * _ - D * w, b = y, E = A, D = x), p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY), F = Math.atan2(E, C), p.scaleX = (Math.sqrt(b * b + M * M + T * T) * m + .5 | 0) / m, p.scaleY = (Math.sqrt(C * C + P * P) * m + .5 | 0) / m, p.scaleZ = (Math.sqrt(D * D + R * R + I * I) * m + .5 | 0) / m, b /= p.scaleX, E /= p.scaleY, M /= p.scaleX, C /= p.scaleY, Math.abs(F) > d ? (p.skewX = F * z, E = 0, "simple" !== p.skewType && (p.scaleY *= 1 / Math.cos(F))) : p.skewX = 0, p.perspective = k ? 1 / (0 > k ? -k : k) : 0, p.x = O, p.y = B, p.z = N, p.svg && (p.x -= p.xOrigin - (p.xOrigin * b - p.yOrigin * E), p.y -= p.yOrigin - (p.yOrigin * M - p.xOrigin * C))
                                    } else if (!It || n || !o.length || p.x !== o[4] || p.y !== o[5] || !p.rotationX && !p.rotationY) {
                                        var U = o.length >= 6,
                                            G = U ? o[0] : 1,
                                            V = o[1] || 0,
                                            H = o[2] || 0,
                                            j = U ? o[3] : 1;
                                        p.x = o[4] || 0, p.y = o[5] || 0, l = Math.sqrt(G * G + V * V), h = Math.sqrt(j * j + H * H), c = G || V ? Math.atan2(V, G) * z : p.rotation || 0, u = H || j ? Math.atan2(H, j) * z + c : p.skewX || 0, p.scaleX = l, p.scaleY = h, p.rotation = c, p.skewX = u, It && (p.rotationX = p.rotationY = p.z = 0, p.perspective = v, p.scaleZ = 1), p.svg && (p.x -= p.xOrigin - (p.xOrigin * G + p.yOrigin * H), p.y -= p.yOrigin - (p.xOrigin * V + p.yOrigin * j))
                                    }
                                    Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (f ? (p.scaleX *= -1, p.skewX += p.rotation <= 0 ? 180 : -180, p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1, p.skewX += p.skewX <= 0 ? 180 : -180)), p.zOrigin = g;
                                    for (s in p) p[s] < d && p[s] > -d && (p[s] = 0)
                                }
                                return r && (t._gsTransform = p, p.svg && (Ct && t.style[Lt] ? e.delayedCall(.001, function () {
                                    Jt(t.style, Lt)
                                }) : !Ct && t.getAttribute("transform") && e.delayedCall(.001, function () {
                                    t.removeAttribute("transform")
                                }))), p
                            },
                            Yt = function (t) {
                                var e, i, r = this.data,
                                    n = -r.rotation * F,
                                    o = n + r.skewX * F,
                                    a = 1e5,
                                    s = (Math.cos(n) * r.scaleX * a | 0) / a,
                                    l = (Math.sin(n) * r.scaleX * a | 0) / a,
                                    h = (Math.sin(o) * -r.scaleY * a | 0) / a,
                                    c = (Math.cos(o) * r.scaleY * a | 0) / a,
                                    u = this.t.style,
                                    p = this.t.currentStyle;
                                if (p) {
                                    i = l, l = -h, h = -i, e = p.filter, u.filter = "";
                                    var f, d, m = this.t.offsetWidth,
                                        g = this.t.offsetHeight,
                                        y = "absolute" !== p.position,
                                        A = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + h + ", M22=" + c,
                                        x = r.x + m * r.xPercent / 100,
                                        _ = r.y + g * r.yPercent / 100;
                                    if (null != r.ox && (f = (r.oxp ? m * r.ox * .01 : r.ox) - m / 2, d = (r.oyp ? g * r.oy * .01 : r.oy) - g / 2, x += f - (f * s + d * l), _ += d - (f * h + d * c)), y ? (f = m / 2, d = g / 2, A += ", Dx=" + (f - (f * s + d * l) + x) + ", Dy=" + (d - (f * h + d * c) + _) + ")") : A += ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = e.replace(B, A) : u.filter = A + " " + e, (0 === t || 1 === t) && 1 === s && 0 === l && 0 === h && 1 === c && (y && -1 === A.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && u.removeAttribute("filter")), !y) {
                                        var w, b, S, E = 8 > v ? 1 : -1;
                                        for (f = r.ieOffsetX || 0, d = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > s ? -s : s) * m + (0 > l ? -l : l) * g)) / 2 + x), r.ieOffsetY = Math.round((g - ((0 > c ? -c : c) * g + (0 > h ? -h : h) * m)) / 2 + _), Mt = 0; 4 > Mt; Mt++) b = st[Mt], w = p[b], i = -1 !== w.indexOf("px") ? parseFloat(w) : it(this.t, b, parseFloat(w), w.replace(M, "")) || 0, S = i !== r[b] ? 2 > Mt ? -r.ieOffsetX : -r.ieOffsetY : 2 > Mt ? f - r.ieOffsetX : d - r.ieOffsetY, u[b] = (r[b] = Math.round(i - S * (0 === Mt || 2 === Mt ? 1 : E))) + "px"
                                    }
                                }
                            },
                            Xt = Y.set3DTransformRatio = Y.setTransformRatio = function (t) {
                                var e, i, r, n, o, a, s, l, h, c, u, p, f, d, g, v, y, A, x, _, w, b, M, T = this.data,
                                    S = this.t.style,
                                    E = T.rotation,
                                    C = T.rotationX,
                                    P = T.rotationY,
                                    L = T.scaleX,
                                    D = T.scaleY,
                                    R = T.scaleZ,
                                    I = T.x,
                                    O = T.y,
                                    B = T.z,
                                    N = T.svg,
                                    k = T.perspective,
                                    z = T.force3D,
                                    U = T.skewY,
                                    G = T.skewX;
                                if (U && (G += U, E += U), ((1 === t || 0 === t) && "auto" === z && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !z) && !B && !k && !P && !C && 1 === R || Ct && N || !It) return void(E || G || N ? (E *= F, b = G * F, M = 1e5, i = Math.cos(E) * L, o = Math.sin(E) * L, r = Math.sin(E - b) * -D, a = Math.cos(E - b) * D, b && "simple" === T.skewType && (e = Math.tan(b - U * F), e = Math.sqrt(1 + e * e), r *= e, a *= e, U && (e = Math.tan(U * F), e = Math.sqrt(1 + e * e), i *= e, o *= e)), N && (I += T.xOrigin - (T.xOrigin * i + T.yOrigin * r) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset, Ct && (T.xPercent || T.yPercent) && (g = this.t.getBBox(), I += .01 * T.xPercent * g.width, O += .01 * T.yPercent * g.height), g = 1e-6, g > I && I > -g && (I = 0), g > O && O > -g && (O = 0)), x = (i * M | 0) / M + "," + (o * M | 0) / M + "," + (r * M | 0) / M + "," + (a * M | 0) / M + "," + I + "," + O + ")", N && Ct ? this.t.setAttribute("transform", "matrix(" + x) : S[Lt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + x) : S[Lt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + L + ",0,0," + D + "," + I + "," + O + ")");
                                if (m && (g = 1e-4, g > L && L > -g && (L = R = 2e-5), g > D && D > -g && (D = R = 2e-5), !k || T.z || T.rotationX || T.rotationY || (k = 0)), E || G) E *= F, v = i = Math.cos(E), y = o = Math.sin(E), G && (E -= G * F, v = Math.cos(E), y = Math.sin(E), "simple" === T.skewType && (e = Math.tan((G - U) * F), e = Math.sqrt(1 + e * e), v *= e, y *= e, T.skewY && (e = Math.tan(U * F), e = Math.sqrt(1 + e * e), i *= e, o *= e))), r = -y, a = v;
                                else {
                                    if (!(P || C || 1 !== R || k || N)) return void(S[Lt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + O + "px," + B + "px)" + (1 !== L || 1 !== D ? " scale(" + L + "," + D + ")" : ""));
                                    i = a = 1, r = o = 0
                                }
                                c = 1, n = s = l = h = u = p = 0, f = k ? -1 / k : 0, d = T.zOrigin, g = 1e-6, _ = ",", w = "0", E = P * F, E && (v = Math.cos(E), y = Math.sin(E), l = -y, u = f * -y, n = i * y, s = o * y, c = v, f *= v, i *= v, o *= v), E = C * F, E && (v = Math.cos(E), y = Math.sin(E), e = r * v + n * y, A = a * v + s * y, h = c * y, p = f * y, n = r * -y + n * v, s = a * -y + s * v, c *= v, f *= v, r = e, a = A), 1 !== R && (n *= R, s *= R, c *= R, f *= R), 1 !== D && (r *= D, a *= D, h *= D, p *= D), 1 !== L && (i *= L, o *= L, l *= L, u *= L), (d || N) && (d && (I += n * -d, O += s * -d, B += c * -d + d), N && (I += T.xOrigin - (T.xOrigin * i + T.yOrigin * r) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset), g > I && I > -g && (I = w), g > O && O > -g && (O = w), g > B && B > -g && (B = 0)), x = T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix3d(" : "matrix3d(", x += (g > i && i > -g ? w : i) + _ + (g > o && o > -g ? w : o) + _ + (g > l && l > -g ? w : l), x += _ + (g > u && u > -g ? w : u) + _ + (g > r && r > -g ? w : r) + _ + (g > a && a > -g ? w : a), C || P || 1 !== R ? (x += _ + (g > h && h > -g ? w : h) + _ + (g > p && p > -g ? w : p) + _ + (g > n && n > -g ? w : n), x += _ + (g > s && s > -g ? w : s) + _ + (g > c && c > -g ? w : c) + _ + (g > f && f > -g ? w : f) + _) : x += ",0,0,0,0,1,0,", x += I + _ + O + _ + B + _ + (k ? 1 + -B / k : 1) + ")", S[Lt] = x
                            };
                        u = Ot.prototype, u.x = u.y = u.z = u.skewX = u.skewY = u.rotation = u.rotationX = u.rotationY = u.zOrigin = u.xPercent = u.yPercent = u.xOffset = u.yOffset = 0, u.scaleX = u.scaleY = u.scaleZ = 1, St("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                            parser: function (t, e, i, r, o, l, h) {
                                if (r._lastParsedTransform === h) return o;
                                r._lastParsedTransform = h;
                                var c, u = h.scale && "function" == typeof h.scale ? h.scale : 0;
                                "function" == typeof h[i] && (c = h[i], h[i] = e), u && (h.scale = u(A, t));
                                var p, f, d, m, g, v, x, _, w, b = t._gsTransform,
                                    M = t.style,
                                    T = Pt.length,
                                    S = h,
                                    E = {},
                                    C = "transformOrigin",
                                    P = Wt(t, n, !0, S.parseTransform),
                                    L = S.transform && ("function" == typeof S.transform ? S.transform(A, y) : S.transform);
                                if (P.skewType = S.skewType || P.skewType || a.defaultSkewType, r._transform = P, L && "string" == typeof L && Lt) f = j.style, f[Lt] = L, f.display = "block", f.position = "absolute", -1 !== L.indexOf("%") && (f.width = et(t, "width"), f.height = et(t, "height")), V.body.appendChild(j), p = Wt(j, null, !1), "simple" === P.skewType && (p.scaleY *= Math.cos(p.skewX * F)), P.svg && (v = P.xOrigin, x = P.yOrigin, p.x -= P.xOffset, p.y -= P.yOffset, (S.transformOrigin || S.svgOrigin) && (L = {}, zt(t, ht(S.transformOrigin), L, S.svgOrigin, S.smoothOrigin, !0), v = L.xOrigin, x = L.yOrigin, p.x -= L.xOffset - P.xOffset, p.y -= L.yOffset - P.yOffset), (v || x) && (_ = jt(j, !0), p.x -= v - (v * _[0] + x * _[2]), p.y -= x - (v * _[1] + x * _[3]))), V.body.removeChild(j), p.perspective || (p.perspective = P.perspective), null != S.xPercent && (p.xPercent = ut(S.xPercent, P.xPercent)), null != S.yPercent && (p.yPercent = ut(S.yPercent, P.yPercent));
                                else if ("object" == (void 0 === S ? "undefined" : (0, s.default)(S))) {
                                    if (p = {
                                            scaleX: ut(null != S.scaleX ? S.scaleX : S.scale, P.scaleX),
                                            scaleY: ut(null != S.scaleY ? S.scaleY : S.scale, P.scaleY),
                                            scaleZ: ut(S.scaleZ, P.scaleZ),
                                            x: ut(S.x, P.x),
                                            y: ut(S.y, P.y),
                                            z: ut(S.z, P.z),
                                            xPercent: ut(S.xPercent, P.xPercent),
                                            yPercent: ut(S.yPercent, P.yPercent),
                                            perspective: ut(S.transformPerspective, P.perspective)
                                        }, null != (g = S.directionalRotation))
                                        if ("object" == (void 0 === g ? "undefined" : (0, s.default)(g)))
                                            for (f in g) S[f] = g[f];
                                        else S.rotation = g;
                                    "string" == typeof S.x && -1 !== S.x.indexOf("%") && (p.x = 0, p.xPercent = ut(S.x, P.xPercent)), "string" == typeof S.y && -1 !== S.y.indexOf("%") && (p.y = 0, p.yPercent = ut(S.y, P.yPercent)), p.rotation = pt("rotation" in S ? S.rotation : "shortRotation" in S ? S.shortRotation + "_short" : "rotationZ" in S ? S.rotationZ : P.rotation, P.rotation, "rotation", E), It && (p.rotationX = pt("rotationX" in S ? S.rotationX : "shortRotationX" in S ? S.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", E), p.rotationY = pt("rotationY" in S ? S.rotationY : "shortRotationY" in S ? S.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", E)), p.skewX = pt(S.skewX, P.skewX), p.skewY = pt(S.skewY, P.skewY)
                                }
                                for (It && null != S.force3D && (P.force3D = S.force3D, m = !0), (d = P.force3D || P.z || P.rotationX || P.rotationY || p.z || p.rotationX || p.rotationY || p.perspective) || null == S.scale || (p.scaleZ = 1); --T > -1;) w = Pt[T], ((L = p[w] - P[w]) > 1e-6 || -1e-6 > L || null != S[w] || null != U[w]) && (m = !0, o = new _t(P, w, P[w], L, o), w in E && (o.e = E[w]), o.xs0 = 0, o.plugin = l, r._overwriteProps.push(o.n));
                                return L = S.transformOrigin, P.svg && (L || S.svgOrigin) && (v = P.xOffset, x = P.yOffset, zt(t, ht(L), p, S.svgOrigin, S.smoothOrigin), o = wt(P, "xOrigin", (b ? P : p).xOrigin, p.xOrigin, o, C), o = wt(P, "yOrigin", (b ? P : p).yOrigin, p.yOrigin, o, C), (v !== P.xOffset || x !== P.yOffset) && (o = wt(P, "xOffset", b ? v : P.xOffset, P.xOffset, o, C), o = wt(P, "yOffset", b ? x : P.yOffset, P.yOffset, o, C)), L = "0px 0px"), (L || It && d && P.zOrigin) && (Lt ? (m = !0, w = Rt, L = (L || et(t, w, n, !1, "50% 50%")) + "", o = new _t(M, w, 0, 0, o, -1, C), o.b = M[w], o.plugin = l, It ? (f = P.zOrigin, L = L.split(" "), P.zOrigin = (L.length > 2 && (0 === f || "0px" !== L[2]) ? parseFloat(L[2]) : f) || 0, o.xs0 = o.e = L[0] + " " + (L[1] || "50%") + " 0px", o = new _t(P, "zOrigin", 0, 0, o, -1, o.n), o.b = f, o.xs0 = o.e = P.zOrigin) : o.xs0 = o.e = L) : ht(L + "", P)), m && (r._transformType = P.svg && Ct || !d && 3 !== this._transformType ? 2 : 3), c && (h[i] = c), u && (h.scale = u), o
                            },
                            prefix: !0
                        }), St("boxShadow", {
                            defaultValue: "0px 0px 0px 0px #999",
                            prefix: !0,
                            color: !0,
                            multi: !0,
                            keyword: "inset"
                        }), St("borderRadius", {
                            defaultValue: "0px",
                            parser: function (t, e, i, o, a, s) {
                                e = this.format(e);
                                var l, h, c, u, p, f, d, m, g, v, y, A, x, _, w, b, M = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    T = t.style;
                                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(" "), h = 0; h < M.length; h++) this.p.indexOf("border") && (M[h] = $(M[h])), p = u = et(t, M[h], n, !1, "0px"), -1 !== p.indexOf(" ") && (u = p.split(" "), p = u[0], u = u[1]), f = c = l[h], d = parseFloat(p), A = p.substr((d + "").length), x = "=" === f.charAt(1), x ? (m = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), m *= parseFloat(f), y = f.substr((m + "").length - (0 > m ? 1 : 0)) || "") : (m = parseFloat(f), y = f.substr((m + "").length)), "" === y && (y = r[i] || A), y !== A && (_ = it(t, "borderLeft", d, A), w = it(t, "borderTop", d, A), "%" === y ? (p = _ / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (b = it(t, "borderLeft", 1, "em"), p = _ / b + "em", u = w / b + "em") : (p = _ + "px", u = w + "px"), x && (f = parseFloat(p) + m + y, c = parseFloat(u) + m + y)), a = bt(T, M[h], p + " " + u, f + " " + c, !1, "0px", a);
                                return a
                            },
                            prefix: !0,
                            formatter: yt("0px 0px 0px 0px", !1, !0)
                        }), St("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                            defaultValue: "0px",
                            parser: function (t, e, i, r, o, a) {
                                return bt(t.style, i, this.format(et(t, i, n, !1, "0px 0px")), this.format(e), !1, "0px", o)
                            },
                            prefix: !0,
                            formatter: yt("0px 0px", !1, !0)
                        }), St("backgroundPosition", {
                            defaultValue: "0 0",
                            parser: function (t, e, i, r, o, a) {
                                var s, l, h, c, u, p, f = "background-position",
                                    d = n || tt(t, null),
                                    m = this.format((d ? v ? d.getPropertyValue(f + "-x") + " " + d.getPropertyValue(f + "-y") : d.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                    g = this.format(e);
                                if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && g.split(",").length < 2 && (p = et(t, "backgroundImage").replace(D, "")) && "none" !== p) {
                                    for (s = m.split(" "), l = g.split(" "), W.setAttribute("src", p), h = 2; --h > -1;) m = s[h], (c = -1 !== m.indexOf("%")) !== (-1 !== l[h].indexOf("%")) && (u = 0 === h ? t.offsetWidth - W.width : t.offsetHeight - W.height, s[h] = c ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                    m = s.join(" ")
                                }
                                return this.parseComplex(t.style, m, g, o, a)
                            },
                            formatter: ht
                        }), St("backgroundSize", {
                            defaultValue: "0 0",
                            formatter: function (t) {
                                return t += "", "co" === t.substr(0, 2) ? t : ht(-1 === t.indexOf(" ") ? t + " " + t : t)
                            }
                        }), St("perspective", {
                            defaultValue: "0px",
                            prefix: !0
                        }), St("perspectiveOrigin", {
                            defaultValue: "50% 50%",
                            prefix: !0
                        }), St("transformStyle", {
                            prefix: !0
                        }), St("backfaceVisibility", {
                            prefix: !0
                        }), St("userSelect", {
                            prefix: !0
                        }), St("margin", {
                            parser: At("marginTop,marginRight,marginBottom,marginLeft")
                        }), St("padding", {
                            parser: At("paddingTop,paddingRight,paddingBottom,paddingLeft")
                        }), St("clip", {
                            defaultValue: "rect(0px,0px,0px,0px)",
                            parser: function (t, e, i, r, o, a) {
                                var s, l, h;
                                return 9 > v ? (l = t.currentStyle, h = 8 > v ? " " : ",", s = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", e = this.format(e).split(",").join(h)) : (s = this.format(et(t, this.p, n, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, o, a)
                            }
                        }), St("textShadow", {
                            defaultValue: "0px 0px 0px #999",
                            color: !0,
                            multi: !0
                        }), St("autoRound,strictUnits", {
                            parser: function (t, e, i, r, n) {
                                return n
                            }
                        }), St("border", {
                            defaultValue: "0px solid #000",
                            parser: function (t, e, i, r, o, a) {
                                var s = et(t, "borderTopWidth", n, !1, "0px"),
                                    l = this.format(e).split(" "),
                                    h = l[0].replace(M, "");
                                return "px" !== h && (s = parseFloat(s) / it(t, "borderTopWidth", 1, h) + h), this.parseComplex(t.style, this.format(s + " " + et(t, "borderTopStyle", n, !1, "solid") + " " + et(t, "borderTopColor", n, !1, "#000")), l.join(" "), o, a)
                            },
                            color: !0,
                            formatter: function (t) {
                                var e = t.split(" ");
                                return e[0] + " " + (e[1] || "solid") + " " + (t.match(vt) || ["#000"])[0]
                            }
                        }), St("borderWidth", {
                            parser: At("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                        }), St("float,cssFloat,styleFloat", {
                            parser: function (t, e, i, r, n, o) {
                                var a = t.style,
                                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                return new _t(a, s, 0, 0, n, -1, i, !1, 0, a[s], e)
                            }
                        });
                        var Qt = function (t) {
                            var e, i = this.t,
                                r = i.filter || et(this.data, "filter") || "",
                                n = this.s + this.c * t | 0;
                            100 === n && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (i.removeAttribute("filter"), e = !et(this.data, "filter")) : (i.filter = r.replace(E, ""), e = !0)), e || (this.xn1 && (i.filter = r = r || "alpha(opacity=" + n + ")"), -1 === r.indexOf("pacity") ? 0 === n && this.xn1 || (i.filter = r + " alpha(opacity=" + n + ")") : i.filter = r.replace(T, "opacity=" + n))
                        };
                        St("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function (t, e, i, r, o, a) {
                                var s = parseFloat(et(t, "opacity", n, !1, "1")),
                                    l = t.style,
                                    h = "autoAlpha" === i;
                                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), h && 1 === s && "hidden" === et(t, "visibility", n) && 0 !== e && (s = 0), Q ? o = new _t(l, "opacity", s, e - s, o) : (o = new _t(l, "opacity", 100 * s, 100 * (e - s), o), o.xn1 = h ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = a, o.setRatio = Qt), h && (o = new _t(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), o.xs0 = "inherit", r._overwriteProps.push(o.n), r._overwriteProps.push(i)), o
                            }
                        });
                        var Jt = function (t, e) {
                                e && (t.removeProperty ? (("ms" === e.substr(0, 2) || "webkit" === e.substr(0, 6)) && (e = "-" + e), t.removeProperty(e.replace(P, "-$1").toLowerCase())) : t.removeAttribute(e))
                            },
                            qt = function (t) {
                                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Jt(i, e.p), e = e._next;
                                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                        St("className", {
                            parser: function (t, e, r, o, a, s, l) {
                                var h, c, u, p, f, d = t.getAttribute("class") || "",
                                    m = t.style.cssText;
                                if (a = o._classNamePT = new _t(t, r, 0, 0, a, 2), a.setRatio = qt, a.pr = -11, i = !0, a.b = d, c = nt(t, n), u = t._gsClassPT) {
                                    for (p = {}, f = u.data; f;) p[f.p] = 1, f = f._next;
                                    u.setRatio(1)
                                }
                                return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : d.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), h = ot(t, c, nt(t), l, p), t.setAttribute("class", d), a.data = h.firstMPT, t.style.cssText = m, a = a.xfirst = o.parse(t, h.difs, a, s)
                            }
                        });
                        var Zt = function (t) {
                            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var e, i, r, n, o, a = this.t.style,
                                    s = c.transform.parse;
                                if ("all" === this.e) a.cssText = "", n = !0;
                                else
                                    for (e = this.e.split(" ").join("").split(","), r = e.length; --r > -1;) i = e[r], c[i] && (c[i].parse === s ? n = !0 : i = "transformOrigin" === i ? Rt : c[i].p), Jt(a, i);
                                n && (Jt(a, Lt), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                            }
                        };
                        for (St("clearProps", {
                                parser: function (t, e, r, n, o) {
                                    return o = new _t(t, r, 0, 0, o, 2), o.setRatio = Zt, o.e = e, o.pr = -10, o.data = n._tween, i = !0, o
                                }
                            }), u = "bezier,throwProps,physicsProps,physics2D".split(","), Mt = u.length; Mt--;) Et(u[Mt]);
                        u = a.prototype, u._firstPT = u._lastParsedTransform = u._transform = null, u._onInitTween = function (t, e, s, l) {
                            if (!t.nodeType) return !1;
                            this._target = y = t, this._tween = s, this._vars = e, A = l, p = e.autoRound, i = !1, r = e.suffixMap || a.suffixMap, n = tt(t, ""), o = this._overwriteProps;
                            var h, u, m, v, x, _, w, b, M, T = t.style;
                            if (f && "" === T.zIndex && ("auto" === (h = et(t, "zIndex", n)) || "" === h) && this._addLazySet(T, "zIndex", 0), "string" == typeof e && (v = T.cssText, h = nt(t, n), T.cssText = v + ";" + e, h = ot(t, h, nt(t)).difs, !Q && S.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, T.cssText = v), e.className ? this._firstPT = u = c.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = u = this.parse(t, e, null), this._transformType) {
                                for (M = 3 === this._transformType, Lt ? d && (f = !0, "" === T.zIndex && ("auto" === (w = et(t, "zIndex", n)) || "" === w) && this._addLazySet(T, "zIndex", 0), g && this._addLazySet(T, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (M ? "visible" : "hidden"))) : T.zoom = 1, m = u; m && m._next;) m = m._next;
                                b = new _t(t, "transform", 0, 0, null, 2), this._linkCSSP(b, null, m), b.setRatio = Lt ? Xt : Yt, b.data = this._transform || Wt(t, n, !0), b.tween = s, b.pr = -1, o.pop()
                            }
                            if (i) {
                                for (; u;) {
                                    for (_ = u._next, m = v; m && m.pr > u.pr;) m = m._next;
                                    (u._prev = m ? m._prev : x) ? u._prev._next = u: v = u, (u._next = m) ? m._prev = u : x = u, u = _
                                }
                                this._firstPT = v
                            }
                            return !0
                        }, u.parse = function (t, e, i, o) {
                            var a, s, l, h, u, f, d, m, g, v, x = t.style;
                            for (a in e) {
                                if (f = e[a], "function" == typeof f && (f = f(A, y)), s = c[a]) i = s.parse(t, f, a, this, i, o, e);
                                else {
                                    if ("--" === a.substr(0, 2)) {
                                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", tt(t).getPropertyValue(a) + "", f + "", a, !1, a);
                                        continue
                                    }
                                    u = et(t, a, n) + "", g = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || g && C.test(f) ? (g || (f = mt(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = bt(x, a, u, f, !0, "transparent", i, 0, o)) : g && k.test(f) ? i = bt(x, a, u, f, !0, null, i, 0, o) : (l = parseFloat(u), d = l || 0 === l ? u.substr((l + "").length) : "", ("" === u || "auto" === u) && ("width" === a || "height" === a ? (l = lt(t, a, n), d = "px") : "left" === a || "top" === a ? (l = rt(t, a, n), d = "px") : (l = "opacity" !== a ? 0 : 1, d = "")), v = g && "=" === f.charAt(1), v ? (h = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), h *= parseFloat(f), m = f.replace(M, "")) : (h = parseFloat(f), m = g ? f.replace(M, "") : ""), "" === m && (m = a in r ? r[a] : d), f = h || 0 === h ? (v ? h + l : h) + m : e[a], d !== m && ("" !== m || "lineHeight" === a) && (h || 0 === h) && l && (l = it(t, a, l, d), "%" === m ? (l /= it(t, a, 100, "%") / 100, !0 !== e.strictUnits && (u = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= it(t, a, 1, m) : "px" !== m && (h = it(t, a, h, m), m = "px"), v && (h || 0 === h) && (f = h + l + m)), v && (h += l), !l && 0 !== l || !h && 0 !== h ? void 0 !== x[a] && (f || f + "" != "NaN" && null != f) ? (i = new _t(x, a, h || l || 0, 0, i, -1, a, !1, 0, u, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : u) : q("invalid " + a + " tween value: " + e[a]) : (i = new _t(x, a, l, h - l, i, 0, a, !1 !== p && ("px" === m || "zIndex" === a), 0, u, f), i.xs0 = m))
                                }
                                o && i && !i.plugin && (i.plugin = o)
                            }
                            return i
                        }, u.setRatio = function (t) {
                            var e, i, r, n = this._firstPT;
                            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                    for (; n;) {
                                        if (e = n.c * t + n.s, n.r ? e = n.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), n.type)
                                            if (1 === n.type)
                                                if (2 === (r = n.l)) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2;
                                                else if (3 === r) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3;
                                        else if (4 === r) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4;
                                        else if (5 === r) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4 + n.xn4 + n.xs5;
                                        else {
                                            for (i = n.xs0 + e + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                            n.t[n.p] = i
                                        } else -1 === n.type ? n.t[n.p] = n.xs0 : n.setRatio && n.setRatio(t);
                                        else n.t[n.p] = e + n.xs0;
                                        n = n._next
                                    } else
                                        for (; n;) 2 !== n.type ? n.t[n.p] = n.b : n.setRatio(t), n = n._next;
                                else
                                    for (; n;) {
                                        if (2 !== n.type)
                                            if (n.r && -1 !== n.type)
                                                if (e = n.r(n.s + n.c), n.type) {
                                                    if (1 === n.type) {
                                                        for (r = n.l, i = n.xs0 + e + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                                        n.t[n.p] = i
                                                    }
                                                } else n.t[n.p] = e + n.xs0;
                                        else n.t[n.p] = n.e;
                                        else n.setRatio(t);
                                        n = n._next
                                    }
                        }, u._enableTransforms = function (t) {
                            this._transform = this._transform || Wt(this._target, n, !0), this._transformType = this._transform.svg && Ct || !t && 3 !== this._transformType ? 2 : 3
                        };
                        var Kt = function (t) {
                            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                        };
                        u._addLazySet = function (t, e, i) {
                            var r = this._firstPT = new _t(t, e, 0, 0, this._firstPT, 2);
                            r.e = i, r.setRatio = Kt, r.data = this
                        }, u._linkCSSP = function (t, e, i, r) {
                            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, r = !0), i ? i._next = t : r || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                        }, u._mod = function (t) {
                            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
                        }, u._kill = function (e) {
                            var i, r, n, o = e;
                            if (e.autoAlpha || e.alpha) {
                                o = {};
                                for (r in e) o[r] = e[r];
                                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                            }
                            for (e.className && (i = this._classNamePT) && (n = i.xfirst, n && n._prev ? this._linkCSSP(n._prev, i._next, n._prev._prev) : n === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, n._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== r && i.plugin._kill && (i.plugin._kill(e), r = i.plugin), i = i._next;
                            return t.prototype._kill.call(this, o)
                        };
                        var $t = function t(e, i, r) {
                            var n, o, a, s;
                            if (e.slice)
                                for (o = e.length; --o > -1;) t(e[o], i, r);
                            else
                                for (n = e.childNodes, o = n.length; --o > -1;) a = n[o], s = a.type, a.style && (i.push(nt(a)), r && r.push(a)), 1 !== s && 9 !== s && 11 !== s || !a.childNodes.length || t(a, i, r)
                        };
                        return a.cascadeTo = function (t, i, r) {
                            var n, o, a, s, l = e.to(t, i, r),
                                h = [l],
                                c = [],
                                u = [],
                                p = [],
                                f = e._internals.reservedProps;
                            for (t = l._targets || l.target, $t(t, c, p), l.render(i, !0, !0), $t(t, u), l.render(0, !0, !0), l._enabled(!0), n = p.length; --n > -1;)
                                if (o = ot(p[n], c[n], u[n]), o.firstMPT) {
                                    o = o.difs;
                                    for (a in r) f[a] && (o[a] = r[a]);
                                    s = {};
                                    for (a in o) s[a] = c[n][a];
                                    h.push(e.fromTo(p[n], i, s, o))
                                } return h
                        }, t.activate([a]), a
                    }, !0),
                    function () {
                        var t = l._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.7.0",
                                priority: -1,
                                API: 2,
                                init: function (t, e, i) {
                                    return this._tween = i, !0
                                }
                            }),
                            e = function (t) {
                                var e = 1 > t ? Math.pow(10, (t + "").length - 2) : 1;
                                return function (i) {
                                    return (Math.round(i / t) * t * e | 0) / e
                                }
                            },
                            i = function (t, e) {
                                for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
                            },
                            r = t.prototype;
                        r._onInitAllProps = function () {
                            var t, r, n, o, a = this._tween,
                                l = a.vars.roundProps,
                                h = {},
                                c = a._propLookup.roundProps;
                            if ("object" != (void 0 === l ? "undefined" : (0, s.default)(l)) || l.push)
                                for ("string" == typeof l && (l = l.split(",")), n = l.length; --n > -1;) h[l[n]] = Math.round;
                            else
                                for (o in l) h[o] = e(l[o]);
                            for (o in h)
                                for (t = a._firstPT; t;) r = t._next, t.pg ? t.t._mod(h) : t.n === o && (2 === t.f && t.t ? i(t.t._firstPT, h[o]) : (this._add(t.t, o, t.s, t.c, h[o]), r && (r._prev = t._prev), t._prev ? t._prev._next = r : a._firstPT === t && (a._firstPT = r), t._next = t._prev = null, a._propLookup[o] = c)), t = r;
                            return !1
                        }, r._add = function (t, e, i, r, n) {
                            this._addTween(t, e, i, i + r, e, n || Math.round), this._overwriteProps.push(e)
                        }
                    }(),
                    function () {
                        l._gsDefine.plugin({
                            propName: "attr",
                            API: 2,
                            version: "0.6.1",
                            init: function (t, e, i, r) {
                                var n, o;
                                if ("function" != typeof t.setAttribute) return !1;
                                for (n in e) o = e[n], "function" == typeof o && (o = o(r, t)), this._addTween(t, "setAttribute", t.getAttribute(n) + "", o + "", n, !1, n), this._overwriteProps.push(n);
                                return !0
                            }
                        })
                    }(), l._gsDefine.plugin({
                        propName: "directionalRotation",
                        version: "0.3.1",
                        API: 2,
                        init: function (t, e, i, r) {
                            "object" != (void 0 === e ? "undefined" : (0, s.default)(e)) && (e = {
                                rotation: e
                            }), this.finals = {};
                            var n, o, a, l, h, c, u = !0 === e.useRadians ? 2 * Math.PI : 360;
                            for (n in e) "useRadians" !== n && (l = e[n], "function" == typeof l && (l = l(r, t)), c = (l + "").split("_"), o = c[0], a = parseFloat("function" != typeof t[n] ? t[n] : t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), l = this.finals[n] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0, h = l - a, c.length && (o = c.join("_"), -1 !== o.indexOf("short") && (h %= u) !== h % (u / 2) && (h = 0 > h ? h + u : h - u), -1 !== o.indexOf("_cw") && 0 > h ? h = (h + 9999999999 * u) % u - (h / u | 0) * u : -1 !== o.indexOf("ccw") && h > 0 && (h = (h - 9999999999 * u) % u - (h / u | 0) * u)), (h > 1e-6 || -1e-6 > h) && (this._addTween(t, n, a, a + h, n), this._overwriteProps.push(n)));
                            return !0
                        },
                        set: function (t) {
                            var e;
                            if (1 !== t) this._super.setRatio.call(this, t);
                            else
                                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                        }
                    })._autoCSS = !0, l._gsDefine("easing.Back", ["easing.Ease"], function (t) {
                        var e, i, r, n, o = l.GreenSockGlobals || l,
                            a = o.com.greensock,
                            s = 2 * Math.PI,
                            h = Math.PI / 2,
                            c = a._class,
                            u = function (e, i) {
                                var r = c("easing." + e, function () {}, !0),
                                    n = r.prototype = new t;
                                return n.constructor = r, n.getRatio = i, r
                            },
                            p = t.register || function () {},
                            f = function (t, e, i, r, n) {
                                var o = c("easing." + t, {
                                    easeOut: new e,
                                    easeIn: new i,
                                    easeInOut: new r
                                }, !0);
                                return p(o, t), o
                            },
                            d = function (t, e, i) {
                                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                            },
                            m = function (e, i) {
                                var r = c("easing." + e, function (t) {
                                        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                    }, !0),
                                    n = r.prototype = new t;
                                return n.constructor = r, n.getRatio = i, n.config = function (t) {
                                    return new r(t)
                                }, r
                            },
                            g = f("Back", m("BackOut", function (t) {
                                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                            }), m("BackIn", function (t) {
                                return t * t * ((this._p1 + 1) * t - this._p1)
                            }), m("BackInOut", function (t) {
                                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                            })),
                            v = c("easing.SlowMo", function (t, e, i) {
                                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                            }, !0),
                            y = v.prototype = new t;
                        return y.constructor = v, y.getRatio = function (t) {
                            var e = t + (.5 - t) * this._p;
                            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                        }, v.ease = new v(.7, .7), y.config = v.config = function (t, e, i) {
                            return new v(t, e, i)
                        }, e = c("easing.SteppedEase", function (t, e) {
                            t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                        }, !0), y = e.prototype = new t, y.constructor = e, y.getRatio = function (t) {
                            return 0 > t ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                        }, y.config = e.config = function (t, i) {
                            return new e(t, i)
                        }, i = c("easing.ExpoScaleEase", function (t, e, i) {
                            this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
                        }, !0), y = i.prototype = new t, y.constructor = i, y.getRatio = function (t) {
                            return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
                        }, y.config = i.config = function (t, e, r) {
                            return new i(t, e, r)
                        }, r = c("easing.RoughEase", function (e) {
                            e = e || {};
                            for (var i, r, n, o, a, s, l = e.taper || "none", h = [], c = 0, u = 0 | (e.points || 20), p = u, f = !1 !== e.randomize, m = !0 === e.clamp, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1;) i = f ? Math.random() : 1 / u * p, r = g ? g.getRatio(i) : i, "none" === l ? n = v : "out" === l ? (o = 1 - i, n = o * o * v) : "in" === l ? n = i * i * v : .5 > i ? (o = 2 * i, n = o * o * .5 * v) : (o = 2 * (1 - i), n = o * o * .5 * v), f ? r += Math.random() * n - .5 * n : p % 2 ? r += .5 * n : r -= .5 * n, m && (r > 1 ? r = 1 : 0 > r && (r = 0)), h[c++] = {
                                x: i,
                                y: r
                            };
                            for (h.sort(function (t, e) {
                                    return t.x - e.x
                                }), s = new d(1, 1, null), p = u; --p > -1;) a = h[p], s = new d(a.x, a.y, s);
                            this._prev = new d(0, 0, 0 !== s.t ? s : s.next)
                        }, !0), y = r.prototype = new t, y.constructor = r, y.getRatio = function (t) {
                            var e = this._prev;
                            if (t > e.t) {
                                for (; e.next && t >= e.t;) e = e.next;
                                e = e.prev
                            } else
                                for (; e.prev && t <= e.t;) e = e.prev;
                            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                        }, y.config = function (t) {
                            return new r(t)
                        }, r.ease = new r, f("Bounce", u("BounceOut", function (t) {
                            return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }), u("BounceIn", function (t) {
                            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                        }), u("BounceInOut", function (t) {
                            var e = .5 > t;
                            return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                        })), f("Circ", u("CircOut", function (t) {
                            return Math.sqrt(1 - (t -= 1) * t)
                        }), u("CircIn", function (t) {
                            return -(Math.sqrt(1 - t * t) - 1)
                        }), u("CircInOut", function (t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        })), n = function (e, i, r) {
                            var n = c("easing." + e, function (t, e) {
                                    this._p1 = t >= 1 ? t : 1, this._p2 = (e || r) / (1 > t ? t : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                                }, !0),
                                o = n.prototype = new t;
                            return o.constructor = n, o.getRatio = i, o.config = function (t, e) {
                                return new n(t, e)
                            }, n
                        }, f("Elastic", n("ElasticOut", function (t) {
                            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                        }, .3), n("ElasticIn", function (t) {
                            return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                        }, .3), n("ElasticInOut", function (t) {
                            return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                        }, .45)), f("Expo", u("ExpoOut", function (t) {
                            return 1 - Math.pow(2, -10 * t)
                        }), u("ExpoIn", function (t) {
                            return Math.pow(2, 10 * (t - 1)) - .001
                        }), u("ExpoInOut", function (t) {
                            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        })), f("Sine", u("SineOut", function (t) {
                            return Math.sin(t * h)
                        }), u("SineIn", function (t) {
                            return 1 - Math.cos(t * h)
                        }), u("SineInOut", function (t) {
                            return -.5 * (Math.cos(Math.PI * t) - 1)
                        })), c("easing.EaseLookup", {
                            find: function (e) {
                                return t.map[e]
                            }
                        }, !0), p(o.SlowMo, "SlowMo", "ease,"), p(r, "RoughEase", "ease,"), p(e, "SteppedEase", "ease,"), g
                    }, !0)
            }), l._gsDefine && l._gsQueue.pop()(),
            function (r, a) {
                var l = {},
                    h = r.document,
                    c = r.GreenSockGlobals = r.GreenSockGlobals || r,
                    u = c[a];
                if (u) return void 0 !== t && t.exports && (t.exports = u), u;
                var p, f, d, m, g, v = function (t) {
                        var e, i = t.split("."),
                            r = c;
                        for (e = 0; e < i.length; e++) r[i[e]] = r = r[i[e]] || {};
                        return r
                    },
                    y = v("com.greensock"),
                    A = 1e-10,
                    x = function (t) {
                        var e, i = [],
                            r = t.length;
                        for (e = 0; e !== r; i.push(t[e++]));
                        return i
                    },
                    _ = function () {},
                    w = function () {
                        var t = Object.prototype.toString,
                            e = t.call([]);
                        return function (i) {
                            return null != i && (i instanceof Array || "object" == (void 0 === i ? "undefined" : (0, s.default)(i)) && !!i.push && t.call(i) === e)
                        }
                    }(),
                    b = {},
                    M = function r(s, h, u, p) {
                        this.sc = b[s] ? b[s].sc : [], b[s] = this, this.gsClass = null, this.func = u;
                        var f = [];
                        this.check = function (d) {
                            for (var m, g, y, A, x = h.length, _ = x; --x > -1;)(m = b[h[x]] || new r(h[x], [])).gsClass ? (f[x] = m.gsClass, _--) : d && m.sc.push(this);
                            if (0 === _ && u) {
                                if (g = ("com.greensock." + s).split("."), y = g.pop(), A = v(g.join("."))[y] = this.gsClass = u.apply(u, f), p)
                                    if (c[y] = l[y] = A, void 0 !== t && t.exports)
                                        if (s === a) {
                                            t.exports = l[a] = A;
                                            for (x in l) A[x] = l[x]
                                        } else l[a] && (l[a][y] = A);
                                else i(202) && (n = [], void 0 !== (o = function () {
                                    return A
                                }.apply(e, n)) && (t.exports = o));
                                for (x = 0; x < this.sc.length; x++) this.sc[x].check()
                            }
                        }, this.check(!0)
                    },
                    T = r._gsDefine = function (t, e, i, r) {
                        return new M(t, e, i, r)
                    },
                    S = y._class = function (t, e, i) {
                        return e = e || function () {}, T(t, [], function () {
                            return e
                        }, i), e
                    };
                T.globals = c;
                var E = [0, 0, 1, 1],
                    C = S("easing.Ease", function (t, e, i, r) {
                        this._func = t, this._type = i || 0, this._power = r || 0, this._params = e ? E.concat(e) : E
                    }, !0),
                    P = C.map = {},
                    L = C.register = function (t, e, i, r) {
                        for (var n, o, a, s, l = e.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1;)
                            for (o = l[h], n = r ? S("easing." + o, null, !0) : y.easing[o] || {}, a = c.length; --a > -1;) s = c[a], P[o + "." + s] = P[s + o] = n[s] = t.getRatio ? t : t[s] || new t
                    };
                for (d = C.prototype, d._calcEnd = !1, d.getRatio = function (t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            r = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
                        return 1 === i ? r *= r : 2 === i ? r *= r * r : 3 === i ? r *= r * r * r : 4 === i && (r *= r * r * r * r), 1 === e ? 1 - r : 2 === e ? r : .5 > t ? r / 2 : 1 - r / 2
                    }, p = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], f = p.length; --f > -1;) d = p[f] + ",Power" + f, L(new C(null, null, 1, f), d, "easeOut", !0), L(new C(null, null, 2, f), d, "easeIn" + (0 === f ? ",easeNone" : "")), L(new C(null, null, 3, f), d, "easeInOut");
                P.linear = y.easing.Linear.easeIn, P.swing = y.easing.Quad.easeInOut;
                var D = S("events.EventDispatcher", function (t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                d = D.prototype, d.addEventListener = function (t, e, i, r, n) {
                    n = n || 0;
                    var o, a, s = this._listeners[t],
                        l = 0;
                    for (this !== m || g || m.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;) o = s[a], o.c === e && o.s === i ? s.splice(a, 1) : 0 === l && o.pr < n && (l = a + 1);
                    s.splice(l, 0, {
                        c: e,
                        s: i,
                        up: r,
                        pr: n
                    })
                }, d.removeEventListener = function (t, e) {
                    var i, r = this._listeners[t];
                    if (r)
                        for (i = r.length; --i > -1;)
                            if (r[i].c === e) return void r.splice(i, 1)
                }, d.dispatchEvent = function (t) {
                    var e, i, r, n = this._listeners[t];
                    if (n)
                        for (e = n.length, e > 1 && (n = n.slice(0)), i = this._eventTarget; --e > -1;)(r = n[e]) && (r.up ? r.c.call(r.s || i, {
                            type: t,
                            target: i
                        }) : r.c.call(r.s || i))
                };
                var R = r.requestAnimationFrame,
                    I = r.cancelAnimationFrame,
                    O = Date.now || function () {
                        return (new Date).getTime()
                    },
                    B = O();
                for (p = ["ms", "moz", "webkit", "o"], f = p.length; --f > -1 && !R;) R = r[p[f] + "RequestAnimationFrame"], I = r[p[f] + "CancelAnimationFrame"] || r[p[f] + "CancelRequestAnimationFrame"];
                S("Ticker", function (t, e) {
                    var i, r, n, o, a, s = this,
                        l = O(),
                        c = !(!1 === e || !R) && "auto",
                        u = 500,
                        p = 33,
                        f = function t(e) {
                            var h, c, f = O() - B;
                            f > u && (l += f - p), B += f, s.time = (B - l) / 1e3, h = s.time - a, (!i || h > 0 || !0 === e) && (s.frame++, a += h + (h >= o ? .004 : o - h), c = !0), !0 !== e && (n = r(t)), c && s.dispatchEvent("tick")
                        };
                    D.call(s), s.time = s.frame = 0, s.tick = function () {
                        f(!0)
                    }, s.lagSmoothing = function (t, e) {
                        return arguments.length ? (u = t || 1 / A, void(p = Math.min(e, u, 0))) : 1 / A > u
                    }, s.sleep = function () {
                        null != n && (c && I ? I(n) : clearTimeout(n), r = _, n = null, s === m && (g = !1))
                    }, s.wake = function (t) {
                        null !== n ? s.sleep() : t ? l += -B + (B = O()) : s.frame > 10 && (B = O() - u + 5), r = 0 === i ? _ : c && R ? R : function (t) {
                            return setTimeout(t, 1e3 * (a - s.time) + 1 | 0)
                        }, s === m && (g = !0), f(2)
                    }, s.fps = function (t) {
                        return arguments.length ? (i = t, o = 1 / (i || 60), a = this.time + o, void s.wake()) : i
                    }, s.useRAF = function (t) {
                        return arguments.length ? (s.sleep(), c = t, void s.fps(i)) : c
                    }, s.fps(t), setTimeout(function () {
                        "auto" === c && s.frame < 5 && "hidden" !== (h || {}).visibilityState && s.useRAF(!1)
                    }, 1500)
                }), d = y.Ticker.prototype = new y.events.EventDispatcher, d.constructor = y.Ticker;
                var N = S("core.Animation", function (t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, et) {
                        g || m.wake();
                        var i = this.vars.useFrames ? tt : et;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                m = N.ticker = new y.Ticker, d = N.prototype, d._dirty = d._gc = d._initted = d._paused = !1, d._totalTime = d._time = 0, d._rawPrevTime = -1, d._next = d._last = d._onUpdate = d._timeline = d.timeline = null, d._paused = !1;
                (function t() {
                    g && O() - B > 2e3 && ("hidden" !== (h || {}).visibilityState || !m.lagSmoothing()) && m.wake();
                    var e = setTimeout(t, 2e3);
                    e.unref && e.unref()
                })(), d.play = function (t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, d.pause = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, d.resume = function (t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, d.seek = function (t, e) {
                    return this.totalTime(Number(t), !1 !== e)
                }, d.restart = function (t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                }, d.reverse = function (t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, d.render = function (t, e, i) {}, d.invalidate = function () {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
                }, d.isActive = function () {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, d._enabled = function (t, e) {
                    return g || m.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, d._kill = function (t, e) {
                    return this._enabled(!1, !1)
                }, d.kill = function (t, e) {
                    return this._kill(t, e), this
                }, d._uncache = function (t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, d._swapSelfInParams = function (t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, d._callback = function (t) {
                    var e = this.vars,
                        i = e[t],
                        r = e[t + "Params"],
                        n = e[t + "Scope"] || e.callbackScope || this;
                    switch (r ? r.length : 0) {
                        case 0:
                            i.call(n);
                            break;
                        case 1:
                            i.call(n, r[0]);
                            break;
                        case 2:
                            i.call(n, r[0], r[1]);
                            break;
                        default:
                            i.apply(n, r)
                    }
                }, d.eventCallback = function (t, e, i, r) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var n = this.vars;
                        if (1 === arguments.length) return n[t];
                        null == e ? delete n[t] : (n[t] = e, n[t + "Params"] = w(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, n[t + "Scope"] = r), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, d.delay = function (t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, d.duration = function (t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, d.totalDuration = function (t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, d.time = function (t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, d.totalTime = function (t, e, i) {
                    if (g || m.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var r = this._totalDuration,
                                n = this._timeline;
                            if (t > r && !i && (t = r), this._startTime = (this._paused ? this._pauseTime : n._time) - (this._reversed ? r - t : t) / this._timeScale, n._dirty || this._uncache(!1), n._timeline)
                                for (; n._timeline;) n._timeline._time !== (n._startTime + n._totalTime) / n._timeScale && n.totalTime(n._totalTime, !0), n = n._timeline
                        }
                        this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (G.length && rt(), this.render(t, e, !1), G.length && rt())
                    }
                    return this
                }, d.progress = d.totalProgress = function (t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, d.startTime = function (t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, d.endTime = function (t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, d.timeScale = function (t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || A, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, d.reversed = function (t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, d.paused = function (t) {
                    if (!arguments.length) return this._paused;
                    var e, i, r = this._timeline;
                    return t != this._paused && r && (g || t || m.wake(), e = r.rawTime(), i = e - this._pauseTime, !t && r.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = r.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var k = S("core.SimpleTimeline", function (t) {
                    N.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                d = k.prototype = new N, d.constructor = k, d.kill()._gc = !1, d._first = d._last = d._recent = null, d._sortChildren = !1, d.add = d.insert = function (t, e, i, r) {
                    var n, o;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), n = this._last, this._sortChildren)
                        for (o = t._startTime; n && n._startTime > o;) n = n._prev;
                    return n ? (t._next = n._next, n._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = n, this._recent = t, this._timeline && this._uncache(!0), this
                }, d._remove = function (t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, d.render = function (t, e, i) {
                    var r, n = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; n;) r = n._next, (n._active || t >= n._startTime && !n._paused && !n._gc) && (n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = r
                }, d.rawTime = function () {
                    return g || m.wake(), this._totalTime
                };
                var F = S("TweenLite", function (t, e, i) {
                        if (N.call(this, e, i), this.render = F.prototype.render, null == t) throw "Cannot tween a null target.";
                        this.target = t = "string" != typeof t ? t : F.selector(t) || t;
                        var n, o, a, s = t.jquery || t.length && t !== r && t[0] && (t[0] === r || t[0].nodeType && t[0].style && !t.nodeType),
                            l = this.vars.overwrite;
                        if (this._overwrite = l = null == l ? $[F.defaultOverwrite] : "number" == typeof l ? l >> 0 : $[l], (s || t instanceof Array || t.push && w(t)) && "number" != typeof t[0])
                            for (this._targets = a = x(t), this._propLookup = [], this._siblings = [], n = 0; n < a.length; n++) o = a[n], o ? "string" != typeof o ? o.length && o !== r && o[0] && (o[0] === r || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(x(o))) : (this._siblings[n] = nt(o, this, !1), 1 === l && this._siblings[n].length > 1 && at(o, this, null, 1, this._siblings[n])) : "string" == typeof (o = a[n--] = F.selector(o)) && a.splice(n + 1, 1) : a.splice(n--, 1);
                        else this._propLookup = {}, this._siblings = nt(t, this, !1), 1 === l && this._siblings.length > 1 && at(t, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -A, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    z = function (t) {
                        return t && t.length && t !== r && t[0] && (t[0] === r || t[0].nodeType && t[0].style && !t.nodeType)
                    },
                    U = function (t, e) {
                        var i, r = {};
                        for (i in t) K[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!J[i] || J[i] && J[i]._autoCSS) || (r[i] = t[i], delete t[i]);
                        t.css = r
                    };
                d = F.prototype = new N, d.constructor = F, d.kill()._gc = !1, d.ratio = 0, d._firstPT = d._targets = d._overwrittenProps = d._startAt = null, d._notifyPluginsOfEnabled = d._lazy = !1, F.version = "2.0.1", F.defaultEase = d._ease = new C(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = m, F.autoSleep = 120, F.lagSmoothing = function (t, e) {
                    m.lagSmoothing(t, e)
                }, F.selector = r.$ || r.jQuery || function (t) {
                    var e = r.$ || r.jQuery;
                    return e ? (F.selector = e, e(t)) : (h || (h = r.document), h ? h.querySelectorAll ? h.querySelectorAll(t) : h.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                };
                var G = [],
                    V = {},
                    H = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    j = /[\+-]=-?[\.\d]/,
                    W = function (t) {
                        for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : 1e-6 > e && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    Y = function (t, e, i, r) {
                        var n, o, a, s, l, h, c, u = [],
                            p = 0,
                            f = "",
                            d = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, n = t.match(H) || [], o = e.match(H) || [], r && (r._next = null, r.blob = 1, u._firstPT = u._applyPT = r), l = o.length, s = 0; l > s; s++) c = o[s], h = e.substr(p, e.indexOf(c, p) - p), f += h || !s ? h : ",", p += h.length, d ? d = (d + 1) % 5 : "rgba(" === h.substr(-5) && (d = 1), c === n[s] || n.length <= s ? f += c : (f && (u.push(f), f = ""), a = parseFloat(n[s]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - a) || 0,
                            f: 0,
                            m: d && 4 > d ? Math.round : 0
                        }), p += c.length;
                        return f += e.substr(p), f && u.push(f), u.setRatio = W, j.test(e) && (u.end = null), u
                    },
                    X = function (t, e, i, r, n, o, a, l, h) {
                        "function" == typeof r && (r = r(h || 0, t));
                        var c, u = (0, s.default)(t[e]),
                            p = "function" !== u ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            f = "get" !== i ? i : p ? a ? t[p](a) : t[p]() : t[e],
                            d = "string" == typeof r && "=" === r.charAt(1),
                            m = {
                                t: t,
                                p: e,
                                s: f,
                                f: "function" === u,
                                pg: 0,
                                n: n || e,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: d ? parseInt(r.charAt(0) + "1", 10) * parseFloat(r.substr(2)) : parseFloat(r) - f || 0
                            };
                        return ("number" != typeof f || "number" != typeof r && !d) && (a || isNaN(f) || !d && isNaN(r) || "boolean" == typeof f || "boolean" == typeof r ? (m.fp = a, c = Y(f, d ? parseFloat(m.s) + m.c + (m.s + "").replace(/[0-9\-\.]/g, "") : r, l || F.defaultStringFilter, m), m = {
                            t: c,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: n || e,
                            pr: 0,
                            m: 0
                        }) : (m.s = parseFloat(f), d || (m.c = parseFloat(r) - m.s || 0))), m.c ? ((m._next = this._firstPT) && (m._next._prev = m), this._firstPT = m, m) : void 0
                    },
                    Q = F._internals = {
                        isArray: w,
                        isSelector: z,
                        lazyTweens: G,
                        blobDif: Y
                    },
                    J = F._plugins = {},
                    q = Q.tweenLookup = {},
                    Z = 0,
                    K = Q.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    $ = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    tt = N._rootFramesTimeline = new k,
                    et = N._rootTimeline = new k,
                    it = 30,
                    rt = Q.lazyRender = function () {
                        var t, e = G.length;
                        for (V = {}; --e > -1;)(t = G[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        G.length = 0
                    };
                et._startTime = m.time, tt._startTime = m.frame, et._active = tt._active = !0, setTimeout(rt, 1), N._updateRoot = F.render = function () {
                    var t, e, i;
                    if (G.length && rt(), et.render((m.time - et._startTime) * et._timeScale, !1, !1), tt.render((m.frame - tt._startTime) * tt._timeScale, !1, !1), G.length && rt(), m.frame >= it) {
                        it = m.frame + (parseInt(F.autoSleep, 10) || 120);
                        for (i in q) {
                            for (e = q[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete q[i]
                        }
                        if ((!(i = et._first) || i._paused) && F.autoSleep && !tt._first && 1 === m._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || m.sleep()
                        }
                    }
                }, m.addEventListener("tick", N._updateRoot);
                var nt = function (t, e, i) {
                        var r, n, o = t._gsTweenID;
                        if (q[o || (t._gsTweenID = o = "t" + Z++)] || (q[o] = {
                                target: t,
                                tweens: []
                            }), e && (r = q[o].tweens, r[n = r.length] = e, i))
                            for (; --n > -1;) r[n] === e && r.splice(n, 1);
                        return q[o].tweens
                    },
                    ot = function (t, e, i, r) {
                        var n, o, a = t.vars.onOverwrite;
                        return a && (n = a(t, e, i, r)), a = F.onOverwrite, a && (o = a(t, e, i, r)), !1 !== n && !1 !== o
                    },
                    at = function (t, e, i, r, n) {
                        var o, a, s, l;
                        if (1 === r || r >= 4) {
                            for (l = n.length, o = 0; l > o; o++)
                                if ((s = n[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                else if (5 === r) break;
                            return a
                        }
                        var h, c = e._startTime + A,
                            u = [],
                            p = 0,
                            f = 0 === e._duration;
                        for (o = n.length; --o > -1;)(s = n[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (h = h || st(e, 0, f), 0 === st(s, h, f) && (u[p++] = s)) : s._startTime <= c && s._startTime + s.totalDuration() / s._timeScale > c && ((f || !s._initted) && c - s._startTime <= 2e-10 || (u[p++] = s)));
                        for (o = p; --o > -1;)
                            if (s = u[o], 2 === r && s._kill(i, t, e) && (a = !0), 2 !== r || !s._firstPT && s._initted) {
                                if (2 !== r && !ot(s, e)) continue;
                                s._enabled(!1, !1) && (a = !0)
                            } return a
                    },
                    st = function (t, e, i) {
                        for (var r = t._timeline, n = r._timeScale, o = t._startTime; r._timeline;) {
                            if (o += r._startTime, n *= r._timeScale, r._paused) return -100;
                            r = r._timeline
                        }
                        return o /= n, o > e ? o - e : i && o === e || !t._initted && 2 * A > o - e ? A : (o += t.totalDuration() / t._timeScale / n) > e + A ? 0 : o - e - A
                    };
                d._init = function () {
                    var t, e, i, r, n, o, a = this.vars,
                        s = this._overwrittenProps,
                        l = this._duration,
                        h = !!a.immediateRender,
                        c = a.ease;
                    if (a.startAt) {
                        this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), n = {};
                        for (r in a.startAt) n[r] = a.startAt[r];
                        if (n.data = "isStart", n.overwrite = !1, n.immediateRender = !0, n.lazy = h && !1 !== a.lazy, n.startAt = n.delay = null, n.onUpdate = a.onUpdate, n.onUpdateParams = a.onUpdateParams, n.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = F.to(this.target || {}, 0, n), h)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== l) return
                    } else if (a.runBackwards && 0 !== l)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            0 !== this._time && (h = !1), i = {};
                            for (r in a) K[r] && "autoCSS" !== r || (i[r] = a[r]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && !1 !== a.lazy, i.immediateRender = h, this._startAt = F.to(this.target, 0, i), h) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        } if (this._ease = c = c ? c instanceof C ? c : "function" == typeof c ? new C(c, a.easeParams) : P[c] || F.defaultEase : F.defaultEase, a.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (o = this._targets.length, t = 0; o > t; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (e && F._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, d._initProps = function (t, e, i, n, o) {
                    var a, s, l, h, c, u;
                    if (null == t) return !1;
                    V[t._gsTweenID] && rt(), this.vars.css || t.style && t !== r && t.nodeType && J.css && !1 !== this.vars.autoCSS && U(this.vars, t);
                    for (a in this.vars)
                        if (u = this.vars[a], K[a]) u && (u instanceof Array || u.push && w(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (J[a] && (h = new J[a])._onInitTween(t, this.vars[a], this, o)) {
                        for (this._firstPT = c = {
                                _next: this._firstPT,
                                t: h,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: h._priority,
                                m: 0
                            }, s = h._overwriteProps.length; --s > -1;) e[h._overwriteProps[s]] = this._firstPT;
                        (h._priority || h._onInitAllProps) && (l = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                    } else e[a] = X.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                    return n && this._kill(n, t) ? this._initProps(t, e, i, n, o) : this._overwrite > 1 && this._firstPT && i.length > 1 && at(t, this, e, this._overwrite, i) ? (this._kill(e, t), this._initProps(t, e, i, n, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (V[t._gsTweenID] = !0), l)
                }, d.render = function (t, e, i) {
                    var r, n, o, a, s = this._time,
                        l = this._duration,
                        h = this._rawPrevTime;
                    if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 > h || 0 >= t && t >= -1e-7 || h === A && "isPause" !== this.data) && h !== t && (i = !0, h > A && (n = "onReverseComplete")), this._rawPrevTime = a = !e || t || h === t ? t : A);
                    else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && h > 0) && (n = "onReverseComplete", r = this._reversed), 0 > t && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (h !== A || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || h === t ? t : A)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var c = t / l,
                            u = this._easeType,
                            p = this._easePower;
                        (1 === u || 3 === u && c >= .5) && (c = 1 - c), 3 === u && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), this.ratio = 1 === u ? 1 - c : 2 === u ? c : .5 > t / l ? c / 2 : 1 - c / 2
                    } else this.ratio = this._ease.getRatio(t / l);
                    if (this._time !== s || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = h, G.push(this), void(this._lazy = [t, e]);
                            this._time && !r ? this.ratio = this._ease.getRatio(this._time / l) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === l) && (e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (0 > t && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== s || r || i) && this._callback("onUpdate")), n && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[n] && this._callback(n), 0 === l && this._rawPrevTime === A && a !== A && (this._rawPrevTime = 0))
                    }
                }, d._kill = function (t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : F.selector(e) || e;
                    var r, n, o, a, l, h, c, u, p, f = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                    if ((w(e) || z(e)) && "number" != typeof e[0])
                        for (r = e.length; --r > -1;) this._kill(t, e[r], i) && (h = !0);
                    else {
                        if (this._targets) {
                            for (r = this._targets.length; --r > -1;)
                                if (e === this._targets[r]) {
                                    l = this._propLookup[r] || {}, this._overwrittenProps = this._overwrittenProps || [], n = this._overwrittenProps[r] = t ? this._overwrittenProps[r] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            l = this._propLookup, n = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (l) {
                            if (c = t || l, u = t !== n && "all" !== n && t !== l && ("object" != (void 0 === t ? "undefined" : (0, s.default)(t)) || !t._tempKill), i && (F.onOverwrite || this.vars.onOverwrite)) {
                                for (o in c) l[o] && (p || (p = []), p.push(o));
                                if ((p || !t) && !ot(this, i, e, p)) return !1
                            }
                            for (o in c)(a = l[o]) && (f && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, h = !0), a.pg && a.t._kill(c) && (h = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete l[o]), u && (n[o] = 1);
                            !this._firstPT && this._initted && this._enabled(!1, !1)
                        }
                    }
                    return h
                }, d.invalidate = function () {
                    return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], N.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -A, this.render(Math.min(0, -this._delay))), this
                }, d._enabled = function (t, e) {
                    if (g || m.wake(), t && this._gc) {
                        var i, r = this._targets;
                        if (r)
                            for (i = r.length; --i > -1;) this._siblings[i] = nt(r[i], this, !0);
                        else this._siblings = nt(this.target, this, !0)
                    }
                    return N.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && F._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, F.to = function (t, e, i) {
                    return new F(t, e, i)
                }, F.from = function (t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new F(t, e, i)
                }, F.fromTo = function (t, e, i, r) {
                    return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new F(t, e, r)
                }, F.delayedCall = function (t, e, i, r, n) {
                    return new F(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: r,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: n,
                        overwrite: 0
                    })
                }, F.set = function (t, e) {
                    return new F(t, 0, e)
                }, F.getTweensOf = function (t, e) {
                    if (null == t) return [];
                    t = "string" != typeof t ? t : F.selector(t) || t;
                    var i, r, n, o;
                    if ((w(t) || z(t)) && "number" != typeof t[0]) {
                        for (i = t.length, r = []; --i > -1;) r = r.concat(F.getTweensOf(t[i], e));
                        for (i = r.length; --i > -1;)
                            for (o = r[i], n = i; --n > -1;) o === r[n] && r.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (r = nt(t).concat(), i = r.length; --i > -1;)(r[i]._gc || e && !r[i].isActive()) && r.splice(i, 1);
                    return r || []
                }, F.killTweensOf = F.killDelayedCallsTo = function (t, e, i) {
                    "object" == (void 0 === e ? "undefined" : (0, s.default)(e)) && (i = e, e = !1);
                    for (var r = F.getTweensOf(t, e), n = r.length; --n > -1;) r[n]._kill(i, t)
                };
                var lt = S("plugins.TweenPlugin", function (t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = lt.prototype
                }, !0);
                if (d = lt.prototype, lt.version = "1.19.0", lt.API = 2, d._firstPT = null, d._addTween = X, d.setRatio = W, d._kill = function (t) {
                        var e, i = this._overwriteProps,
                            r = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; r;) null != t[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
                        return !1
                    }, d._mod = d._roundProps = function (t) {
                        for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, F._onPluginEvent = function (t, e) {
                        var i, r, n, o, a, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s;) {
                                for (a = s._next, r = n; r && r.pr > s.pr;) r = r._next;
                                (s._prev = r ? r._prev : o) ? s._prev._next = s: n = s, (s._next = r) ? r._prev = s : o = s, s = a
                            }
                            s = e._firstPT = n
                        }
                        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                        return i
                    }, lt.activate = function (t) {
                        for (var e = t.length; --e > -1;) t[e].API === lt.API && (J[(new t[e])._propName] = t[e]);
                        return !0
                    }, T.plugin = function (t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            r = t.priority || 0,
                            n = t.overwriteProps,
                            o = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = S("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
                                lt.call(this, i, r), this._overwriteProps = n || []
                            }, !0 === t.global),
                            s = a.prototype = new lt(i);
                        s.constructor = a, a.API = t.API;
                        for (e in o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                        return a.version = t.version, lt.activate([a]), a
                    }, p = r._gsQueue) {
                    for (f = 0; f < p.length; f++) p[f]();
                    for (d in b) b[d].func || r.console.warn("GSAP encountered missing dependency: " + d)
                }
                g = !1
            }(void 0 !== t && t.exports && void 0 !== r ? r : window, "TweenMax")
    }).call(e, i(93))
}, function (t, e) {
    (function (e) {
        t.exports = e
    }).call(e, {})
}, function (t, e, i) {
    "use strict";
    var r = i(41),
        n = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(r),
        o = i(4),
        a = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(o);
    a.DDSLoader = function (t) {
        this._parser = t.DDSLoader.parse
    }, a.DDSLoader.prototype = (0, n.default)(a.CompressedTextureLoader.prototype), a.DDSLoader.prototype.constructor = a.DDSLoader, a.DDSLoader.parse = function (t, e) {
        function i(t) {
            return t.charCodeAt(0) + (t.charCodeAt(1) << 8) + (t.charCodeAt(2) << 16) + (t.charCodeAt(3) << 24)
        }
        var r = {
                mipmaps: [],
                width: 0,
                height: 0,
                format: null,
                mipmapCount: 1
            },
            n = i("DXT1"),
            o = i("DXT3"),
            s = i("DXT5"),
            l = i("ETC1"),
            h = new Int32Array(t, 0, 31);
        if (542327876 !== h[0]) return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."), r;
        if (4 & !h[20]) return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."), r;
        var c, u = h[21],
            p = !1;
        switch (u) {
            case n:
                c = 8, r.format = a.RGB_S3TC_DXT1_Format;
                break;
            case o:
                c = 16, r.format = a.RGBA_S3TC_DXT3_Format;
                break;
            case s:
                c = 16, r.format = a.RGBA_S3TC_DXT5_Format;
                break;
            case l:
                c = 8, r.format = a.RGB_ETC1_Format;
                break;
            default:
                if (!(32 === h[22] && 16711680 & h[23] && 65280 & h[24] && 255 & h[25] && 4278190080 & h[26])) return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", function (t) {
                    return String.fromCharCode(255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255)
                }(u)), r;
                p = !0, c = 64, r.format = a.RGBAFormat
        }
        r.mipmapCount = 1, 131072 & h[2] && !1 !== e && (r.mipmapCount = Math.max(1, h[7]));
        var f = h[28];
        if (r.isCubemap = !!(512 & f), r.isCubemap && (!(1024 & f) || !(2048 & f) || !(4096 & f) || !(8192 & f) || !(16384 & f) || !(32768 & f))) return console.error("THREE.DDSLoader.parse: Incomplete cubemap faces"), r;
        r.width = h[4], r.height = h[3];
        for (var d = h[1] + 4, m = r.isCubemap ? 6 : 1, g = 0; g < m; g++)
            for (var v = r.width, y = r.height, A = 0; A < r.mipmapCount; A++) {
                if (p) var x = function (t, e, i, r) {
                        for (var n = i * r * 4, o = new Uint8Array(t, e, n), a = new Uint8Array(n), s = 0, l = 0, h = 0; h < r; h++)
                            for (var c = 0; c < i; c++) {
                                var u = o[l];
                                l++;
                                var p = o[l];
                                l++;
                                var f = o[l];
                                l++;
                                var d = o[l];
                                l++, a[s] = f, s++, a[s] = p, s++, a[s] = u, s++, a[s] = d, s++
                            }
                        return a
                    }(t, d, v, y),
                    _ = x.length;
                else var _ = Math.max(4, v) / 4 * Math.max(4, y) / 4 * c,
                    x = new Uint8Array(t, d, _);
                var w = {
                    data: x,
                    width: v,
                    height: y
                };
                r.mipmaps.push(w), d += _, v = Math.max(v >> 1, 1), y = Math.max(y >> 1, 1)
            }
        return r
    }
}, function (t, e, i) {
    "use strict";
    var r = i(4),
        n = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(r);
    n.MTLLoader = function (t, e) {
        this.manager = void 0 !== e ? e : t.DefaultLoadingManager
    }, n.MTLLoader.prototype = {
        constructor: n.MTLLoader,
        load: function (t, e, i, r) {
            var o = this,
                a = new n.FileLoader(this.manager);
            a.setPath(this.path), a.load(t, function (t) {
                e(o.parse(t))
            }, i, r)
        },
        setPath: function (t) {
            return this.path = t, this
        },
        setTexturePath: function (t) {
            return this.texturePath = t, this
        },
        setBaseUrl: function (t) {
            return console.warn("THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead."), this.setTexturePath(t)
        },
        setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        },
        setMaterialOptions: function (t) {
            return this.materialOptions = t, this
        },
        parse: function (t) {
            for (var e = t.split("\n"), i = {}, r = /\s+/, o = {}, a = 0; a < e.length; a++) {
                var s = e[a];
                if (s = s.trim(), 0 !== s.length && "#" !== s.charAt(0)) {
                    var l = s.indexOf(" "),
                        h = l >= 0 ? s.substring(0, l) : s;
                    h = h.toLowerCase();
                    var c = l >= 0 ? s.substring(l + 1) : "";
                    if (c = c.trim(), "newmtl" === h) i = {
                        name: c
                    }, o[c] = i;
                    else if (i)
                        if ("ka" === h || "kd" === h || "ks" === h) {
                            var u = c.split(r, 3);
                            i[h] = [parseFloat(u[0]), parseFloat(u[1]), parseFloat(u[2])]
                        } else i[h] = c
                }
            }
            var p = new n.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
            return p.setCrossOrigin(this.crossOrigin), p.setManager(this.manager), p.setMaterials(o), p
        }
    }, n.MTLLoader.MaterialCreator = function (t, e) {
        this.baseUrl = t || "", this.options = e, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : n.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : n.RepeatWrapping
    }, n.MTLLoader.MaterialCreator.prototype = {
        constructor: n.MTLLoader.MaterialCreator,
        crossOrigin: "Anonymous",
        setCrossOrigin: function (t) {
            this.crossOrigin = t
        },
        setManager: function (t) {
            this.manager = t
        },
        setMaterials: function (t) {
            this.materialsInfo = this.convert(t), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
        },
        convert: function (t) {
            if (!this.options) return t;
            var e = {};
            for (var i in t) {
                var r = t[i],
                    n = {};
                e[i] = n;
                for (var o in r) {
                    var a = !0,
                        s = r[o],
                        l = o.toLowerCase();
                    switch (l) {
                        case "kd":
                        case "ka":
                        case "ks":
                            this.options && this.options.normalizeRGB && (s = [s[0] / 255, s[1] / 255, s[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === s[0] && 0 === s[1] && 0 === s[2] && (a = !1)
                    }
                    a && (n[l] = s)
                }
            }
            return e
        },
        preload: function () {
            for (var t in this.materialsInfo) this.create(t)
        },
        getIndex: function (t) {
            return this.nameLookup[t]
        },
        getAsArray: function () {
            var t = 0;
            for (var e in this.materialsInfo) this.materialsArray[t] = this.create(e), this.nameLookup[e] = t, t++;
            return this.materialsArray
        },
        create: function (t) {
            return void 0 === this.materials[t] && this.createMaterial_(t), this.materials[t]
        },
        createMaterial_: function (t) {
            function e(t, e) {
                return "string" != typeof e || "" === e ? "" : /^https?:\/\//i.test(e) ? e : t + e
            }

            function i(t, i) {
                if (!a[t]) {
                    var n = r.getTextureParams(i, a),
                        o = r.loadTexture(e(r.baseUrl, n.url));
                    o.repeat.copy(n.scale), o.offset.copy(n.offset), o.wrapS = r.wrap, o.wrapT = r.wrap, a[t] = o
                }
            }
            var r = this,
                o = this.materialsInfo[t],
                a = {
                    name: t,
                    side: this.side
                };
            for (var s in o) {
                var l, h = o[s];
                if ("" !== h) switch (s.toLowerCase()) {
                    case "kd":
                        a.color = (new n.Color).fromArray(h);
                        break;
                    case "ks":
                        a.specular = (new n.Color).fromArray(h);
                        break;
                    case "map_kd":
                        i("map", h);
                        break;
                    case "map_ks":
                        i("specularMap", h);
                        break;
                    case "norm":
                        i("normalMap", h);
                        break;
                    case "map_bump":
                    case "bump":
                        i("bumpMap", h);
                        break;
                    case "ns":
                        a.shininess = parseFloat(h);
                        break;
                    case "d":
                        l = parseFloat(h), l < 1 && (a.opacity = l, a.transparent = !0);
                        break;
                    case "tr":
                        l = parseFloat(h), this.options && this.options.invertTrProperty && (l = 1 - l), l > 0 && (a.opacity = 1 - l, a.transparent = !0)
                }
            }
            return this.materials[t] = new n.MeshPhongMaterial(a), this.materials[t]
        },
        getTextureParams: function (t, e) {
            var i, r = {
                    scale: new n.Vector2(1, 1),
                    offset: new n.Vector2(0, 0)
                },
                o = t.split(/\s+/);
            return i = o.indexOf("-bm"), i >= 0 && (e.bumpScale = parseFloat(o[i + 1]), o.splice(i, 2)), i = o.indexOf("-s"), i >= 0 && (r.scale.set(parseFloat(o[i + 1]), parseFloat(o[i + 2])), o.splice(i, 4)), i = o.indexOf("-o"), i >= 0 && (r.offset.set(parseFloat(o[i + 1]), parseFloat(o[i + 2])), o.splice(i, 4)), r.url = o.join(" ").trim(), r
        },
        loadTexture: function (t, e, i, r, o) {
            var a, s = n.Loader.Handlers.get(t),
                l = void 0 !== this.manager ? this.manager : n.DefaultLoadingManager;
            return null === s && (s = new n.TextureLoader(l)), s.setCrossOrigin && s.setCrossOrigin(this.crossOrigin), a = s.load(t, i, r, o), void 0 !== e && (a.mapping = e), a
        }
    }
}, function (t, e, i) {
    "use strict";
    var r = i(4);
    ((function (t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (null != t)
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e.default = t, e
    })(r)).OBJLoader = function (t) {
        function e() {
            var t = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materialLibraries: [],
                startObject: function (t, e) {
                    if (this.object && !1 === this.object.fromDeclaration) return this.object.name = t, void(this.object.fromDeclaration = !1 !== e);
                    var i = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                            name: t || "",
                            fromDeclaration: !1 !== e,
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: []
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function (t, e) {
                                var i = this._finalize(!1);
                                i && (i.inherited || i.groupCount <= 0) && this.materials.splice(i.index, 1);
                                var r = {
                                    index: this.materials.length,
                                    name: t || "",
                                    mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
                                    smooth: void 0 !== i ? i.smooth : this.smooth,
                                    groupStart: void 0 !== i ? i.groupEnd : 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function (t) {
                                        var e = {
                                            index: "number" == typeof t ? t : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return e.clone = this.clone.bind(e), e
                                    }
                                };
                                return this.materials.push(r), r
                            },
                            currentMaterial: function () {
                                if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                            },
                            _finalize: function (t) {
                                var e = this.currentMaterial();
                                if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3, e.groupCount = e.groupEnd - e.groupStart, e.inherited = !1), t && this.materials.length > 1)
                                    for (var i = this.materials.length - 1; i >= 0; i--) this.materials[i].groupCount <= 0 && this.materials.splice(i, 1);
                                return t && 0 === this.materials.length && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }), e
                            }
                        }, i && i.name && "function" == typeof i.clone) {
                        var r = i.clone(0);
                        r.inherited = !0, this.object.materials.push(r)
                    }
                    this.objects.push(this.object)
                },
                finalize: function () {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function (t, e) {
                    var i = parseInt(t, 10);
                    return 3 * (i >= 0 ? i - 1 : i + e / 3)
                },
                parseNormalIndex: function (t, e) {
                    var i = parseInt(t, 10);
                    return 3 * (i >= 0 ? i - 1 : i + e / 3)
                },
                parseUVIndex: function (t, e) {
                    var i = parseInt(t, 10);
                    return 2 * (i >= 0 ? i - 1 : i + e / 2)
                },
                addVertex: function (t, e, i) {
                    var r = this.vertices,
                        n = this.object.geometry.vertices;
                    n.push(r[t + 0], r[t + 1], r[t + 2]), n.push(r[e + 0], r[e + 1], r[e + 2]), n.push(r[i + 0], r[i + 1], r[i + 2])
                },
                addVertexPoint: function (t) {
                    var e = this.vertices;
                    this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
                },
                addVertexLine: function (t) {
                    var e = this.vertices;
                    this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
                },
                addNormal: function (t, e, i) {
                    var r = this.normals,
                        n = this.object.geometry.normals;
                    n.push(r[t + 0], r[t + 1], r[t + 2]), n.push(r[e + 0], r[e + 1], r[e + 2]), n.push(r[i + 0], r[i + 1], r[i + 2])
                },
                addColor: function (t, e, i) {
                    var r = this.colors,
                        n = this.object.geometry.colors;
                    n.push(r[t + 0], r[t + 1], r[t + 2]), n.push(r[e + 0], r[e + 1], r[e + 2]), n.push(r[i + 0], r[i + 1], r[i + 2])
                },
                addUV: function (t, e, i) {
                    var r = this.uvs,
                        n = this.object.geometry.uvs;
                    n.push(r[t + 0], r[t + 1]), n.push(r[e + 0], r[e + 1]), n.push(r[i + 0], r[i + 1])
                },
                addUVLine: function (t) {
                    var e = this.uvs;
                    this.object.geometry.uvs.push(e[t + 0], e[t + 1])
                },
                addFace: function (t, e, i, r, n, o, a, s, l) {
                    var h = this.vertices.length,
                        c = this.parseVertexIndex(t, h),
                        u = this.parseVertexIndex(e, h),
                        p = this.parseVertexIndex(i, h);
                    if (this.addVertex(c, u, p), void 0 !== r && "" !== r) {
                        var f = this.uvs.length;
                        c = this.parseUVIndex(r, f), u = this.parseUVIndex(n, f), p = this.parseUVIndex(o, f), this.addUV(c, u, p)
                    }
                    if (void 0 !== a && "" !== a) {
                        var d = this.normals.length;
                        c = this.parseNormalIndex(a, d), u = a === s ? c : this.parseNormalIndex(s, d), p = a === l ? c : this.parseNormalIndex(l, d), this.addNormal(c, u, p)
                    }
                    this.colors.length > 0 && this.addColor(c, u, p)
                },
                addPointGeometry: function (t) {
                    this.object.geometry.type = "Points";
                    for (var e = this.vertices.length, i = 0, r = t.length; i < r; i++) this.addVertexPoint(this.parseVertexIndex(t[i], e))
                },
                addLineGeometry: function (t, e) {
                    this.object.geometry.type = "Line";
                    for (var i = this.vertices.length, r = this.uvs.length, n = 0, o = t.length; n < o; n++) this.addVertexLine(this.parseVertexIndex(t[n], i));
                    for (var a = 0, o = e.length; a < o; a++) this.addUVLine(this.parseUVIndex(e[a], r))
                }
            };
            return t.startObject("", !1), t
        }

        function i(t, e) {
            this.manager = void 0 !== e ? e : t.DefaultLoadingManager, this.materials = null
        }
        var r = /^[og]\s*(.+)?/,
            n = /^mtllib /,
            o = /^usemtl /;
        return i.prototype = {
            constructor: i,
            load: function (t, e, i, r, n) {
                var o = this,
                    a = new e.FileLoader(o.manager);
                a.setPath(this.path), a.load(t, function (t) {
                    i(o.parse(t, e))
                }, r, n)
            },
            setPath: function (t) {
                return this.path = t, this
            },
            setMaterials: function (t) {
                return this.materials = t, this
            },
            parse: function (t, i) {
                console.time("OBJLoader");
                var a = new e; - 1 !== t.indexOf("\r\n") && (t = t.replace(/\r\n/g, "\n")), -1 !== t.indexOf("\\\n") && (t = t.replace(/\\\n/g, ""));
                for (var s = t.split("\n"), l = "", h = "", c = [], u = "function" == typeof "".trimLeft, p = 0, f = s.length; p < f; p++)
                    if (l = s[p], l = u ? l.trimLeft() : l.trim(), 0 !== l.length && "#" !== (h = l.charAt(0)))
                        if ("v" === h) {
                            var d = l.split(/\s+/);
                            switch (d[0]) {
                                case "v":
                                    a.vertices.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])), 8 === d.length && a.colors.push(parseFloat(d[4]), parseFloat(d[5]), parseFloat(d[6]));
                                    break;
                                case "vn":
                                    a.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]));
                                    break;
                                case "vt":
                                    a.uvs.push(parseFloat(d[1]), parseFloat(d[2]))
                            }
                        } else if ("f" === h) {
                    for (var m = l.substr(1).trim(), g = m.split(/\s+/), v = [], y = 0, A = g.length; y < A; y++) {
                        var x = g[y];
                        if (x.length > 0) {
                            var _ = x.split("/");
                            v.push(_)
                        }
                    }
                    for (var w = v[0], y = 1, A = v.length - 1; y < A; y++) {
                        var b = v[y],
                            M = v[y + 1];
                        a.addFace(w[0], b[0], M[0], w[1], b[1], M[1], w[2], b[2], M[2])
                    }
                } else if ("l" === h) {
                    var T = l.substring(1).trim().split(" "),
                        S = [],
                        E = [];
                    if (-1 === l.indexOf("/")) S = T;
                    else
                        for (var C = 0, P = T.length; C < P; C++) {
                            var L = T[C].split("/");
                            "" !== L[0] && S.push(L[0]), "" !== L[1] && E.push(L[1])
                        }
                    a.addLineGeometry(S, E)
                } else if ("p" === h) {
                    var m = l.substr(1).trim(),
                        D = m.split(" ");
                    a.addPointGeometry(D)
                } else if (null !== (c = r.exec(l))) {
                    var R = (" " + c[0].substr(1).trim()).substr(1);
                    a.startObject(R)
                } else if (o.test(l)) a.object.startMaterial(l.substring(7).trim(), a.materialLibraries);
                else if (n.test(l)) a.materialLibraries.push(l.substring(7).trim());
                else {
                    if ("s" !== h) {
                        if ("\0" === l) continue;
                        throw new Error('THREE.OBJLoader: Unexpected line: "' + l + '"')
                    }
                    if (c = l.split(" "), c.length > 1) {
                        var I = c[1].trim().toLowerCase();
                        a.object.smooth = "0" !== I && "off" !== I
                    } else a.object.smooth = !0;
                    var O = a.object.currentMaterial();
                    O && (O.smooth = a.object.smooth)
                }
                a.finalize();
                var B = new i.Group;
                B.materialLibraries = [].concat(a.materialLibraries);
                for (var p = 0, f = a.objects.length; p < f; p++) {
                    var N = a.objects[p],
                        k = N.geometry,
                        F = N.materials,
                        z = "Line" === k.type,
                        U = "Points" === k.type,
                        G = !1;
                    if (0 !== k.vertices.length) {
                        var V = new i.BufferGeometry;
                        V.addAttribute("position", new i.Float32BufferAttribute(k.vertices, 3)), k.normals.length > 0 ? V.addAttribute("normal", new i.Float32BufferAttribute(k.normals, 3)) : V.computeVertexNormals(), k.colors.length > 0 && (G = !0, V.addAttribute("color", new i.Float32BufferAttribute(k.colors, 3))), k.uvs.length > 0 && V.addAttribute("uv", new i.Float32BufferAttribute(k.uvs, 2));
                        for (var H = [], j = 0, W = F.length; j < W; j++) {
                            var Y = F[j],
                                O = void 0;
                            if (null !== this.materials)
                                if (O = this.materials.create(Y.name), !z || !O || O instanceof i.LineBasicMaterial) {
                                    if (U && O && !(O instanceof i.PointsMaterial)) {
                                        var X = new i.PointsMaterial({
                                            size: 10,
                                            sizeAttenuation: !1
                                        });
                                        Q.copy(O), O = X
                                    }
                                } else {
                                    var Q = new i.LineBasicMaterial;
                                    Q.copy(O), Q.lights = !1, O = Q
                                } O || (O = z ? new i.LineBasicMaterial : U ? new i.PointsMaterial({
                                size: 1,
                                sizeAttenuation: !1
                            }) : new i.MeshPhongMaterial, O.name = Y.name), O.flatShading = !Y.smooth, O.vertexColors = G ? i.VertexColors : i.NoColors, H.push(O)
                        }
                        var J;
                        if (H.length > 1) {
                            for (var j = 0, W = F.length; j < W; j++) {
                                var Y = F[j];
                                V.addGroup(Y.groupStart, Y.groupCount, j)
                            }
                            J = z ? new i.LineSegments(V, H) : U ? new i.Points(V, H) : new i.Mesh(V, H)
                        } else J = z ? new i.LineSegments(V, H[0]) : U ? new i.Points(V, H[0]) : new i.Mesh(V, H[0]);
                        J.name = N.name, B.add(J)
                    }
                }
                return console.timeEnd("OBJLoader"), B
            }
        }, i
    }()
}, function (t, e, i) {
    "use strict";

    function r(t, e, i, r) {
        this.object = t.object, this.event = i, this.running = !1, this.target = new s.Vector3(0, 0, 0), this.path = [], this.nowStep = 0, this.prevPosition = [], this.nowPosition = null;
        var n = {
            NONE: -1,
            ROTATE: 0,
            PAN: 1
        };
        this.state = n.PAN, this.totalDistance = 0, this.discrib = {
            distance: 0,
            remain: 0,
            remainTime: {
                hour: 0,
                minute: 0,
                second: 0
            },
            nextDirection: ""
        }, this.config = {};
        this.set = function () {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return t.dom = t.dom ? t.dom : document.createElement("div"), t.speed = t.speed ? t.speed : .3, 2 == t.pathPoints[0].length ? t.naviHeight = t.naviHeight ? t.naviHeight : 3 : 3 == t.pathPoints[0].length && (delete t.naviHeight, t.cameraFollow = !1), t.naviSize = t.naviSize ? t.naviSize : 1, t.naviMarker = t.naviMarker ? t.naviMarker : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUMyNTgzQTVBN0I4MTFFNkE2NDRENjY2NTMwRUEwNTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUMyNTgzQTRBN0I4MTFFNkE2NDRENjY2NTMwRUEwNTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2RUY3NEZGOTlGM0ExMUU2QUE3RkNBNzQ0MEQ5OTA1MCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2RUY3NEZGQTlGM0ExMUU2QUE3RkNBNzQ0MEQ5OTA1MCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pi+6GDYAAB1vSURBVHja7F1pbFzXdT5vFs4Mdw5JLdRGUQutxVLsKLIkL1LsOI5jOymaBPnV9k8XpEX/NwX6q02RH/1RtGiDogWKAi0CpG0Kx3YSJ6kkO5Yt27JjqbY2i6soiqK4iDuHs7x+37vnkSNyZkjKHHLecC5wNBQ1mnn33HO+s9xzz7Vs25bSWL/DV2JBSQBKYx2PQCE+1IWbIn/5ui2vfixSHRGJBFfsoy1QCBRVKgclQfdA/aCxlfiSqbjI6JTIiwdF/uI5S45sKwlAISFeI+gp0BOgnVwv0HnQz0EXSwhQ3GM76CTot0CPgxr091sVDSggn4LGSz5Acc51D+gF0DFQTdq/8fffAL0Iqi8hQPGNatA+XeCTagbSR43SV0BtigAjoEQJAYpjUKufBz03T/PnjyYVkEfUJJQQoAjmVws6AXoWtHeR928GnVLtHwRd0iihhAAeHeWqzSdVuxcbDDi3gD6vwlJR7Dwq5sn5QbtAX1at3rxEfnDRD4O+CjoOqiuZAG8KdoVq8aOq1ctJJ9FpfEbNQJe+lgTAQ4Nae0S1+PADOHSuKaAQXBOTKaQQxEsmwBujUT3+Z1SbH3RsVOfxSVBlCQEKfwQ15Dupi7/lM35egy4+o4Je0AXQDMguIUBhjkpdsGdVe1eCPwwjD4AOqUAUldIUiwC4u3z7xWTznpS5PP9n/dwyUKualKdkYRaxZAIKZB4NqqUHVGt9K4ws3D8YUKewtyQAhef0PaVa2qpau9J82qjfcV1M7cCdYogKisUEbFKn71ievfUGNTFMLtWUEKAwvH4u/pdUOzfm+fvqVMiGQd1iCkkmQakSAqzNqFFtfH6FnL6lDDqbu0FfEFNgUlZCgLURXHejxy3wCK/id7eo4I2CpkHtJQRY3RFS7aMW7loDLYxoxEGzs7WEAKs/uLP3RTEJn5Y1EGTuNLKqmLuFNzQ87BBTYFpCgFUYW1X7Dqk2rtWIalTwvHh029hrCEC7v1Pj/eO6AGs5uOXM7eYhMbWEZ8WcLUiWECB/YdjzStECei76Iywzf2iNEaloESCo2nZEtf+RAjRJT4vZNSQCXBaP7Bh6BQEqVLuOq7YV2ghrbuC4mig6iVYJAVbW2TqpsffOef9mayzOvHxMX7lnn1BKKqWU7HlkKfnSyK8UVB6V6c9hDUGDGRSJhSefAz2mkcFN0ERJAFZmMOPHSt2HMzwzF7tPTHrWfb0rc4c7pnUhZlRAkiokrkD49DPdBeZrpTqc9DmqxGw2cYeRBSYbJPuWcIVGJp+ISRKVBGAFhqWMrUtbbNboTWr8TQ+8V393O4sATKYJQK4RSvM3XAGonicAjfoaVcGM6HvK9VkPqI/ykXhg29gLAuBC8i3Q+6pdl/Tv7pbsfBMwX9NdE7DYcE3HjGrwYAYTUKYCUqX+yA5FJiakmlQwNqkwlXyAFRoDGmNzAa6qAAwtFT6SsPQJLH9ycRGgT5D0+yQZgNj5LZlaxJV3hYDPtEuFgUhxzQvw7xUB4LJ1K5z7FNpHl7r4PvwxA/0fB0bEl5ieCQJvqiBqQXAnZeeM52haulQYL6gZCOvz9ZUE4AFHKOBo36xWWia2Hsu2yimISDyDhnPxElj0Brh0BzfDUIdzhsFuVCCjEJZ2gP8ARC3gN0KUPoAQEgT5gBT4H+OSpZ8A5xAKlARg2YPaRwi2UmaFsgXUlgZwXPxMGp6CB+CfgicHt+13jlpyaPOCuZfpx7t+Am2/XIIr+XdnbbkF3Z6Ei+cLLkQIChOFw5Ece6FU8dk5h6rwOhaAcbhinQDukQnDFf8SUyNX+oGfE5bYAbMiPntO0wnnKXtOwy38PQoNP7bZlpqwM59yddLKppMSHp2ygl/aK+GXDkhZY4XjsZep5x6aJwB0/ribN74jKpMdA1Y8Uiax6og9E/Y7v4+pXZ8amZb4jQFLBqH3dhpC8LUMf49jrnz2Prz7TJvIvg3L4xt9Fj5RDWbRjDijMo/upJXPPoEfYyF/8A6MY7thd8i/RMHBqncjmBuaNHBLxlp4nYFG21Myt9WC1yDes2WfyJ9/EbFXk+OBN2tWrgECsgUmoL6+Uja1RKUGmhuZl/CZbwKcpBGQZLp9SCawwHeg5UP4/i616UzwdP+mVwb++gzCkCtY7HKNUcS8WhGDDEl8Uh3+bTsCycplVivEkkbcjiCu+M5xmK8NHkWAIWjAaSx+B9yjOKQ5tVRG+IyOWgFt0ZE0gV4An9EKGK8xsBqKJeBxT0vV461S98IBqWuqdLKEswKg8Xq9LHPjiBDf2uhE/BPq4LkCwP5B3U110vnxXRk6F8S/hWUcdp65hxiQQa7Bd4hPGGwZxOvgoCx7b9AHBQhOGE/y24c8bAJoA6tDuvjlsvS6HWtON/mjDc0PgMUbsKTfeUzkUXPSvwFQeRRQub+uUg41RJwikTqF9wr9trB8tmqhiCZ+KlWomOCZwncN/+Fj0vetA3IRz3kFpu09/L7nw14RIkN/DwQ3mvYEywTZVMAkMMi7gM/DAkDoJuw7ml9mNHopw1YbyIV3tAfL0LJLyr56SKLfOih1G4yms7ET8+77NBHjz8cUdAnvc+Vo5w804skanePnMATCToDXd0Wl88agDP80JYPXJ7CGUzK3q+BTp3Up8+f0E4Z3PsvDAvAgOV/bmoN8CxQEE6MPifzpU1L7dKs8URtxCkCPpEF7VZ4Wf7Hh1+wfLfRBmgo82/t/cFTe3lUjb3zvTRkcAhLEIby2K0IBOl2FtU9cUAJAL5/YVwYAfwgwHwqCbdPS+ESrNH/7EdkPL5577sdkhbaEbfnMe7ZVSpsVGZr3N8qWxnKJto/I1bfC0okZ3I3FJXYVvsAM7LodNA5tSQAyab7a+gbY+j/CMh/eBEcuJc/Bxj9bG3a0bYusUO0dzUzCNt+9gnaWaHCSz/r7R6X9G/vlF4D+X17sk57vnVbfoM6gQaEgQaCQNJ+hImy9BVtf/80D0gRbz+NerAA6JUvcXOHCTsRNv16+Mjk0HTf5A74yxJqClz2VNPsDzvFfcCECKg+aCIA2nkIRDppMXkXQ9Cvm6yJ2nEC/GZ+xGUjwMHwEp//gnno5/emA3FLfQOzpwkGCQEFp/m7H1gdg6x+BPX1JzJGvxuV48swKduGzukcQtA8gDIMPcWvUhGTD+DkB52ompY6WIgAXlc4WF9/N8tWBmrB8G2CO9gKRttXC66xfei5DBZa+yg7MpQW+wcvqGyQG+goHCQIFpPllLxyWrbD1+2Drv4bfviRL6OwVS5iFvRcDxI6J9IKu9asAIIIfmBS5iZ/Hxo1jObspbOVwCNihHLSNAgALvxeu5lb8/BAAfgv+DmRyUrzRiEGOHBGEk00AotQBEcrgG4TgG1x5zZYeRgmFgASBAtJ8evmPw36+pI7ekpI3d6HZ57pEfnPb5PCZPaTWE+4n40bbaQ5mA7olBn/TEKyeUfP5nYOOQyr1EbPoBzfBP4FoPr5DZOfSPBLO5XnMLQrf4OWWGnkdSDBQCEgQKADND0Lzd0LzH4Pm/7bCfmUuz50Zt0EsdCc0/DK0/Y12CACY2c7yELeDj19n5yaVrOXlIeykEaBJ/DyslYVt/CwIwlV853WYl36gyn6gwi6YBmi31EZymoPtMC/1QAI/3wskeB9I0AkkmFlLJAgUgObXQPOPQju+qYmdnHX1dNwuY6Hf7DSa3ztiIH4kroselvtLPa0skL/IgzrP6tfP8t3/mb1AhbEu42tshKg+3izyDGKUY9vN3sUiTiJRLggkCAAJRoAE/UACe62QILCaqz9P8wWavx2afwya/3UxdfVZNX8UNv4mILkNmve/bSK/hgD8pkc/L6luon9ltMhKE4L5gkN0mCECjWmeHxzsxXMNqJO5Cw7j1mr4CKGsyaONQIKngQQJIEEcSHAOSNCVHh2sZkF5YNVUXxZovgXN3wtt4OUNT+TSfDKdHv3Pr4u83S3y4S1o/Ix+bkDJt0qMs+T+qn+8tmFOA5dEOoaMX/DcXpHPbc4ZMnKuJzD3GJCgH0jQDSSwZ32CwOoJweoIgO62ByuMvXz+sNSqt8/Ff0YTKAsG98Vp6z8B5J+FnX/lishHvRCIMZkr4PbPIfSqybI1l3ymcE5Be6eABq/BJ7g9anIN9FP2b4Swl2fM5/vSkGAQSDDB6OBnCGbapnU3MVVEAmAlzD7+PtjIPz4q8uRu2aiazwscarP9P3ry56Hxr141Wk9BcDaKytMcO1njjJqLQuXm2S7dxa+umnD0hYfg0cI3KM+exeDcXwQvJoAEQ61RufeP7+EzBkyhS1EIgFN1kTR73DVwfgD70T1R55QPM3w7Mmp+yoRyF2DjX7ks8jI0/y61Pmb8BysoBbOjYrmTBCLYEPQ4EOACC1rumURTAG84stWEkBkcRIrGDiDBc0CCdryO/MclGQxOSTzlX51ze4F8M8entX2szcOiVg1NyAlExVlhn4Ph13s3RX6ChX8HQnB3PC2Y8klhHrt0o4WQ+Zkh4jvdWmaE+Z9qyeoYcrC51TPgzV3w6Cx4NWSXK++8LAC04VxMXxXEfKf4Tu2UnRUh53wfnb4FTZ1S+n7a+Z/C4XsVAnB7TD19xsl+Kegzt5aaA1uPlnzSZyqLWUHM9PLnm4w5yOATkBdPgDdD4FF3ckxGOgYkBV7YyTzPN68ow7z8CGC7vkF8f3JKQt85Ls3NNU4BR30m4eOGDWNras6H0Py+EV1wdxPGCweubQ1F1UzdGTVzebsLUcKwmWOW8DBK3oBHLeBVGDyzyLt4ysMIwJ04xsahiFQ81Sr7D25wbH+rZNnZ68GCn+kwTt8lOnyuzQ+It/pzaxGrgwQxM5cyn9lt5A7jnvqM1jJUGZJW8ghsu/k378on4N1oPOlhAWDWbhgMCMxIjWP7zeVNVdneT8eJad0Pbprt2oK2+cvwCaZnTNJqQ7XIgU0ZBcAdTIQdB6/aYTpuJmwZTXgZATZUivX1VocNzTUhx+4/LBmubpkEg9oQR//qBpw/wP/kPQ31guZMgFeb89PW83wAaxsn4Mu8C8HeA2u/AXPbXZ8xPOSsD4JXJ17Y63QhvQ0epvKpAnkVAEzS92ennKzXNvzs3tuzwAVi0oSJHhK3dZ0kj6/w6uceBARmkSBs/CHOsQl63liRUQAcNxK8agLfWGh6ET+nn4TwlgBUh6Ti0Sbn1Kx7cdN9i2/rqd0b0P6zHUb7U/pUliVFMzgX5vh5fO19zLGpyqSK6ytMhDBvrhb4tgV8I894ypiHUcbyhlJ5njvr83mJwz7JsBvPmjxu8jCXzqqdJEyBnZLVy+uvZraIc8LcUjNmru33DPJl8fLLlW8HJM93FeVbAJjqZFnUQRWG+8YEmPExPOR3e8yWrntTbzHeZDU7p4SJds7fNHOfmMmqOPSXPi85UuVeEABKcrNm/RaEfmMzpoqHxASQe1TTLkIBsF0kKDNzvdQn8n99hgcZRpnyjOXvES8KgJsUpd3fppNY8F1M8X5wC4yAAIzFTDqkmGx/Jl+Ac+RcKfQXbpk6giz8CyvvtqQFxJ4RADqXdfrwWSvx7rFiF+7NOCiZKELbn8UX4Fwnx0ya+97Uogi6VXkZ8JIAhPXBd2Wy/fT82TuAqVFW0zgZv9T6uMvemWPKzLlv1PCAiJAl4VOhPNwmeboPIV88J2Rxh6sxU+KHFbedwybz56Q6/cVr+7P6An5TOEIekBfTiYxvD6ovsFHy1HUsXwIQUandmkly6fleHzT1fcwCrmYJVMGYgoCZ+6cDhhdZogEXSbflyxnMlwDQi40qLch3UfLvTor0T+rumLUOBUC7l/HgCimWzMrHOqUyrwnABqWyTCbg1oiJhycTsj6MfwbOT2pOgLzIYgJy8rHQowBmsKoyea90eO5Niwy7mbB1hgCz3c2w6ENTc2cWs/CxSnkZyNdC5etza9SLXSBkMwlzWJPHrpL2+kUACj/hn8fZsqSE/TLXltZTYaB7RiejXvOAyFSC7bgk+2HNYo4EdK7cDGNOgL5AjtIvPZCWHw7lUwDKsz00TcCE27s7tb78v/s1QZx6RypDKpVTACLisUygL5fTwuLPmHuNg565W29BwOyBhoTxBVL2ok61pwRgUVBPzXbmXecDmh9LLXoQyHMC4HbdzOoFB6x1GP9n0g57Ya/h5SpTIQoABXom15eG/HN+7boGAp85MbTICifzxaZ8CkAsFwIE0xs42OtLCGZrBdW/DwcWbQg54zUBoMROSRbTxg5clW73UN/6VHxn/dVVJi9ytKrjWyclT4Wh+TYB8UySS2kvD5mJW27d/3qDANsgYaTMtJ/L0Vkk4UUB4EOz2fWYzFb6pbm0mHBDhcimCtOjb7XOwhea9x8EHzaWG16UBbLykTy8l4mP3hUAv3bcwuTD6xUBlA+8U6AuktUEuAIwrmjqGQEg/PcrLYgG2FuPffdIkXWMAOUB04uQfAhnRgA60ney8bHQBWBIaSYTAjRGFPr8Ivk9/FSgCJA0c2cjyk2VWQXA5eOg1wSAEQBv2eB1b9MLEAC2rzkqsjtqnKD8RbkFPJLGCeZB0ZaoOTmcYUwrHzuVp54RAEJXn0LXAtvFJFBTtem/G/bPCYC1nhAgZbSePCAvsvQgdq/K7c2kSIUuAHzodslwrs2vZ+Wba4398+vFS6kiTwg5vq7WP3DOnPuOGsOLLGEgedemvIx5SQAS6rnyMuesV6hWhiEEdQiFIAjBsnUSDdgm5GvEwm+vzdk3SJR3t72YB9CNTufhO1QYFkygIWLaqz66DaFQKFvaqLg8f86Rt54dwZwf22Yc4cwegsOzDjUBCfFYKjjdGaQZuJnJieGFiIeaQJs0HCziAhHLFYCYgXx2G+ftZ9WhrHzrVt7F8vlc+RYAZrDeBX2QyRcgI/bWmz56LXj1a2OIYvMF3MspKAWcI7ulHsWc9zZm9f7HlGfvKg89KwCcyMegy5m8WOeWDp9JhrBlSpQOYTHmBdTr9wPl6nWuW6r1fmQra/h3WXk3ls9Hy2uHkNGYTN8YdOJYtjrpYucLmVfgSCGgI/jMblMh+zYi3jtDkscyyDUSAFjxhmptLY+57qjLOD2+Mw6+dYFvF2kGKCzVIY8iAFu/fP+sQ3fwM+1ZWhuIucEJPrUDBObUlmv0m0qznR5fe3dvlHl/zpFzzbKo5M0IeNUBnvWTd+ShZ00A26W+fE3ktevSMxKTs9l8AaZEN0M7ngRzTu4EozaY3oDsrpXysClwYv64mQvnxLlxjpuqNQWexfaDV2fIM/Kuf9zDAkAbx/CuoVJGohXyDn71Ti6bRrvIXvtf2mVyBI4l1LODXkKC2apfvQGVc+GcODdm/XJZTdDb4NU58qzO63cHs+yLW50j4zL95jW5gb+ea66RIwj/eGh0wakhtk4jRPJev3FozhkEQNNJ03HT9nmne0jKzYLgmSNY8CcA+V/fb7S/Lpw1QzAxHpNLnSPyFnjVHkcgWFeppXNeRQB6+DWQ4sEBkX+AAfjBO9KLCX6gCY4F8a1P388WatSYz8FlDPhlrrjM8oj6p4zm89k5h2d3mTlxbr7MHCcv2sCbC+QReUWe8f1BLyOA3zJxbgqg38VbP6rk1u8+KqfFdL7iaZc983lHiedFjdQiNo/gbuH5TnN6xtaLoQoVCWxX8/GM5dD8Y9D4rwD2n91t5pRDm2+BTk/E5PTZDunt+gTzL9c9Ai/fHu6EvykD38mIUwU0CfvG2Jbt0R+eLwDpvsPOqAmXyADn5pAefM6EERvHQSxAxXeaQwOtfBDvR7eKvPgQHL8Ws/W9iC1npvQt8OYyeDT1acTwLJXK/zzzfmMI0ZC3XyTLnMaIidPXZDi+W87viUozNIIniNk9/L4G0tRw7pUzVRrRrqH0JXh9DI+Up9IaSq0lGsyWd9umwaWFZ66H5p9grA/Y/zK0v7Uhp+WiQ3wdSPfqp0Ny/tc3ZNhpHhkxV8asRqHUqtwZxIbJPCt8BTHt354RuTYkw989Ja/B6eO599+TLB3EmSRiwuS5PSZ0olD8sg1CwCqDMpm9Lcxag/5Clgv5eiEWrXgj7PxXsehfOyCyD2HftupF3RaWe/3PvWn5yb+8J0M/uwhHYNqgnD29OvNYnVvDfOabeBvWDUD5D4HqLTVy/elWeQ1I0AAk4L2BmyRDIyQuOq9q3aJ1c0wUvdFh2quxx0AiaW75nG0xl8eQcb7GO/v6AZPh462hNFkvtprrYSLBnB9Fp++2av4rQMUbP8TiD9xIuzbOV0wC4Kpn0Eywb1zk799wrk/tAhL8J5CAa8abQ7NeFs198xPbTRHJvkZzceSZdqDBiLIzDRHyKgGuxs8Yca0qN3cFOkmsFnNpZGhxrjK/9xNo/n9B82++9hF4Qv+mTmZvGlktSFu9m0MxIR9v1gobeGvvAxJYMggkeAtI4AcSlPH2LBWCUCbHcHOVoY1K9eUmVdoOGseijE2Z7iN2Mg2n5x1Anb2+dp6cOJt19jxNl3mLgWcI4slqsMgVAbODuQuL9vRuk+VbJMkjmtq6A81/HZr/Y2j+OUfz28ziW3p1bCqxaquyuncHzzJ2IRJcARL8O5BgSpFga67P4eXLp3aarWReJ8sbxth6la93mUublNmr3Bzyza2+nbbq9jwJmD2lm0rT9pRm9PiK741CAI5ug1naKPKFbUbjWdoVXVoTt7uq+T+G5l/JpPmr7cusye3hTIbMQwJen9oPJLCBBBaQ4CvqE9Rk+v+EWBcNHtmCkLHWeNt0GNl4kZ23YtCi8RmTS5jSNiz82WnLkr7A6RdN+0zYGQqbXD0jkGDAaHtIzzLQBHHhD0MADm5ecpw+opr/c2j+f0Pz38yk+evm+vgcSHAZSPCvQAL6+XQMjy7Fv2RZNS9fYNjItqvdvFEcggBmS/+oaUXPm0jYjYudSSZjasfdHkV6y5cVMokn1uk3aNEmP5cwz+rd7TXGF6Hp4esykjTXQa9A81+F5ncXguavqQDkQIJhIMEwkGByd1RmoIXcC9umfkFlLgeRtFVt8NGUEQJeOH1n3PThowAwxp6JmxbtRAWiBNGAFbksy2aJGg9q8rAGj65tqTV1i7T1XPxlbsy4BZ03gT4/u2G8/auFovkFIQDZkKBtRG5996T8eEOlU0PAy6boHO5f8qToMFaaPXc6hVxstmFjcypm15JKbumZpTkHCgL/L6t2g2oCaAqYkn2AXTlm915nhg8h64f//J7c+WkBaX5BCEA2JPiRTyb3NEj74U3SDYi+U1cp40CEDizGHmVfVGbv7848GIcvEouv9KCrOEyCxn8Kjf9oeBwC4JPzF/tk5keXYI4KSPMLSgDmI8EAbPU/nQcsB2Gpp+Xy460yDER4A4hwHO96XKlKCmsw9rgAOg+NPw+N7zl3TXolLPFY3MwpUUCavyoC4LaD483hqaVu4OB9M2PmCnU/7HZwSoZvTMjwtmq5fHiz9Ngp6Y1WyJ3d9dJcHXYiBQpCrQnSVn3BWbE7PjotfSzjGpqQX1vU+Nvyyb99CNNzxeT1kyHNbJQZp9NeLMk/Y3hG3uW7IirvN4fyVrDghDrciaVDAjdDuCNGBk5DGP7qrJMK7vFNyy9OtMolRAubHmmSQ+obMFpoWcwsrOTUxGzhvge60jYkl77/htx++5r0pcJyj42fhynAuqvnzMXtl7IUkzhjeDaa/SIJbwgANFWebjG4SA0IPcDysIUMIZRePDRtQr3rHv3nayoAXSoAzWLqDCpU5yIKuiGda2AZCxzXzB1fpzT5O6nfz+/rcAVAw7zZAVPlJKlgwhbX9gzDaaKJ+R5pMTzM57BsO38Yw2thOhGCjUzMJVke1JQ4XnzSMJRMccqlww7sp5sAtlVvEnPNinvrFh3GjRpG1srStlmG1KG7rXn7Hn3tFHNQsz/NBIxBMCeZkoYJcASWlUCs5PE94HyTmqSqqeCduyY89aQArNGoUjTYqAJQN08A0hHCl5b8dTV8Whf7ni72kArAgGr+WDExqxgFwG1UPd8E+PXn9B0CKy0QSc/6uxY7pj9P62te7/Fdt2FgHuLxsWLT1LzlYEosKAlAaazj8f8CDABibvt9JzQHegAAAABJRU5ErkJggg==", t.cameraFollow = !!t.cameraFollow && t.cameraFollow, t.loop = !!t.loop && t.loop, t.naviColor = t.naviColor ? t.naviColor : 3381759, t
        };
        var a = this;
        a.set(e, a),
            function () {
                var t = void 0;
                if (e.cameraFollow) {
                    var i = i = new Image;
                    i.src = e.naviMarker, i.onload = function (i) {
                        t = new s.Sprite(new s.SpriteMaterial({
                            color: 16777215,
                            map: (new s.TextureLoader).load(e.naviMarker),
                            side: s.DoubleSide,
                            transparent: !0
                        })), t.scale.set(e.naviSize, e.naviSize, 1), r.call(a, t)
                    }
                } else t = new s.Mesh(new s.SphereGeometry(e.naviSize, 32, 32), new s.MeshBasicMaterial({
                    color: e.naviColor,
                    side: s.DoubleSide
                })), setTimeout(function () {
                    r.call(a, t)
                });
                if (!e.loop) {
                    a.dom = e.dom, a.dom.innerHTML = "";
                    var n = document.createElement("div");
                    n.setAttribute("id", "distanceToItem"), n.setAttribute("class", "naviDiscription");
                    var o = document.createElement("div");
                    o.setAttribute("id", o), o.setAttribute("class", "naviDiscription");
                    var l = document.createElement("div");
                    l.setAttribute("class", "naviDiscription");
                    var h = document.createElement("span");
                    h.setAttribute("id", h);
                    var c = document.createElement("span");
                    c.setAttribute("id", c);
                    var u = document.createElement("style");
                    u.innerHTML = ".naviDiscription{\n                padding-left: 5px;\n                padding-right: 5px;\n                height: 30px;\n                border: 1px solid #ccc;\n                color: #333;\n                background-color: #FFF;\n                line-height: 30px;\n                font-size: 14px;\n                border-radius: 3px;\n                margin-bottom: 2px;\n            }\n            ", l.appendChild(h), l.appendChild(c), a.dom.appendChild(u), a.dom.appendChild(n), a.dom.appendChild(o), a.dom.appendChild(l), a.domControl = {
                        distanceToItem: n,
                        totalTimes: o,
                        remain: h,
                        nextDirection: c
                    }
                }
            }(), this.naviDiscription = function () {
                e.loop || (a.domControl.distanceToItem.innerHTML = "" + (.85 * a.discrib.distance).toFixed(1) + "", a.domControl.totalTimes.innerHTML = "" + function () {
                    return a.discrib.remainTime.hour ? a.discrib.remainTime.hour + "" : ""
                }() + a.discrib.remainTime.minute + "" + a.discrib.remainTime.second + "", a.discrib.distance ? (a.domControl.remain.innerHTML = ": " + a.discrib.remain + " ", a.domControl.nextDirection.innerHTML = a.discrib.nextDirection) : (a.domControl.remain.innerHTML = ": ", a.domControl.nextDirection.innerHTML = ""))
            }, this.computeTime = function (t) {
                var e = .85 * t / 80,
                    i = parseInt(e / 60),
                    r = parseInt(e),
                    n = Math.floor(e % 1 * 60);
                a.discrib.remainTime.hour = i, a.discrib.remainTime.minute = r, a.discrib.remainTime.second = n
            }, this.computePathSegment = function (i) {
                var r = [];
                if (2 == e.pathPoints[0].length)
                    for (var n = 0; n < e.pathPoints.length; n++) {
                        n < e.pathPoints.length - 1 && (this.totalDistance += Math.sqrt((e.pathPoints[n][0] - e.pathPoints[n + 1][0]) * (e.pathPoints[n][0] - e.pathPoints[n + 1][0]) + (e.pathPoints[n][1] - e.pathPoints[n + 1][1]) * (e.pathPoints[n][1] - e.pathPoints[n + 1][1])));
                        var o = new s.Vector3(e.pathPoints[n][0], e.naviHeight, e.pathPoints[n][1]);
                        r.push(o)
                    } else if (3 == e.pathPoints[0].length)
                        for (var l = 0; l < e.pathPoints.length; l++) {
                            l < e.pathPoints.length - 1 && (this.totalDistance += Math.sqrt((e.pathPoints[l][0] - e.pathPoints[l + 1][0]) * (e.pathPoints[l][0] - e.pathPoints[l + 1][0]) + (e.pathPoints[l][2] - e.pathPoints[l + 1][2]) * (e.pathPoints[l][2] - e.pathPoints[l + 1][2])));
                            var h = new s.Vector3(e.pathPoints[l][0], e.pathPoints[l][1], e.pathPoints[l][2]);
                            r.push(h)
                        }
                var c = new s.SplineCurve3(r);
                a.discrib.distance = this.totalDistance, a.computeTime(this.totalDistance), a.naviDiscription(), e.cameraFollow && (t.target = c.points[0]), i.position.set(c.points[0].x, c.points[0].y, c.points[0].z), a.startPosition = [c.points[0].x, c.points[0].z], a.prevPosition = [c.points[0].x, c.points[0].z];
                for (var u = 0; u < c.points.length - 1; u++) {
                    var p = "";
                    if (u < c.points.length - 2) {
                        var f = (new s.Vector3).subVectors(c.points[u], c.points[u + 1]),
                            d = (new s.Vector3).subVectors(c.points[u + 1], c.points[u + 2]);
                        Math.acos(f.dot(d) / (f.length() * d.length()));
                        p = f.x * d.z - f.z * d.x > 0 ? "" : ""
                    } else p = "";
                    this.splitLine(c.points[u], c.points[u + 1], this.path, p)
                }
                this.running = !0
            }, this.update = function (t) {
                if (a.running) {
                    if (a.nowStep < a.path.length - 1) {
                        var i = a.path[a.nowStep].newStart;
                        if (a.nowPosition = i, a.discrib.remain = a.path[a.nowStep].remain.toFixed(0), a.discrib.nextDirection = a.path[a.nowStep].nextDirection, e.cameraFollow) switch (a.state) {
                            case n.ROTATE:
                                a.rotateCamera(i);
                                break;
                            case n.PAN:
                                a.goOneStep(i, t)
                        } else t.position.set(i.x, e.naviHeight || i.y, i.z), a.nowStep++;
                        a.discrib.distance -= Math.sqrt((a.nowPosition.z - a.prevPosition[1]) * (a.nowPosition.z - a.prevPosition[1]) + (a.nowPosition.x - a.prevPosition[0]) * (a.nowPosition.x - a.prevPosition[0])), a.computeTime(a.discrib.distance), a.prevPosition = [a.nowPosition.x, a.nowPosition.z]
                    } else e.loop ? (a.nowStep = 0, a.discrib = {
                        distance: 0,
                        remain: 0,
                        remainTime: {
                            hour: 0,
                            minute: 0,
                            second: 0
                        },
                        nextDirection: ""
                    }, a.state = n.PAN, e.callback.call(a)) : (a.running = !1, a.nowStep = 0, a.discrib = {
                        distance: 0,
                        remain: 0,
                        remainTime: {
                            hour: 0,
                            minute: 0,
                            second: 0
                        },
                        nextDirection: ""
                    }, a.state = n.NONE, a.event.off("animate", e.animate), e.callback.call(a));
                    a.naviDiscription()
                }
            }, this.goOneStep = function (i, r) {
                var l = (new s.Vector3).subVectors(i, a.target);
                a.object.position.add(l), a.object.lookAt(i);
                var h = JSON.parse((0, o.default)(i));
                a.target = new s.Vector3(h.x, h.y, h.z), t.target = new s.Vector3(h.x, h.y, h.z), r.position.set(i.x, e.naviHeight || i.y, i.z), a.nowStep += 1, a.state = n.ROTATE
            }, this.rotateCamera = function (t) {
                var e = (new s.Vector3).subVectors(a.target, a.object.position),
                    i = new s.Vector3(e.x, 0, e.z),
                    r = (new s.Vector3).subVectors(t, a.target);
                r.y = 0;
                var o = (new s.Vector3).crossVectors(i, r),
                    l = i.dot(r) / (i.length() * r.length());
                Math.abs(l - 1) < 1e-4 && l > 1 && (l = 1);
                var h = Math.acos(l);
                if (h < 1e-5) return a.state = n.PAN, !0;
                var c = Math.PI / 180,
                    u = h > c ? c : h,
                    p = o.y > 0 ? -u : u,
                    f = (a.object.position.x - a.target.x) * Math.cos(p) - (a.object.position.z - a.target.z) * Math.sin(p) + a.target.x,
                    d = (a.object.position.x - a.target.x) * Math.sin(p) + (a.object.position.z - a.target.z) * Math.cos(p) + a.target.z,
                    m = a.object.position.y;
                return a.object.position.set(f, m, d), a.object.lookAt(a.target), !1
            }, this.splitLine = function (t, i, r, n) {
                var o = e.speed,
                    a = (new s.Vector3).subVectors(i, t),
                    l = a.length();
                if (l >= o) {
                    var h = o / l,
                        c = h * a.x + t.x,
                        u = h * a.y + t.y,
                        p = h * a.z + t.z,
                        f = new s.Vector3(c, u, p);
                    r.push({
                        newStart: f,
                        remain: l,
                        nextDirection: n
                    }), this.splitLine(f, i, r, n)
                } else r.push({
                    newStart: i,
                    remain: 0,
                    nextDirection: n
                })
            }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(9),
        o = function (t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }(n),
        a = i(4),
        s = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(a);
    e.default = r
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = function () {
            function t(e) {
                (0, o.default)(this, t), this.config = this.set(e), this.map = {}, this.domControl = {}
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.top = t.top || "10px", t.left = t.left || "10px", t.position = t.position || "absolute", t
                }
            }, {
                key: "callback",
                value: function (t) {
                    function e(t, e) {
                        var i = e;
                        e.domControl.showFloor.children[t].addEventListener("click", function (t) {
                            i.map.showFloor(t.target.innerHTML);
                            for (var e, r = 0; e = t.target.parentNode.childNodes[r++];) e.style.boxShadow = "none";
                            t.target.style.boxShadow = "0px 0px 5px 5px #efefef inset"
                        }, !1)
                    }
                    var i = this;
                    this.map = t;
                    for (var r = 0; r < this.map.dom.children.length; r++) "OvuRouteMapMenu" == this.map.dom.children[r].className && this.map.dom.removeChild(this.map.dom.children[r]);
                    this.addDom().domStyle(), this.map.floors.forEach(function (t) {
                        i.domControl.showFloor.appendChild(i.createFloorList(t))
                    });
                    for (var r = 0; r < this.map.loadedMap.length; r++)
                        for (var n = 0; n < this.map.floors.length; n++) this.map.loadedMap[r] == this.map.floors[n] && (this.domControl.showFloor.children[n].style.cursor = "pointer", e(n, this));
                    var o = this;
                    this.map.event.on("loadComplete", function (t) {
                        for (var i = 0; i < o.map.floors.length; i++) t.name == o.map.floors[i] && o.domControl.showFloor.contains(o.domControl.showFloor.children[i]) && (o.domControl.showFloor.children[i].style.cursor = "pointer", e(i, o))
                    });
                    var a = this.map.floors.findIndex(function (t) {
                        return t === i.map.config.get("defaultFloor")
                    }); - 1 === a ? this.domControl.showFloor.children[0].style.boxShadow = "0px 0px 5px 5px #efefef inset" : this.domControl.showFloor.children[a].style.boxShadow = "0px 0px 5px 5px #efefef inset", this.domClick()
                }
            }, {
                key: "createFloorList",
                value: function (t) {
                    var e = document.createElement("div");
                    return e.style.width = "100%", e.style.height = "43px", e.style.borderBottom = "1px solid #EFEFEF", e.style.borderTop = "1px solid #EFEFEF", e.style.lineHeight = "43px", e.style.textAlign = "center", e.style.cursor = "not-allowed", e.innerHTML = t, e
                }
            }, {
                key: "addDom",
                value: function () {
                    var t = void 0,
                        e = void 0,
                        i = void 0,
                        r = void 0,
                        n = void 0,
                        o = void 0,
                        a = void 0,
                        s = void 0,
                        l = void 0,
                        h = void 0,
                        c = void 0;
                    return t = this.createElement("div"), t.setAttribute("class", "OvuRouteMapMenu"), this.map.dom.appendChild(t), r = this.createElement("div"), n = this.createElement("div"), o = this.createElement("div"), e = this.createElement("div"), a = this.createElement("div"), i = this.createElement("div"), l = this.createElement("img"), s = this.createElement("img"), h = this.createElement("img"), c = this.createElement("img"), t.appendChild(r), t.appendChild(n), t.appendChild(o), t.appendChild(e), t.appendChild(a), r.appendChild(h), n.appendChild(c), o.appendChild(s), e.appendChild(i), a.appendChild(l), this.domControl = {
                        dom: t,
                        domChild: e,
                        showFloor: i,
                        allFloor: r,
                        oneFloor: n,
                        toTop: o,
                        toDown: a,
                        imgTop: s,
                        imgDown: l,
                        imgOne: h,
                        imgAll: c
                    }, this
                }
            }, {
                key: "createElement",
                value: function (t) {
                    return document.createElement(t)
                }
            }, {
                key: "domStyle",
                value: function () {
                    return this.domControl.dom.style.width = "45px", this.domControl.dom.style.borderTopRightRadius = "3px", this.domControl.dom.style.borderTopLeftRadius = "3px", this.domControl.dom.style.border = "1px solid #fdfdfd", this.domControl.dom.style.position = this.config.position, this.domControl.dom.style.top = this.config.top, this.domControl.dom.style.left = this.config.left, this.domControl.allFloor.style.height = "45px", this.domControl.allFloor.style.border = "none", this.domControl.allFloor.style.borderTopRightRadius = "3px", this.domControl.allFloor.style.borderTopLeftRadius = "3px", this.domControl.allFloor.style.backgroundColor = "#FFA500", this.domControl.imgOne.style.width = "100%", this.domControl.imgOne.style.height = "100%", this.domControl.imgOne.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAC4jAAAuIwF4pT92AAAP10lEQVR4nO3dC3BU1R0G8LuvbN5AgJAYDKPB1mAhJCCKGmg7044drVUIo2hRXlqpFIqoKBBjEhTBt1WpWhVtbX0EELBOndFKwAqCBFAb7AjajNIQhUCIee1md/sduelsFY557N5zH99vJrN3M5r7J7nf/u+5j3O9kUhEI6IT86ougMjMGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQIgkGBAiCQaESIIBIZJgQEygpqbGV1BQcIHL5ToXX/0ikcgHR44c2TBw4MBm1bU5HQOiUFNTU/+0tLT5hYWFv8Lb7K7vIyRaRkbGMQRlVXNz88r09PRGhWU6GgOiQFVVlWfSpElzsOGX423GSf6zdHwtQoCuDYfD5bt3715VVFQUNLBM0hgQwwWDwbMmT578FBbP6eb/koGO8hC6zHWdnZ2zvV7vtnjWR/+PATGI2+12YQOfjw18Od4m9uJHnOXxeP6B3a5HDh06tGTw4MFfxbpG+jYGxADHjh3LCIVCz2Lx4j7+KDe+5g0aNOgihO1qhO2dGJRHEgxInGGXaiTGEa9g8fQY/tg8dJPN6CbLd+3aVcGxSfwwIHGErlGCT/nVWEyJw4/34GspxiYXdnR0TPX7/fvisA7HY0DiQIw3EI5yvC7FW1ecVzc2ISFhZzgcnoP1/TnO63IcBiTG6uvrkxGO1VicYuBq010u1/PY5frJF198MXfIkCEtBq7b1hiQGGpra8vJyspaj8UxikqYnpmZOS4QCExBV6lVVIOtMCAx0tnZeXZiYqIYjJ+iuJQRPp9vO3a5fo1drucU12J5DEgMYGO83OPxPIPFJNW16FKwy/UsdrmKDxw4MG/o0KFtqguyKgakD6qrq70TJkxYjo1xoRb/wXhvzM7JyRnT0dEx2e/3f6q6GCtiQHqptbU1G+EQR41+qLqW71CI8ch7oVBoGrrca6qLsRoGpBewsV2YlJQkzoxnqq6lmzIwHtmIXa5lFRUV5WVlZWHVBVkFA9IDtbW1Cfn5+cuxsS3QzLlLJSMuU7kdipqamqb169fvqOqCrIAB6Sbsxw9HOF7Q1B3CjZWL09PT3w0EApfxUPB3Y0C6IRwOX4mN6fdYTFNdS4x8z+fzbcOu4gyMS9aoLsbMGBCJurq6xNzc3IdcLtd1qmuJgzTsKr4sLnjEuKSU45ITY0BOArtUpyEc4tO1UHUtcSTGUYvFuOTYsWNXYtfriOqCzIYBOQHsevwMu1R/0k5+O6zdXJiWlrYjGAxeil2vD1UXYyYMSJTy8nJ3aWnpUux6lGnHj/o4SZ7X692KD4drMC5Zq7oYs2BAdGKGEexq/FHr+11/VpaKD4cqjEsqeb7kOAZE+/quv1HY/xbjjeGqazEBMS4R50tGNzY2ThPTD6kuSCXHByQcDv8SuxaPYzFZdS0mc8mAAQO2BgKBSzEe+1h1Mao4NiD6WfH7XC7XXNW1mJi4dP5djEumYlzyuupiVHBkQMSNTQjHS1g8T3UtFjAA45K/otMuRqe9B68R1QUZyXEB6ezsnJiYmPgiFoeorsVCPOi0K9BJRtfX18/Ozs5uVV2QURwVEHz63YhdhRWaw/7dMTQ1KyvrzPb29svwIVOnuhgjOGJDERMp4A/7ND4FL1ddiw0U+v3+Hegm4i7Kt1QXE2+2D4i4sUmfSOFs1bXYyGCMS15HR74Jrw+rLiaebB2QYDBYkJSUtBGLp6quxYZ8YlLtSCQy9uDBg9fbdVxi24BgF+DnXq/3ec0+l6ib1TR06AL9vnfbze5ou4Dos6jfitdlmvOup1JlVEJCwg79Oq4NqouJJVsFJIazqFPP9ceH0ivi/pI1a9bcXlJSElJdUCzYJiAYbxSmpaWJ66lOU12Lg319f8nkyZPHt7S0TE1JSWlQXVBf2SIg4XB4OsYbj2nmmbjN6X6UnJxcg13dK/B32aK6mL6wdED27dvnz8vLe9Dlcl2vuhb6llMwHnkTH163IiQPWPUSFcsGpL29PRfheBmL41TXQiclDgXfh3Hh+UePHp3Zv3//JtUF9ZQlA4Jf+E/9fr84hDtIdS3ULZP69es3EuPEKT6fb4/qYnrCUgHRD+Euwesd2vEnLJF1nCFu6cWu1g34+z2jupjuskxAxC2x+iHcS1TXQr2WhF2upyORyAUHDhyYa4VZ5y0REN4Sazszc3JyCjs6OqZgV3m/6mJkTB8QtOSr0Jqf0HhLrN10zTo/3ePxrFddzMmYNiC8JdYRxNn3ddjlumfz5s1LJk6c2Km6oG8yZUB4S6yjiLPvt0yYMOHc1tbWK5KTk+tVFxTNdAHhLbGONSEpKalGnyBik+piupgmIPoh3IX45SzXTFQXGSoL28EbGHcuxbhzhRnOvptiQzx8+HAaPjme0ox9tjiZk5ggYjm2h/FNTU3XqH7Qj/KABAKB/IyMDHEIN191LWQql6Snp2/H9vGLhISEvaqKUBoQfEqU+Hy+pzXe9Ucndga2j7ex632xOAuvogBlARFTfuoPurfas/7IWBkYl/4tGAxOUHEdl5KAdHR0nK4/0ozhoO5IRwdZj7HqyIEDBzYbuWIlAUE47sVLiop1k2UNw1i1Aq8LjFyp4QERg3K0ykuNXi/ZwvXNzc3L0tLSDhu1QsMDgnDM0rhrRb2TmJKSMhmvTxi1QhW7WOwe1Gsul+vHml0D0t7efqrf788zcp1kO2cZuTJDA4Ldq7FGro9sKU9clmTUZSiGBgTt8Qwj10e2lCRm68drixErMzogWUauj+wpNTVVnCKwX0A0XlJCMYBdrASj1mV0QHh4l/oM44+AUesyOiCOfuY2xUYrpKQYcyGGoQGJRCL/wTjEyFWS/bQMHjz4K6NWZnRAPmJAqI8MfXiooQFpa2vbhtYojl8zJdRb7xu5MkMDkpqaeghdRNz4wtlKqFew/Wwyci/E8Gux8A98Fv9ABoR6I9je3r4+Odm4OQQND8hnn332XG5u7hIs5hq9brK8vyAcB41coeEBGTZsWHsoFJrjdrvF45n5kE3qrkZ0j8VJScY+REzJHYUej+e1cDg8F7ta9+NtoooayFJasL2UIBwHjF6xskkb0EFWBQKBap/Ptxpvz1ZVB5leLfY4rvZ6vTtVrFzptD8JCQm11dXV5xUXFy9GNxHjEsOusSHTExNZr9y/f3/F8OHDO1QVoXziOH1G74pgMLgenxLiATkFqmsi5T5E15iB7eE9hENpIcoD0kXMeVRbWzsuPz+/FG9v1UxUGxkmiK8V6BrLVHaNaKbaCEeMGCGu0izt7OzcgIG86CacjtQ5PtC7xk7VXSOaqQLSBb+kHXV1dUW5ubmVeHujxsPBdia6xvK9e/feqX9AmoopAyKI8yV4uRndZD26iXgqqnk+VihW9uDvOwO717sQDtW1nJBpA9IF3eTthoaG0ZmZmXfj7Q0aL3S0A9E17kLXuMuMXSOa6QMiDBkyRNx//Bvso65zu91iNvhhqmuiXtutd43dZu0a0SwRkC7Y1fp7Y2PjqAEDBogz8LNU10M9EohEInfu3r17eVFRUVB1Md1lqYAIGRkZ4rbd2egmr6CbPIllzpRifjV613gf4VBdS49YLiBd0E1ebW5u/kFqauqjeHu56nrohDrQNZaha6ywUteIZtmACPos31egm7yIbiKCkq26JvqfnXrX+MBqXSOapQPSBd1kXVNT01vp6en3aMfHJjzSpY7oGhVbtmxZqV9GZGm2CIigPw31WnSTF9BNHscyJ8k23nZ0jZnoGv9EOFTXEhO2CUgXdJM3GxoaCjIzM8XTiOaLb6muyQHa0TXK0TXutUPXiGa7gAj6eZOF+DR7CYER503Mf8DdurYHg8EZ4tYFu3SNaLYMSBev1/tuXV3dGF7TFReia5StXbv2vpKSkpDqYuLF1gERoq7p2ohushrLpykuyQ62omvMRNf4COFQXUtc2T4gXdBNNn/55ZejBg0atAJv52g80tUbbegat6NrPGDnrhHNMQER9DldbwiFQlVut/sPWD5ddU0W8o7eNf5l964RzVEB6YJdrbcaGhpGZWZm3oW3czWOTWRE11haWVn5YFlZWVh1MUZzZEAE/UjXfIxNqvQjXbzf5Nve1rvGxwiH6lqUcGxAumBssqW+vr4gKyvrTrydp7GbCK3oGkvQNR52YteI5viACNnZ2a14WYBu8rLeTb6vuiaFtqBrzHJy14jGgERBN3nn888/L8zJyRFn4RdozjoL34KusRhd4xGnd41oDMg3DB06tE07ft5krd5NzlRdkwGqA4HALL/fv59d4/8xICeBbrK1rq6uMDc3V2wxN2n2/F19ha5xG7rGY+waJ2bHP3rM6Gfhb0M3WafPrGKna7o26V3jE3aNk2NAugHdZPu+ffuK8vLybsfbWzRr/95E11iEf9OqcDgcUV2M2Vn5D20ofSrMJfrYRHSTkapr6oU30TVmo2v8G+FQXYslMCA9JKbGrK2tHZufny9mo78NXz7VNXVDM7rGLaj9cXaNnmFAekGf7KwsGAyuw0Ynuslo1TVJvIGucS27Ru8wIH0gJj+rqakZV1hY2NVNzPR8k2PoGjcjwE+ya/QeA9JH+nQ2d6CbrMXGKM6bjFFdk3b8vMYMdI1P2TX6hgGJETEpGrrJ+NGjRy9yuVxL8S2/gjLEXX6llZWV9/O8RmwwIDGkd5Nl+tOyRDcZa+DqxUzpV4kZRXheI3YYkDgQk6VVV1ePLy4uvgndRGyt8XySr+gUD+7fv3+xWZ7KZCcMSJzo09/cjbHABgRGdJNz4rAaMcaY6fF4NpnpqUx2woDEmZgOp6qq6vxJkyYtRDcp12LTTcRRqVWHDh1apN9GTHHCgBhAn+BgJbrJer2bnNeHH7cnFArNE5NQIBwxqpBOhgExkJjwoLy8vLi0tPS36CbL8K2kHvzvjfo8VKucMqOIGTAgBtMPv96PbrIR3eQpLBd/x/9Sj2A8evTo0d+JZ6M4aUYRM2BAFBG3tLrd7onBYPAivE7Ht8bjawi+xA1bn+BrGwbgG/fs2fO6OHyMcKgs17EYEIX0S0Be1b80BMUVfVmIx+PRrPxsDTtgQEyE10yZDwNCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRBANCJMGAEEkwIEQSDAiRxH8BLR35Ma6ESecAAAAASUVORK5CYII=", this.domControl.oneFloor.style.height = "45px", this.domControl.oneFloor.style.border = "none", this.domControl.oneFloor.style.borderTopRightRadius = "3px", this.domControl.oneFloor.style.borderTopLeftRadius = "3px", this.domControl.oneFloor.style.backgroundColor = "#FFA500", this.domControl.imgAll.style.width = "100%", this.domControl.imgAll.style.height = "100%", this.domControl.imgAll.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAC4jAAAuIwF4pT92AAAeeUlEQVR4nO2dCXgV1dnHJyHLzUYIkBACiTahmmBbwKW1FQK2Vq31E0nUuqEoiIKoyBbAkBCJLGENO1IVoRTFGLSldrNUiLXW1nzUUoptDE3JFxpjQhKyr9//Tc7YSMNkmXPnzL33/T3PPHMvmjPvnZn/Oec95z3v8Wlvb9cYhukeH9UGMIydYYEwjAEsEIYxgAXCMAawQBjGABYIwxjAAmEYA1ggDGMAC4RhDGCBMIwBLBCGMYAFwjAGsEAYxgAWCMMYwAJhGANYIAxjAAuEYQxggTCMASwQhjGABcIwBrBAGMYAFgjDGMACYRgDWCAMYwALhGEMYIEwjAEsEIYxgAXCMAawQBjGABYIwxjAAlFMXV1dpMPhuN7Ly+tKfB2Jo629vf3Pra2tb/v6+uarts/TYYEooLi4OCAqKuoeiOKhgICA6/BPXl3/O/79Xh8fHw1CKcDxclNT08sQ0RlF5no0LBALqa+vH4kX/akRI0Y8hK9DevEnoyCWFf7+/sshlMNtbW2bBgwY8I6TzWS6wAKxACGMFByP4Kt/P4oYgGOyt7f3ZOp+4cjKzc199Y477miVbCpzASwQJ3L+/PkhwcHBSyGMx7X+CaM7xqBV2Z+cnJyBFmXNqVOn9o4ePbpJUtnMBbBAnEBRUZEjOjr6SYhjCb4OctJlqPu1OyEhIQ1CWVdSUrJ75MiR9U66lsfCApEIukBeLS0td8bExKzB10stumw0hJINv2YphLK+tLR02/Dhw+ssurbbwwKRBIRxTWtr60Z8vE6RCcMglKzIyMh5EMqqwsLCXaNGjWpUZIvbwAIxSUNDQ4y/v/9zAwYMuE+7YLhWEZHUosTFxZFQns3Ly9s7ceLEFtVGuSoskH5SW1sbERgYuATimKXJc8BlcgmE8kJiYmIKhJK+YsWKg+np6W2qjXI1WCB9hGa+AwIC5kMcJIwg1fb0gssglANpaWmL0QVMRUt3WLVBrgQLpJfU19ePcDgciyAOmssIUG1PPxjj7e390/b29mMQSoqPj8/7qg1yBVggPSCEsRjHDHx1qLZHAoloRd6DUA41Nzc/4+fnd0q1QXaGBXIR4GMMIx8DwpipuWaLYQQNJiT5+vreBqHsaWhoWI6W8f9UG2VHWCAXUFlZGQoWQBxz8TVYtT1Ohp7/DFQC90Io2VVVVWsGDRpUpdooO8ECEYjZ7zkQx2Ktd4GE7kQgjiX47TPb2tpWFhYWbuM5lE48XiBHjx71mTBhwrSYmJh0rXM9hiczxMvLa31cXNwcCCUVjvwBnNtVG6USjxUIhYXASU1OTEzMxNfLVdtjM75EAZGtra1P04gXnPojqg1ShUcKBA/9RhzP4ePVqm2xOVejIvkN/JO3WlpaFsOp/4tqg6zGowSCh3wtasOVeOjXq7bFxbgF3a2baHVjQ0NDekBAQLFqg6zCIwTS1NQUj9pvFcQxWbNHvJQrQou2HnY4HPdAKBurqqqyPGHEy60FUl1dHRYSErIc4qCwEF/V9rgJNCe0VIx4ZRYWFu505xEvtxSIGJmaAXGswNehqu1xU4bCkd8UFxf3NISyPDc3d587LgF2K4GIkakpYmQqQbU9HgJFDb+UnJyc0traugyt9evuNDTsNgLBw7lZjExdqdoWDyUeFdRreAYf4kiDv/eWaoNk4PICaWlp+ZYYmZqo2hamg6vwLH4GRz6Pwut9fHyOqTbIDC4rEHSlvoabTyv5blVtC9MtE/BsjkIov6KuF57VB6oN6g8uJ5DGxsY4Pz+/5bjh9+Krt2p7mB65EUL5LoTyJlp78lFOqDaoL7iMQOrr66McDscyiGO6xkO2rgbNPd2OSo3C619B678cz/Efqo3qDbYXiJjLWARxPKl1Rp0yrgu1+PeiFbmL1qGgN/Cs3XMO21YgpaWlQeHh4U9DHAvwNVS1PYxUOtah+Pv7T4VQdqF3sCowMPDfqo3qDtsJ5OTJk37x8fEzIyIinsHXSNX2ME6FssE8GRAQMANC2Xz+/Pm1AwcOrFBtVFdsI5CcnJwBSUlJUxMSEmhdxqWq7WEshbrOi9FbmNXW1rbh3LlzG4cMGXJetVGEcoGI2e/JycnJNPt9hWp7GKWEenl5ZQwePPgJSsx95syZrZdcckmDSoOUCqS1tfV6HCvx8VqVdjC2g+K81sbExDwJoSxEJfqqKkOUCKSsrCx46NChL+OHJ6m4PuMyUGLuV+Cf3FlVVTVdRXi95QLJz8/3HTdu3E/xcZLV12ZcluTQ0NCYioqKG9D9qrbywpYLBOIgJ3yS1ddlXJ5rwsLCNuM8zcqLWioQMRu+wMprMm7F1MbGRtqz8ROrLmipQPDDaPNKO2ZCZ1wDb19f31tw3mLVBS0VCByum628HuN+4B0aa+X1rPZBeJ6DMYulS6itFkiYxddj3A8/Ky9mtUBqNdfYdIaxL5aGoFgtENqL4iqLr8m4F6etvJjVAvm5xgJhTNDW1vbegAEDLLuepQJpaGjY6XA45mvutyENYw2fnj59+hejRo2y7IKWCoR2MUINkOLl5bXZyusy7kF7e/tCq7M4Wh5q4u3tvQU/lIbqlmmcJ5fpHXhl2tPw7uy1+sJKonnRgqQ3Nze/7uPjQ92tezROwsBcnD+g17EEfsdvVVxc2XoQX1/fj3B6EH7JMn9//6fwmbZXDlFlD2MrKMfvm62tretRiVrqlF+I8hWFcNr/hdP8qqqqFSEhIY+hdaHsJcNV28UogebJXmpqaspGpVkAcai2R71AdEJDQytxWl1QULAxNjb2PgiFul+jVdvFWMJZ+Bhba2pqdlLSBohDtT2fYxuB6IhRihfhkL0EP+X7OC/E90TVdjFO4SPajKewsPAAPXeIQ7U9/4XtBKIjUugfpqOlpeXr6IeSUKZonTsdMa4LPddf4vluhB/6a3rOVs5r9BXbCqQrIvHxnY2NjaP8/Pzm4fODGmdZdDWoZ7AflR0J4wQ53hCHapt6xCUEokOOG06za2trlwcGBj6Oz3QMUWwWY8xnOHbW19dvxzM7C3GotqdPuJRAdIKCgj7FKb20tDQrPDz8ITHy9WXVdjFf4B/wLzbhGe0ZPnx4HcSh2p5+4ZIC0Rk2bBgNC27NyMjYnpqaehsceppPmaTYLE/nGPkXmZmZP0lPT2+DOFTbYwqXFogOPQic3qCjubl5LHwWEgrN0NtnvNC9acGRKyb2PiD/As9EtU1ScAuBdAV93OM4PQQ/ZXFAQABNPM7G9wjVdrkplKPqh42NjZsdDkeRHSb2ZON+v0gAP6UUp4yzZ8+uRVdsGoRCo19xqu1yE4rhX2yprq7eRdkOIQ7V9jgNtxWIDjmIOG3PycnZlZSUlCyE8g3VdrkoH0IYG44fP/7alVde2QxxqLbH6bi9QHTEJvcH6RA741Ioy2SNJx57gvy7w+R44569gwpGgzhU22QZHiOQrlCEKE7voe8c6+fnRw79wziCFZtlN+px7Gtubt6Ie3RKZUStSjxSIDr+/v6FOD2FvvTy4ODgR1E7zsH3EartUsyn6EZtq6ur24F7UgZxqLZHKZYJBN2ab7S2tn5mZV7V3jJw4MBzOK0+efLkhvj4+LshlKfx3dIMfjbgbzSxd+bMmb20aQ3Eodqebqmvrx/h6+sbhV7AH624nmUC8fb2vg7NdBYewusQylr8wD9Zde3eMnr06CacaFnnXtj4bdhMfsr3NPdeGnwE/sV6vHQ/p8BBiEO1Pd1SW1sbERgYmOJwOGbjHUrFP7mXQAC9fNSRvQtCoW2A36ZttvD5bQtt6DWw6whOR5qamhLw8szF5wdwuMt4ZjOOV0XgYL6dAwfR/R0cEhIyH+KgcCK9WbMscYOVArlwd6AbUEPfAKHk41ibm5v7mhhpshXog/8Np0dRgy3DQ6JJx1ma60480qK05xsaGrYEBAQU2zlwsKamJjwoKGgexEEBqRcuxbZsEx3LBAIRfEZDhN1wJf79AG3iiVpsHfrAe1Rv3NgdIkByeVFR0ero6OgHYDO1Kgmq7eolp8m/KC8vfzE8PLwG4lBtz0Wpq6sbDvsW4H4/ql0kTS1+S5lV9lgmEPTpT6PFMPpf4vDS7YiJicmAULagBtkmnGdbIcT7PH7L7ubm5u8JP+Xbqu26CH+giT20zq9T6wxxqLbnoogh94UQxzSth64s3qUiq4adLRPIiRMnPhk3bhz1HXsKIIyAUCiBwyI83F3oDmyihHNW2NgXxIrHt+gQAZI08nW3ZnH28W7omNjDS5QFm35HrTbEodiki4N79xXYmQJx0L3rzfvYgHfpH1ZNVlomEApNwAv/Lj5+p5d/Qv3OBQ6H40n83Y9xI9fiJp50oon9RgRIPlhfX78U9tJcCnUPrN7qgRzv/fp9snvgYEtLy3i0Aimw8/ta30YJ36d3yVl2XYildxEveg5qtN4KRIdq5Gl4CR/A3/9E1Iy/d4Z9ZhEt3ZKysrLnhgwZ8jB+K83Sxzr5shRrRhG16yDOM3ae2MvIyPAW63YWQRzf7E8Z4h2SbdpFsVQgeHH2RURELMfHYf34c3JgbseNvZ1aIhoihmh+Jro6toIcYZw25+TkbJsyZcpk4ad8S/JlaCnr9tra2q00423niNqioiIHDWykpaVRNzTeRFGfnjt3bi8qH1mm9YilAqEVgGgBZuOFydHMTb6NRxnjUdZfaeTr+PHj+61sdnuLGLbOpYMiCSBuiiRO1swFSB5HBbGjpKRk38iRI+vtOuNN1NTUDKWh8ZiYGBoe70+l2JV2POvHIQ633kCHJuByRYb3NZr5GeorUM5LcP6fRZkbysvLfyhqb9uBbuEfcPoBukJfQjeIJr2ma71PtUrzF7RibzfKeZ+6GBCH02w1i8g+83RQUNA0TU72GUpeTd2yHAll9Qklnhxq/7V4oYvxoHfiq4xsYdEoa+PQoUOX4UZSt2MzdTsklCsdf39/2iHp6aqqqoyQkJAHYXeS1rmpUNcxf5pU/SuO93Gffvnxxx+/Q2EwLuB4dywjgDhu1zq7xDL4DPdgJso9JKm8PqHsjkMkB+rr6/PQd96odXY7ZHheg3Gk0gwshPJiU1PTBvFC2g6RajWbDnJe58+fPxgvgQM214j/1gGN90Mc6gztAfhZA/SFaLBV5kI0Ck16Ht205ahIyiWW2yeUVkkU7oDTnah5rsbNfQafb9Pk1DzUrM9BTTYLQnkN5WfBof9fCeU6BZF0gpxuzc6z3F05e/ZsIC1lTk5OJsdbZmrECq0zHGYrjQpCHBKL7ju2aLNFZO8U1J7xeJGf0DoDA2V4n+QM343yfwChULrLtSIIkeknIqp2TmRkJDneMoeTaPBhF/zIH9kpHMYWAtGhlWs4PY7++TOoOSjRAk24mRkW1KHu283o1t2Mh/BHCCUrMzMzV9TcTC9A5fVlVF7zII5pmryoZoqseKW1tXWnPvhgt3AYWwlER/TBN+GFzm5ubv4OzhRBS90vGfZeg/JeS0tL+zutg9AXCEko1y0RicNTIA6Zjjf5FDv0dKR2Hnywr2Xa5/FOtF7kbVpJBof+Ma0zjENGNXMZaqxdIjgyu7q6egelsJFQrluAWp2WI6RAHDdILNbl0pHaWiBdEWEcywoKCjJjY2PvEfl4x0koOhJlrUKrtVgER2bjWiUSynU5uoSCLMYhc0TKZdORuoxAdMQGO3voQPOfiBqOnHpq/s3+llAci9BKPQWhUDaPdfCJPjZZpktw9OhRnwkTJtyNbmcKvn5FUrFukY7U5QTSFdz4Yzgda2xsvJRmbrXO2eluF9n0AQrHn4E+98MiOHINOZCmjbUhIkZqWmJiIm1OJCuokkJBdrtLOlLXtl7g7+//T60zfU9GcHDwbJG+x2zsT9fgyHdoiFhPbGDWXtWUl5eHhIWFzYL/RZVKpKRiO9KRnj9//nkaZLFz8GRfcAuB6NAGkDhlomZcRzWj2AhUxiTWJPTJJ6E1+YiEkpeX98rEiRNbJJRrKRQ8GBQU9MTgwYOpWyprvQrlFFivpyOFOCQVaw/cSiA6Yth2Z05Ozu4pgNYf4Ps1Eor+GkS3D12SFeR0lpWVvSD2KLE1ehcU4pDRBSVo/ugtkY70iDunI3VLgeiIcHOKAM1B7T9JCOVmzXzc16V4KbIjIiLSaPtisSbjM9MGS6a5ufmr8AEW9WE5a09QxbPXk9KRurVAukKJl3F6R7w0CzQ568cp1CIdNfMCCOWFpqamjcIfUooY3VvYj+WsF4Myuuyoq6vbTtld7LxqUTYeIxAdONp/0TrXjz9DQ7r4PFMzH3JP3ZYn8eJQ1r9X8IKSQ/+RaWP7QJeo2vkQx9clFXuK9jHXF2dBHJKKdR08TiA6IpJ4YWVlZSac+0fFxKPZxNV0P+9HzX0fXqyfi+DId0wba4CIqn1YRNXKGqo9Iib23qKJPTsvznI2lgmkuLg4gGohq67XW0R4SVZBQUF2bGzsvWLk6wqTxVK35hb4PLdAKLToaY0+i2ze4k7Q3YmEyGdLjKqlJcu0NGC9no7UrhN7VCmIjZGcjmUCiYqKorUZN8FZfk5M8NkKMUP/El7qPZITwl2Lsg6lpaV9TOvnCwsL94lr9QuxduYpiOMuTU4OLvIvKCvKTsqKYtd0pLiHXngu38V5IVrMX+Cf1ltxXSu7WPRS3IiHeyOEQrE5q/D5FxZev1dckBBuDMRMiRZox1yzb87laJ12x8XF6cGRu3obHClCQZLw90/gno03aYfOnynrIgT7KgnWrhN7wre6ExUrjUDqsXdvWHV9KwXSNRtFImqCRDygD/GyrET34w07rs1Abfpn7T8OPU2uUSSx2ZmwKEpYERoaupSyk6Ds7MDAwH939z+KCOZHEhMTZ2hyNvYh8f9aRAX8hioDiENCsfKhLjl6HQ/Bt+pu89UKq+ywMnl1STcJv66CUF5H94PS96zMzc191Y4Z3oVDn1JRUfEcan1KCEdiMesQk9Boq+q5uDc0t7Dez8/v71VVVYNCQkJuxTXugzi+q8nZQ5Eqnxx0z1bT0mObb3cQFhwc/PiIESPoHnebRR/366xV9liZvLrIIHk1pe/Zj9qC0vdknTp1ao/YzMZWDB48mNLub0Kzv0UkhKORI7NdHurbzMSLOwMP/u8DBw6k2lKWI0DhMAcgvpU0sWdX/4JoaGiI9vf3n4vK4RGth3RITU1NBVYtybVMIKtWrfoELQX1uY26KJThfVdCQsIy6gaUlpb+0KrRir5wQUK4q1Aj01YIZp1mqj1kLC8myN/bixdpNe3DaOeJPdg4GsJdCDvv03pXMZSJFt0SLBMI+RioIX+Hj7f04n8fSaEckZGRqRDKpsrKyq2i9rYdcOI/xGkq/IWO7cG0zolHVQuraanyLuHXnMVLp8iMnhHJqxdCHLdqfVvK+66zbOoOq5NXH8SL3xuB6ITj/38uLCxsIf52c01NzWaVOZKMEKsQU4uKijKjo6Pvgt20M5KsGe2eKKL7c+7cud2UmtOuS1nFisVbaai2v6Nx+J1vum3y6pKSkoNwvlbiY1Qf/3QQjjQ4b/NpWSxqyHVUQzrBRNOISOKOjUBFwgMSyg+0nvdF6Q+UxDv73XfffYPC761M6twX8vPzfceOHXsfuti0MMtMFryKsrKynGHDzC716T2WCoRm0vFAF6MG2NvPIigYaB7NIEMoNLmVRZNbMm2UCS01xekDtHwLIOhH8Lup+2V2G1kKrz8A8W3XR6QgDvPGOgGxMOuRcePGkY8WbbY8PPOVVi8vsDwWC83rPvzQ67TOOYX+QiM/c9DHnomy9sDRy7Lj/us6Ik/wSnQxVqOLQdlCaKRmsta30SpKrPZCdXX1PppgtPOIlEguRwuzqPWUtTDr13l5edlWVwZKghWfffbZ2WhuqSvylMmiaHhmpp+f33QXSjH6KzrE1gB3o1W5X+v0VbrrWNNoDW3X/DJFIVPfG+Kw0uQ+gRY9Ds+Ckss9hK+yxmH/TUt50RptVrGKU4lAxIsyF90t2kNvs2Z+XfSFKUaz0PX4rXlLnYdYYLWVDpoDwItFk4NX43sgfsNx/Ia38W/5NNtt59aCaG5uHicWZt2pyZnYJDpC7fXEfqoyLioNd6cMhxUVFb9EP5XibGjm1Oy6jK4pRr+wVtq8tc5D+FE79O/UUtCkql1nu3VEcjlamEUz/rKGlihOb31mZuZhqkghDknF9g/l60HE/EYq+tbrUavSugyaSzDt0Gmd+6/vh4O4hraV1rNtSCjXo6HgQbHOPwXH1ZKKpYnXNyG4tZRiyU6h9soFoiP2RF999OjRdePHj6exckozSjWT2XywNOm4BuUvE3uGZNPssnmLPQs9h1ZycrKsTDEERUnsEUuVC+yYQ8t2FglHjMKZ3xCby9OIz8PaRQLX+gBtp0DLYh+nySbUVhvxQCydlXVFRPDkYzExMTSgIiuHFvlf2/RkF3ae8bedQLoiavolJ0+eTI+Pj08Ss9NmgwPJiUxCM54EofyJHEFX8FOsRoTaz6XlyFrv91LsiQK633ryajtvQKpja4HoiMjeV+gQs9MURXuHZt7+q4Wfshp+ylb2UzqCBxN8fX0XQBwUPCiraqdlx2sPHTr0JgV6cvJqJyJmp+9paGhYjBaGEi3QYiKzo1/Rnu6noOK5VuwDImsbPBqCOyySVx8jxxvikFCstbicQHQoMTJO8ysqKjIGDRpE+Xhl9JG7+imHhJ/ynnlr7YlY5/19ETyYKKlYCrXfJxaAnbKj490XXNt67fNh4tXFxcXZUVFR00VWkktNFkt+yh14ae4QWUnWZWZmHrLjsuD+oG93INZ5f1VSsbQMdid8ly20hNjOa1D6gssLREekFNqKh7+THj6EIuvhU1aSnLS0tAKxZdseV92yDc5xUHh4OK1xJx8uRlKx/yTHu7y8/EXafNOuofb9xW0EoiOGiX+El3q/6D7QpjAyMoGMguh2xMTEpEMom6urq7e7ypZtIqv7nIiICNoWQlZMfEekQl5e3kG653bbfFMWbicQHZG+5zAdcEC/SQ4oPv+PZt4BpS3bVoaGhi6y+yIukdV9PsRB80gyqna6p5Qxcr2e1d2uofaycFuBdAWO4u9xul2sfyYfRcYQpr6Iax6Esr2urm4DXsRS08ZKAC3n1/CbF0rM6t4xzI6KZh1FFXtCVncdjxCIDl6YkzhNx8ucGhAQQEPEFM5iNn6cRr4W0foHsdoxS9VqR7HFQwrEcZMmJ3iQupC0selm2kTV7lHFzsCjBKIjXuAlcCxX0oo3dBVkrHij9Q9z8SI9JlY7rnU4HP8yb60xYp337bT3icSdaWk7tezKysrnaZTQqhQ7dsQjBaJDCQ5w2pCfn79l7NixtLU0ZfEbY7JYfbXjo3jJaKBgrWi5pFJQUOAfGxs7NS0tjfY6uVxSsR+JJQIHKPQG4pBUrOvi0QLREXFYe2k5sEiQTH6K2TUO1B+Zhm7JAzJ3y0WtHjpw4MBZcXFx1EWUFbNxRKQjpcVm7e66nVp/YIF0QYx8dSyJhVC+ghea5gvMOvRdd8s9Snm++rMVAvym4eQ3hYaGztLM5wcmaDj8YNftDuy+QEsFLJCLgJfmhPYfh57mD8ihN9vnmIjWaSK6RZ9QcGRNTc1esTPvRWlqarqMMg/ChqmanODBGq1zu4NNFK7jiY53X2CB9IBw6J8pKytbBZ9lmkhcfZnJYinF6saQkJBVaFVyIJYX0Koc69qqoGa/BrX6IrzASZqc4MGztOEoRLmDFqfZdbsDu8EC6SUURoHT1oyMjO2pqam0exQFR35HM+en0Ft6P8q6H61KCV7gt3CcgHioSzZJht3gJDnehYWF+2kfEIhDUrGeAQukj4havmOGXvgpJBTyU8yOhVK2yRkS02p+IfmBXfcBsTssEBMIP+URdFuWoitGCSfIT5Gx0U1/oeQHh0Tygw/slPzAVWGBSEBkTszMz89fM2bMGNo3hEaartfkpcLpCdsnP3BV+E5KRMyn5NCB7tcVeFGpRXlAM7/i8WJ8Cv9iW11d3Xa7Jz9wVVggTgLdr7/i9ER5efnSsLCwqaL7JWtx0mnagLOkpOQFWgfjCskPXBUWiJMR4Szb6RAJJ6Zrnbvm9idTCO1Muzo3N/c1Sn4AcUi1lflvWCAWom+HUFpaOi88PHwyWhUSyo2a8dZtNGrWMQOPVumnNNvviskPXBUWiALEHhc/pkPEVt0EsXxT64woJj+mBi0F7Rp1qrGx8V1a482hIGpggShGLNs9KI7P0edD3G2Nt6vBAmEYA1ggDGMAC4RhDGCBMIwBLBCGMYAFwjAGsEAYxgAWCMMYwAJhGANYIAxjAAuEYQxggTCMASwQhjGABcIwBrBAGMYAFgjDGMACYRgDWCAMYwALhGEMYIEwjAEsEIYxgAXCMAawQBjGABYIwxjAAmEYA1ggDGMAC4RhDGCBMIwBLBCGMYAFwjAG/D/fmt4J4JLltAAAAABJRU5ErkJggg==", this.domControl.toTop.style.height = "30px", this.domControl.toTop.style.cursor = "not-allowed", this.domControl.toTop.style.backgroundColor = "#ffffff", this.domControl.imgTop.style.width = "100%", this.domControl.imgTop.style.height = "100%", this.domControl.imgTop.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAANpElEQVR4Xu2de8h32RTHP2Mkg3IpoijKiDQK5TZuueR+aShyGxm3GZeGKJQxDCGEMOM6uV9qXCeGMO63P1BMmaJoKBrlMiHk1tf707yeeZ/nt9d6zvnts87+rn/eP969zt77u/bnOb9zzt5rHYfNCliBfRU4ztpYASuwvwIGxKvDChyggAHx8rACBsRrwArkFPAdJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByutlrEAUMyCCB9jRzChiQnG72GkQBAzJIoD3NnAIGJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByutlrEAUMyCCB9jRzChiQnG72GkQBAzJIoD3NnAIGJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByutlrEAUMyCCB9jRzChiQnG72GkQBAzJIoD3NnAIGJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByutlrEAUMyCCB9jRzChiQnG72GkQBAzJIoD3NnAIGJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByutlrEAUMyCCB9jRzChiQnG72GkQBAzJIoD3NnAIGJKebvQZRwIAMEmhPM6eAAcnpZq9BFDAggwTa08wpYEByus3ldTPgDsBNgBsAlwO/BL4DXDFXp77u/goYkP6r4wTgOcBjgdsfMJyLgA8AH+k/5HFGYED6xvrJwGuBGwWGcRlwJvDJgI+bJhUwIEnhDul2NeDtwNOS1/k38OINXMlL2K1FAQPSotL0bS4EHjrBZc8HTpvgOr7EPgoYkN0ujasDnwYePGG3HwKeBPxrwmv6UhsFDMjulsLxwAXAI2fo0pDMIKouaUBmEnbPZfXM8WHgMTN2J0ieCOj5xDaRAgZkIiEPuIw0ft9m8c7dm55JnmpIppPZgEyn5X5Xeuch3lZlRmdIMqr5IX1C1dov9Qbg+e3N/9tSX89fA1wK3Bk4PfidRNc4Dzgj2K+bH0MB30HmWxavAF4avPwlwH2A3x7ldz3gy5stKJHLnQs8K+LgtldVwIDMsypeALwueOmfAifvgeN/l7gu8A3gpOA1fScJCra3uQE5pIDHcH828JbgZX++gePXB/hp8+JXDUlQ2UM2NyCHFHCPu7aO6KE8YtqtqzuH/t1mWUjeBDxv28X9//6JNeca0DcIvc6N/NHRHUNw6A7SaoLkW8CtWx027QxJUDA1jwQzcflhXPQBUB8C9UGw1fQgLjj07BG1GwJfNyRR2eLtDUhcs70e2jqiLSTaStJqvwPuDvyk1eEY7bKQ6BWydgLbGhQwIA0iHdBEmw61+VCbEFvtj8A9gR+1OhzQTpB8G7hl8FqGpFEwA9Io1DGa3Q/4LHCNwCX+BNwb+H7AZ1vTG29eARuSbUol/t+AJETb3AG+AFwz4P4X4L7AdwM+rU2zkJwNvLy1kxHbGZB41O+4eUC+VsD1r8ADNn4Bt1BTQaLkDjcPeR15HtFPLtsxFDAgsWVxu80i15ftVvs78BDgS60Oh2h3083PLUNyCBGPdjUg7ULeBvjmJh1Pq9c/gEcAn2t1mKBdFhJ9SNS3EttRChiQtuVw4ubjnN4atdo/gUcDn2p1mLCdINHPLf0bMUOyRy0Dsn353GIDh5K5tZrOhz8O+Firwwzt9DNLGxwNySHENSAHi6dMh9rWoX9bTUdeT90keWv1matdFhKdJdFO4OHNgOy/BHTHEBy6g0Ts6cC7Ig4ztxUk+rmlt1wRMyTei7XvetGzhuDQs0fElEL0rRGHHbXVR0T93DIkQcF9B7mqYNotq7dVemsVsRcCr4847LhtFhIlptM59yHNgPx/2PV9Q7tk9b0jYmcB50QcOrUVJNq7FXkbp2cqZUoZEhIDcuVKvc7mxJ6+lEdMdw3dPaqYzpHoj4AhaYiYATkikvZUfQW4S4NmRzfR84aeO6qZIWmMmAE5shtXu3K1OzdielOlN1ZVTZDoRYSeuVpNP7d0clJZHIew0QHJJpNWIRt966ie5lNZUpQIIgKJPoIqWfYQkIwMSDaZtL6O6yv5WrKpG5ID7oWjApJNJq19VdpfpX1WazJBou8kkV3K+gOhs/g6brxaGxGQbDJp7cjVzlzt0F2jqXjoxUFI9IdCtRVXC8mIgGSSSessh8506GzHms2Q7InuaIAo46EyH0ZM3wx0GlCnAkcwQfI1QN+FWk13klOAz7Q6VGk3EiDKlaucuRHT+XGdI9d58pFMWeV114xAop+ej1obJKMAoizryrYeMWUeUQYSZSIZ0QzJILt5M5nWlbNKuauUw2pkEyR6cI8kqNCd5GHA59cg3NrvIJlk0sp2qKyHyn5oO6KFUhxFINHLDL3xKw/JmgHJJJM+qEbHyLAMC8laAckkk26p0TE6JF8MJssrfydZIyCZZNKRGh0jQ6LycNrYGckoKUgetHmWKafd2gDJJJPO1OgoF+gJB5yBRN+Q9KFVD/ylbE2AZJJJH6ZGR6lATzxYQXJRMHF3SUjWAoheyUaTSU9Ro2PidVfqcg/clH6IZLcXJPffnPkvMdk1AKJTgCqTHHkNOWWNjhKBnmmQGUi0K0Fbd5QYY/FWHRCdH9eBn8iWCMGh7SNT1uhYfKBnHOCqIakMSCbT+hwFbGZce2UuLUguDFba0p1EzzLfW/IsqwKSybQ+ZwGbJcd4V2N7OPDxICT6g6WXK4uFpCIgSgUqQSNpa3ZRwGZXC3HJ/awOkmqAZJJJ77KAzZIX767GJkg+Eaz6qzvJvYAf7GqQrf1UAiSTTLpHAZtW7dfcTuf2PxqERC9P9EyyKEiqAJJJJt2zgM2aF3/r3FYBSQVAMsmkl1DApnUhrbmdIFGaJGWRabVF3UmWDkgmmfSSCti0Loo1t3s88P4EJPcAftxbmCUDkk0mvbQCNr1jvIT+M5BoK5COPHeFZKmAaNuIto9Ek0kvtYDNEhZp7zEIEqVsjay57pBEBrsrgXXWQBsPtQExYksvYBOZy1rbPgV4dwKSk4FLe4iyNECymdZfCShziW35CmQg0bEE/cHcOSRLAiSbab1aAZvlL+H5RyhI3hPspgskSwFErwG1j0fHZSNWtYBNZI5rbXs6cG5wcoLkbsDPgn7p5ksAJJtMunoBm3TQVuSYgeQ3gF4B7wSSJQCSSSa9lgI2K1rr6aksGpLegGSSSa+tgE16Za3I8UzgjcH56E5yV+AXQb9Q856AZJJJr7WATShoK22cgeRXm59bs0HSC5CzgZcFA732AjZBOVbZfHGQ9AAkk0x6lAI2q1z1wUm9CHh10Ge2O8muAVHxGj13RGy0AjYRbdbaNguJnkkEy2S2S0AymdZHLWAzWYALXyjzM1zPInoFPBkkuwIkk2l99AI2hdf2ZEPXTy3dTSI2KSS7ACSTad0FbCJLYt1ts5Do55ZeBR/K5gZEyaRV2PH4wChdwCYg1iBN9Y1Eb7gipi/t+rl1KEjmBCSTTNoFbCJLYKy2XSCZC5BMMmkXsBlrwWdmm4VEGxy10TFscwCSSSbtAjbh0A3roB3A2r8VMZ0j0R/tMCRTA5JJJu0CNpFQu60U2BkkUwKSSSbtAjZe8FkFspDo+G5zBeOpALkVoI961w/M9veb294lAR83tQJHK3Ae8MygJMqScidA+Zq32lSAaJHfdmtvVza4YpPS5YcBHze1AsdS4B2AUj1FTGCd0eIwBSB6navywK3mGh2tSrldiwJaw8qUonPuraa0tNcG/rbNYQpAROLbtnW0+X/X6GgUys3CCigJRAQSPTNvTUo3BSBKCPbBhum4RkeDSG5yKAXeC5zaeAUVYdqaRmgKQJR5/bKG4vIq06WEcDYrMKcCylfwhC0d/KH1hdIUgGgs2/bvq6iKatjZrMAuFNgGyWnA+S0DmQoQ9fVm4Ll7Or0ceAags+Q2K7BLBV4FvOQYHZ4FnNM6kCkBUZ8nAbpb6O3AxUurFtQqitutRoETgVOAE4A/AxcA2vPXbFMD0tyxG1qBCgoYkApR8hi7KWBAuknvjisoYEAqRMlj7KaAAekmvTuuoIABqRAlj7GbAgakm/TuuIICBqRClDzGbgoYkG7Su+MKChiQClHyGLspYEC6Se+OKyhgQCpEyWPspoAB6Sa9O66ggAGpECWPsZsCBqSb9O64ggIGpEKUPMZuChiQbtK74woKGJAKUfIYuylgQLpJ744rKGBAKkTJY+ymgAHpJr07rqCAAakQJY+xmwIGpJv07riCAgakQpQ8xm4KGJBu0rvjCgoYkApR8hi7KWBAuknvjisoYEAqRMlj7KaAAekmvTuuoIABqRAlj7GbAgakm/TuuIICBqRClDzGbgoYkG7Su+MKChiQClHyGLspYEC6Se+OKyhgQCpEyWPspoAB6Sa9O66ggAGpECWPsZsCBqSb9O64ggIGpEKUPMZuChiQbtK74woKGJAKUfIYuylgQLpJ744rKGBAKkTJY+ymgAHpJr07rqCAAakQJY+xmwIGpJv07riCAgakQpQ8xm4KGJBu0rvjCgoYkApR8hi7KWBAuknvjisoYEAqRMlj7KaAAekmvTuuoIABqRAlj7GbAgakm/TuuIICBqRClDzGbgoYkG7Su+MKChiQClHyGLspYEC6Se+OKyhgQCpEyWPspsB/AD/42tjVvrGcAAAAAElFTkSuQmCC", this.domControl.toDown.style.height = "30px", this.domControl.toDown.style.cursor = "pointer", this.domControl.toDown.style.backgroundColor = "#ffffff", this.domControl.imgDown.style.width = "100%", this.domControl.imgDown.style.height = "100%", this.domControl.imgDown.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAANv0lEQVR4Xu2dWcg1RxGG36hIFEER3EBxBwUViYJbokk0xChxF5cQBTUioheCiQjiChLQC8GIoEZccEVFI4kJLrhkMUEj6IWCoBduwSVREhMRN17+GTPfz1mm6sycMzP19M138XXNdD3V7+me6e6aE0SBAATWEjgBNhCAwHoCCITeAYENBBAI3QMCCIQ+AIEcAUaQHDesihBAIEUCjZs5Aggkxw2rIgQQSJFA42aOAALJccOqCAEEUiTQuJkjgEBy3LAqQgCBFAk0buYIIJAcN6yKEEAgRQKNmzkCCCTHDasiBBBIkUDjZo4AAslxw6oIAQRSJNC4mSOAQHLcsCpCAIEUCTRu5gggkBw3rIoQQCBFAo2bOQIIJMcNqyIEEEiRQONmjgACyXHDqggBBFIk0LiZI4BActywKkIAgRQJNG7mCCCQHDesihBAIEUCjZs5Aggkxw2rIgQQSJFA42aOAALJccOqCAEEUiTQuJkjgEBy3LAqQgCBFAk0buYIIJAcN6yKEEAgRQKNmzkCCCTHDasiBBBIkUDjZo4AAslxw6oIAQRSJNC4mSOAQHLcsCpCAIEUCTRu5gggkBw3rIoQQCBFAo2bOQIIJMcNqyIEEEiRQONmjsDQAnmUpOdIurOkv0n6oqTf5ZqGFQR2JvBwSc+XdFdJf5f0JUm/jlx1SIG8RdKFx938Nkkvk/S1SKOoC4EBCLxe0odWXOcVkj7d9/pDCeQ1kj664aYeVb7et1HUg8COBF4n6cMbrvEUSVf3uccQArlnM406ccsNnynpij6Nog4EdiCw7cfal/6VpIf2uccQAnlx86zR536nSfpun4rUgUCCQB9xtJe9t6Q/bbvHEAJZN9dbdW8/KJ0h6ZptDeP/EAgSeLWkjwVsniDpum31hxDIWZIu23ajzv9vlnS6pB8FbKgKgU0EXiXp4iCiezRvWjeaDSEQ3+AGSfcJNPAmSadK+mnAhqoQWEXglZI+EUTzrWYms9VsKIH4LVX0Ve6fJZ0i6RdbW0kFCKwm4Fe2nwzC8fqc1+t+28duKIH4Xuc2jY1c0w9JnguGFm/6OEadxRM4R9KnJN0h4Oktkp4m6fq+NpHO3Oea50n6SJ+KnTq/keT30v5LgUAfAllxPEPStX1u0NYZWiC+7hskfTDSiGYEsUj+ELSjej0CL5L0hcTIERaH0Y4hEF/3zZLeF4zdL5uRZOu76eB1qb4cAhbH5yXdMeDSrc1b09DIMeYI0l77XZLeHnDEVX8u6WRJNwbtqL58AllxnCnpyiyesUaQtj0eRTyaRIpf/T61zzvqyEWpO2sCBxHHmFOsbjT8POLnkkj5cbNO4rcOlNoEvITwleC06h/NOkd65NjHFKsbVr/Z8huuSPmhpKdL8hySUpOAxfFlSXcKuG9xPFvSdwI2a6uOPcXqCvFzkl4SbPT3JXkOaacptQgcXBz7mmK1YfWbB5/oel4wzt4W4F+EfwbtqD5fAhlxuH94X+AgI8e+p1jt/TxUekvKs4Kx82bI50r6V9CO6vMjkBWH+8flQ7u7rylWt90+r36pJC/cRMpXJb1Q0n8iRtSdFQEfqvPJ08gzh0eOUcSx7ylWN1I+fejThX6dGyk+S+zdm/+NGFF3FgQsDs8u/APat4wqjkMKxPd2polvS3piXxpNPZ99f23QhurTJpARh6fbZ48xreqiOsQUq3v/uzVHcB8XjN9Fkt4YtKH6NAlkxeHp9iVju3Rogdi/u0vy69zHBJ19v6TzgzZUnxYBnyz9RnBa5ZFjL+I49BSrGypnRvGq5yOD8XunJO/5osyPgMXhlzXbsuF0Pfu3pBfsY+RobzqFEaRty70kXSXJ2fAixaOIRxPKfAhkxfHSZi1tb55OSSB2+n6NSB4cJODnET+XUKZPYDbimNIUqxvWBzSnviyWSPGbrU3ZHSPXou44BDLi8LqXtyh5F8bey9RGkBaAp1mebnna1bd4bcRrJL3zrva9MPUGIeBzPt8MPnNYHE7M8JlBWpC4yFQFYlf8wO4Hdz/A9y0G6jccXnWnTIeAxeGFYa999S0HF4cbOmWBuH1+9etXwH4V3Lf4NaC3HkSS2fW9NvXiBDLi8GzAWXIONnK0bk5dIG6nFxGdz9eLin2LtyB4B7B3AlMORyArDufY/fjhmn37necgELfW21G8LSUyRPsMic+SeASi7J+A851563kkZh45JiOOOUyxumH1xkbPYyMLSz6N6FOJPp1I2R8Bi8Ojd2TUn5w45iYQt9db5L36Gtnx6XPtzgPsc+6U8QlkxOFWOTv7JKZVXURzmWJ12+zDVt4WHTkz4HysHoFIlj2uQLLi8Cc0Nn0RatxWb7j6HAVid3xs1wtHkQRizrXlh0bn3qIMT2Bx4pjjFKsbVq+ufjaYgtJZG53i1FkcKcMROEnS94LPHL77ZEeOFs1cR5C2/X5X7gzfkeL8vxYJGeUj1NbXtTj8tiqyVuWrvUnSB4ZpwnhXmbtATCaTLNuZ5D0lIFn2bn1r0eKY+xSrG1qSZe/W0TPWixfHkgRiX5woO3p4imTZGWlIj5b0g8S06q2SLszd8jBWS5hidcmRLHv8fmRxeOtPZBOpWzU7cSxtBGm7BsmyxxNJVhzvkPTu8Zo13pWXNoK0pEiWPXyfyYrDUyqPHrMsSxWI/fLXT/0aOFJIlr2aVklxLHWK1YbYXz/1QmI0ozzJso+K5BHN6c7oM8esR44WwVJHkNa/bEZ5kmUfI2hxeFSNHH22nRcAvRA4+7J0gThA2YzyPrbrT385F1PFUl4cS59idTu1t8c7YUA0WbY/N/zyghnlEUfTeyqMIK1QssmynSXFmTWqlIdJujoxrfJ2dW8+XFSpJBAHjmTZm7uvxeEV8vsGe/kixVFpitWNN8myV/d+xLGCS7URpEWQTZbt1WCvCi+tZMXhI7I+KrvYUlUgDijJso916wdJuiYxrbI4nIFk0V/7qiwQd47qybItDj9z3D84BJQQR9VnkOP7gpNlOw+w/0bK3JNlZ8XhbIfewrPokaPtCNVHkJaDP7dgkUQyys85WfYu4vAr7zJfGkYgt48ZmYzy7iheSPSC4lwK4ghECoEchZXJKO+tKN6SMoeM8n7W8AN59JnD06pSIwdTrPW/Is4o7+lWJG2mM8qfNfFk2RaFH8g9gkSK8495R3SZaVUXDiPI6q6ytGTZu4jD3wWsumFz8t8HifzSDV13KcmyEccOPYMRZDO8uSfL9p4qP3NEp1WXNJ9bLjty8AzS/1dlrsmyLQ4/c3gbSaRYHP6MnZ+ryhdGkH5dYG7JshFHv7hurYVAtiL6f4W5JMvOiuNySWczchztEAikv0Bc01ssnC0lwm2fybJ3EYc/fOpvO1I6BCKBBtwxAudJct6tSHGybGeU99+xincn+yRg9JnDIwfiWBMVBJLrrpmM8v7cgkUyRkZ5i8PZR3yWPFIQxxZaCCTSnY7WnUpG+aw4/E0Pr/4zrdrQBxBIXiC2fI+ktwUv4YzyT5Lk7ybuWnYRh78j709lUxDIqH3gUMmyfWzYe8ai0yqPHIijZ5dgBOkJaku1fSfLtjj8CQLnzI2UKyWdwcjRHxkC6c9qU819JsveRRxnSrp1GJdrXAWBDBfnfSTLRhzDxavXlRBIL0y9K42ZLDsrjmslnc7I0TuGRyoikBy3TVZjJMt2sjtvPIw+c1gc3pF8y/Bu1rgiAhknzk6WfWnTOSN3WJUs2+Lwmyd/VTZSEEeE1pq6CGQAiGsucRdJV0g6JXgLi+ECSV4vebIk572Nbh+5rhHnzcF7U/04Aghk3C6RzSi/S6uub545hliI3KUdi7BFIOOHMZtRPtMyxJGhtsEGgQwMdM3l/Bzho69OKzRWQRwjkEUgI0Bdc8lssuw+LfxZ86zDtKoPrUAdBBKANUDVbLLsTbe2OE6VdOMA7eMSPKQfvA84DY/3RD1wgJZYHKdJ+ssA1+ISKwgwghymW3i65U9NP36H2/sb8P4+x207XAPTLQQQyOG6yImSLkp8oekmSedLuvhwTa9zZwRy+Fg/VtJ7m9N9m1rze0nOk+tPwP318M2u0QIEMp04+1Wwkyc8pGmSE7fd0CR6+ImkP06nqXVagkDqxBpPEwQQSAIaJnUIIJA6scbTBAEEkoCGSR0CCKROrPE0QQCBJKBhUocAAqkTazxNEEAgCWiY1CGAQOrEGk8TBBBIAhomdQggkDqxxtMEAQSSgIZJHQIIpE6s8TRBAIEkoGFShwACqRNrPE0QQCAJaJjUIYBA6sQaTxMEEEgCGiZ1CCCQOrHG0wQBBJKAhkkdAgikTqzxNEEAgSSgYVKHAAKpE2s8TRBAIAlomNQhgEDqxBpPEwQQSAIaJnUIIJA6scbTBAEEkoCGSR0CCKROrPE0QQCBJKBhUocAAqkTazxNEEAgCWiY1CGAQOrEGk8TBBBIAhomdQggkDqxxtMEAQSSgIZJHQIIpE6s8TRBAIEkoGFShwACqRNrPE0QQCAJaJjUIYBA6sQaTxMEEEgCGiZ1CCCQOrHG0wQBBJKAhkkdAgikTqzxNEEAgSSgYVKHAAKpE2s8TRBAIAlomNQhgEDqxBpPEwQQSAIaJnUIIJA6scbTBAEEkoCGSR0CCKROrPE0QQCBJKBhUocAAqkTazxNEEAgCWiY1CGAQOrEGk8TBBBIAhomdQggkDqxxtMEAQSSgIZJHQL/A2xT29iVgShZAAAAAElFTkSuQmCC", this.domControl.domChild.style.maxHeight = "315px", this.domControl.domChild.style.borderTop = "none", this.domControl.domChild.style.borderBottom = "none", this.domControl.domChild.style.position = "relative", this.domControl.domChild.style.overflow = "hidden", this.domControl.showFloor.style.backgroundColor = "#ffffff", this.domControl.showFloor.style.position = "relative", this.domControl.showFloor.style.top = "0px", this.map.config.get("showAllFloor") ? (this.domControl.allFloor.style.display = "block", this.domControl.oneFloor.style.display = "none") : (this.domControl.allFloor.style.display = "none", this.domControl.oneFloor.style.display = "block"), this
                }
            }, {
                key: "domClick",
                value: function (t) {
                    var e = this;
                    this.domControl.allFloor.onclick = function () {
                        e.domControl.allFloor.style.display = "none", e.domControl.oneFloor.style.display = "block", e.map.showOneFloor()
                    }, this.domControl.oneFloor.onclick = function () {
                        e.domControl.allFloor.style.display = "block", e.domControl.oneFloor.style.display = "none", e.map.showAllFloor()
                    }, this.domControl.toTop.onclick = function () {
                        var t = parseInt(e.domControl.showFloor.style.top.replace("px", ""));
                        if (0 != t) {
                            e.domControl.toDown.style.cursor = "pointer";
                            "0px" == (e.domControl.showFloor.style.top = t + 45 + "px") && (e.domControl.toTop.style.cursor = "not-allowed")
                        }
                    }, this.domControl.toDown.onclick = function () {
                        var t = parseInt(e.domControl.showFloor.style.top.replace("px", "")),
                            i = e.domControl.showFloor.children.length;
                        if (i > 7) {
                            if (t == 45 * -(i - 7)) return;
                            e.domControl.toTop.style.cursor = "pointer";
                            (e.domControl.showFloor.style.top = t - 45 + "px") == 45 * -(i - 7) + "px" && (e.domControl.toDown.style.cursor = "not-allowed")
                        } else e.domControl.toDown.style.cursor = "not-allowed"
                    }
                }
            }]), t
        }();
    e.default = l
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = function () {
            function t(e) {
                (0, o.default)(this, t), this.config = this.set(e), this.map = {}, this.domControl = {}, this.changeScaleSpacing = function () {
                    this.dom.style.width = "50px";
                    var t = this.map.getScaleSpacing() / .85,
                        e = (50 / t).toFixed();
                    this.dom.innerHTML = e + "m", 0 == e && (e = (50 / t).toFixed(1)), this.dom.innerHTML = e + "m"
                }
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.bottom = t.bottom || "50px", t.left = t.left || "30px", t.color = t.color || "black", t.fontcolor = t.fontcolor || "black", t.linewidth = t.linewidth || "3px", t.linelong = t.linelong || "50px", t.fontsize = t.fontsize || "16px", t
                }
            }, {
                key: "callback",
                value: function (t) {
                    var e = this;
                    this.map = t;
                    var i = function () {
                            e.changeScaleSpacing()
                        },
                        r = function () {
                            if (e.map.event.off("onMouseWheel", i), e.map.event.off("changeFloor", i), "MODE_3D" == e.map.config.get("showViewMode"))
                                for (var t = 0; t < e.map.dom.children.length; t++) "OvuRouteMapScale" == e.map.dom.children[t].className && e.map.dom.removeChild(e.map.dom.children[t]);
                            else if ("MODE_2D" == e.map.config.get("showViewMode")) {
                                for (var t = 0; t < e.map.dom.children.length; t++) "OvuRouteMapScale" == e.map.dom.children[t].className && e.map.dom.removeChild(e.map.dom.children[t]);
                                e.addDom(e.map), i(), e.map.event.on("onMouseWheel", i), e.map.event.on("changeFloor", i)
                            }
                        };
                    r(), this.map.event.on("changeModel", r)
                }
            }, {
                key: "addDom",
                value: function (t) {
                    var e = document.createElement("div");
                    e.setAttribute("class", "OvuRouteMapScale"), this.dom = e, t.dom.appendChild(e), this.dom.style.borderBottom = this.config.linewidth + " solid " + this.config.color, this.dom.style.height = this.config.fontsize, this.dom.style.bottom = this.config.bottom, this.dom.style.left = this.config.left, this.dom.style.position = "relative", this.dom.style.textAlign = "center", this.dom.style.color = this.config.fontcolor, this.dom.style.fontSize = this.config.fontsize
                }
            }]), t
        }();
    e.default = l
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = function () {
            function t(e) {
                (0, o.default)(this, t), this.config = this.set(e), this.map = {}
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.left = t.left || "150px", t.top = t.top || "60px", t.position = t.position || "absolute", t.width = t.width || "48px", t.showCompass = void 0 === t.showCompass || t.showCompass, t
                }
            }, {
                key: "callback",
                value: function (t) {
                    this.config.showCompass && (this.map = t, 0 == this.map.dom.getElementsByClassName("OvuRouteMapCompass").length && this.map.dom.appendChild(this.addDom()))
                }
            }, {
                key: "addDom",
                value: function () {
                    var t = document.createElement("div"),
                        e = document.getElementsByClassName("OvuRouteMapCompass").length;
                    t.setAttribute("id", "OvuRouteMapCompass" + e), t.setAttribute("class", "OvuRouteMapCompass"), t.style.width = this.config.width, t.style.height = this.config.width, t.style.left = this.config.left, t.style.top = this.config.top, t.style.position = this.config.position, t.style.borderRadius = "50%", t.style.cursor = "not-allowed";
                    t.style.background = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAr8SURBVHja7J1taBv3Hce/vzvdyXe2T8Ju2jlRlqlOWkankhY2l47SuOA3zVgD2QKhpZTCNgJNu67QLO8DXl+E0mEw896FFEFaQ9s1e+NgB/qm8YsQ7KylTY0IdqLWtY18lnXS6e5+e5E7V5Kl00OU1rHvC0KyTk/38e/p/3iE9onqPF96Tz7H6n2eJ67yuNp9rWN+n9d2CO0GWfm47O/x8fHeRCJxsKOj4xFJkg6EQqEDRPQzIupaWVnZtby8rAJAb29vrqen53tmzjLzt5Zl3SgWizfy+fzXs7Oz144ePbpcBSLXAdxWsHQPYFaDVwZxeHhYOXbs2HOqqh6SJOmQIAiPMXPV37K8vIyVlRUAQE9PD3p7e6v/ECJ2HOd/xWLxci6Xu3zhwoXJ06dPGzXg1gPLPzbQZkFSLBajiYmJZ6LR6IuyLB8BoJXCCIVCJIoiRFGEIAgQBAFEhNu3b+PWrVsAgD179mD37t1gZjiOA8dxYNs2bNuGZVlc8U/RTdP8KJPJvD80NPTZwsIC14DaVrDURphVb6dOnQq/9tprL6uq+iaAuPeGUCgESZIgSRJCoVDNL7t16xYWFhYAALFYDHv27Kn5WsuyUCwWUSwWYVlW6aFULpd7d2Rk5Nw777xT8AF711DpLmHWskpheHhYeemll/6sKMobRNQHAKIoQpZlhMNhCILQ0Bc2A7RUjuOgUCjANE3Ytn2HDHPaMIz3zp8/P+aGA6dBa+V7AZRqWCUACKUw5+bmno9Go2cB7POsUVEUSJLUtDu0CrRUxWIRhmGUWu3NTCbzVn9//38roDpVkldTUIUGQZKPi3swhcnJyV8sLi5+EI1GPwSwLxQKobu7G5qmtQSzXZIkCZqmobu72wsv+6LR6IeLi4sfXLp0aV/pOVRJon4cWgJaL14KAMRUKnXk4MGDn4uieFgQBO7s7PzJQdYC29nZCUEQWBTFw08++eSVVCp1BIBYBWjTOUZo0c09kMLJkyfD6XT6rKZpSWaOyrKMSCRC4XAYW1XhcBiRSIRkWQYzRzVNS6bT6bMnT54Me+dVx1JbiqF1YSaTyZ6hoaFxInqKiFhV1baDbEcM9VOhUEAul2NmJmb+fGJi4ujx48dX3Hjq+FQA3EorpybMqampWCKR+ISIfimKIrq6uiCKIu5H2baNbDYL27bBzF/Ozs7+fnBwcKEVqNQKzCtXrjy6f//+TwHEvMRDRLifxcxYW1vzKoGFb7755ncDAwNfNQu1kRi6yTI9mJIkbQuYbmsN3d3dXhKN7d+//9OpqalYAzHVNymRX+snmUz2JBKJT7YbzFpQE4nEJ8lkssenX2KTR4sNuPpGNn/11Vf/Q0RPbBc3ryVZlmFZFph518MPP/xbwzCS09PTjk8yItTpf6ws2sV0On1WluUToihC07RtC7M0puq6Dtu2YZrmaF9f31sA7JIWFVfrkxUacHUhlUq9IMvyCSLirq6ubQ/Tc3/3XFmW5ROpVOqFOoU/+SWljTdMTk7ui0QiowCgqirdr6VRKxJFEaqqEgBEIpHRS5cu/bxeciIfVxcACIuLix+IonhYlmV0dXVhJyqbzXq9VhcffPDBP/q5vuBnnXNzc8+Xts13qkrb/nNzc89XuH7NsqksNgwPDytuFxwURaGdEDf94qmiKAQA0Wj07PDwsFIrllYOmG24+s2bN//a1dU1HAqFoGkaAgG6rsOyLORyub/v3bv3vZJWlFMty5cNW3R2dr7uWmdA0pXHQlGUN06dOhWuZqVULRHNz8//SVXVfwbW6Wulr+/du/fflVZaGVwpFouRO6AWWKePlaqq+mYsFts0x6AyKWFiYuIZAHFRFLdUb/tWkSRJXjdl3GVV1jDaFEOj0eiLXns2UO22vpvxX6yMoUJlqeROQsBWHsL4qeWxkWX5SGUJVVbYHzt27DkAWigUanjcfCdKEARv9FRzmZUV9ht0VVU95MWJQPVjqZucDtWyUJIkKQDaJFCXGW2y0PHx8V5BEB5zJ24FxOooFAqBiFgQhMfGx8d7N1loIpE4yMwUCoUowNUwVGJmSiQSBzeVTR0dHY8CwE7q77xbeaw6OjoeqSybIMvygQBoa0BlWX7EM0yh5OABryQI1Hj5VMquzOWJ6KEAaGtAXXblY0pE1OXeB6QalMfKYwcAG/XRysrKLmZGLpfzhdruyVpbXbdv3655jJlhGAYA7CoFSgDgLV2pp50GdH5+vpGXqZuSUqA21aZwx0J6e3tzzKwqihLE0QY9kpmRz+dBRDnvqY0Y2tPT8z3uzD0PMn2JYrFYzWOO4yCTyQDA95VlE5g561EP1Jg8Vh67UqDMzN951AM1Jo8VM3+LimFk2LZ9IwDaGlDLsm6UWigDgGmaX7tgA1INymNVLBY9oLzh8vl8PgDaIlCXXbnLz87OXiMitiwryEoNyrIsJiKenZ29ttEcdWtRAYC4tLQ0TUS/0jQNQa99XZjQdR3MfP2BBx74De5McXRKC04uFouX3ZgQEKsjj5HLjCuTEgPgXC4XAG0SqMtsg2FZk+jChQuTAHTLsoLyqU655C4Q011mKI2hQuktnU7/S5bllxVFCSaL1ZBhGDAMA6Zpnuvr6/sLSmbgbZRN3i2Tybzv1qUBuRry2LisypYsliUlABgaGvoMQMq27SCW1oidbv2ZclmhVlICAF5YWOBcLveuZ9qBNru7m4zeLdlpB9WS0obpjoyMnGPmtLfLTKAfrNNdspgeGRk5hyorlGsuWpifn39DVdV/BNPCf1AzixY2Wen58+fHANy0LAuFQmHHwywUCl6pdNNlU3X9fLWVdBtWOjc3dzgajX4oCAJHIpEdu1aJmZHJZJiZKZPJ/KG/v/9iNeusBbRsFXKwNLH5pYlczeW9N1y/fv0tIsqYprkjXd/bnYyIMjMzM39D7d3IAIBr7dtZtnYplUod0TQtSUSsadqOWZFs2zZ0XWdmJl3Xj8fj8Y/gvwcJC5WFaTUrjcfjH5umOcrMlM1md8RAHjPDPVcyTXM0Ho9/XM86Af8tMsqeN03z8rPPPjvIzDHLsiDL8rYdv/d2yHG3Hfr8zJkzr0xPT1uovZtDTW3agg13OqAlAOFkMrl7aWnpi+XlZXZdYVtK13VeXl7mpaWlL5LJ5G4AYZdBCNW3dPO1St94OjU1FXv88cen4O6Ms522zPDc3G0dLszMzAw2sCEWNwO0KtRgI6xNjSGUlk3we0FlggLgDAwMfDUzMzPIzF96Yyv382ipm829dvqXMzMzg63A9EtEDVlqsJngZtUrKH39eHx83DAMI/n0009HRVH8tddXKElS20LA2toadF0HAGia1raOGmbG+vo68vk8AJBpmqNnzpx55e23316rks0b3u22kbP2s9TS4v+FSCQyysxRQRBYUZS2WOu9sNBCoQDDMNhxHCKizOrq6omSOtOv1kS9cqmVeYtcJa7a8Xj8o2vXrj1l2/ZFx3FofX0duq5vqf7UYrEIXdexvr4Ox3HItu2LV69eHXBbQHYDMJu2vlYsFQg2tW7JQutmf89a+/v7L46NjT2RzWZPez3/a2trWF1dhWEYP8oQteM4MAwDq6urG+UQM6ez2ezpsbGxJ9wuOLtKN1zLMJu10Hq1a3BhAASXrtgSl664G7BAcHGVlj+jlcv/PCrL8gFRFA8Q0UN1Lv/znW3bN0zTvJHP57/aLpf/aRZsNcDV7hv5bdv2AlXNgm0WJDVQbdQDe89B3kugzfYT0F3+pkYA33OQnv4/AJcsXc5NjeAUAAAAAElFTkSuQmCC') center center no-repeat", t.style.backgroundSize = "contain";
                    var i = document.createElement("div");
                    return i.setAttribute("id", "OvuRouteMapCompassp" + e), i.setAttribute("class", "OvuRouteMapCompassp"), i.style.width = this.config.width, i.style.height = this.config.width, i.style.borderRadius = "50%", i.style.cursor = "not-allowed", i.style.background = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAABUCAYAAADjyTUjAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAmiSURBVHja7FlbjBtnFf7OmRnfd72bxNlbVJRWXSAWLbCqEFUlVhRVhQohKBS1EZcKoS1FlAcUCfpSRQKJlxbxEPUBqSJllZaqRX0BESLRvBDKwyot1AQ1210p3m7iOF7Xqb2+zOXn4Z9/Zjz2+LJJ1ZeOdLROZub/vvOd75z5PSYMOIQQhBs8iEgMPP9BAY9KYjwCx48PJvbUU2JcEjQSeBRwoUDI58UoZPZOIAheKPify2X/cy7nLx4kNAKJwQQUuAIulwnLy/Lc9rZ/3fy8XPjsWUkmgsRQApHgCnh7m1Ct9i/H9LTwyBQKoksNl0Q/AjzQbP3A63VCOs1dUa8TikVGtUrY3ibk89RTsgh/ceRJBb64SCgUGMWiBMtkGJVKd2QyjJkZSS5MYkj38EDHLy/Dy3pmhlCpMGo1xtQUIZHgrlBE0mlfiXKZhqnAA9pLLhIEV8DXrmkAZNTrklQiIf82GuSRWFwcqgJH9r6quQJXwPE4Ix5n7O4ystnfgFkDsySj1Gg0/HLk8z0qRCtw/Dh52VerMhMFXq9L4OvXNRBpmJ9/DLb9MFKpOAxDEorHpQq1mvREuF37lIEjsweARoMwNUVotwnxOMMwGLEYu/J/B8wJZLMrqNc1xGI+iWxWqqZKoYZWnzJwT43Uxek0o9Ui1GrsgbdaDCIN2ewRAB+HpgHMD4FIlkCRqNelXxoN8swcYUbuMZ9yvsreNAm7uz64rjMM46dgZjADRJ/AwYO3o92W18RijExGEm+1pBdURwz1QLnsOz+YfSzG0HUZREkwfxHMcAkwYrHH3HMaLEsSNk1ZupkZ6SelQqgM3GU+lf3MjJ99sykza7cZzaaGffseBfMkmAFNg1uG+zx1dN1XIZslryMizMg95qvX5U2tljReKkUwDAazBGB+KJC9igPI5b4O02SvFLu7jHZbrqNU6GNG7jKfyl7WTsqostc0xuzsXSBaDAD7RHT9YU+BRIIQi8nyqbkQYUbuMp9qvURCShiLSfcbBsM0Gcwrocz9AJaQyx30VLAs8nwQNGNfE4bN125LI1kWedmn05NgvicEGlTBgK7/0FNB1xnNZq8Z1WR0lee+5lO113VGPE4wTcb09AqApFd/Be7vNgCir8A02VMhlSJvMEWYUe8yn+x1BjPBthm2zRBCtd/XegA9HRkQAhDiEBYWvoBr1/4OTZMdxOzAcQhCkDeepRkFjh8n7jJfuy3rZprUJWUu9yUwH+rKvqeYnhm/C9NkdDr+6I7H/ckYnAkAdCwuEopFAiD7FiBYFsO2pfRSge931b17pxkuw+cRj0/AcWowTZm5ENJLQghYliqD8E2oWk+ZT7VeLEbYv38WzHf1cX2UCkns2/coHIeGmhEAe5tMNflSKUIiQZ75Uqkfgdnoar8oFdR5w/gqbJvgOATblmsGJ2Pg2cNdky+TIVgWeTcDgKZ9eWjmQQ/Iv7djdvZO2LZcb8BMkCVQ8pumf4NtEw4d+iaIckPB5WDvJqnrP0AsJtcBANP0Fwh0g79zCV8kszraNW4HkQiWQdMAomU4jo50GrAsn0S7LT+7pefIBQ8cuA1Ed44EHiYiSU9ibu4RNBrR1y4vuwQUq+CRTP4YROwBCzE6uFIN+BY0beCNkkA8Li8yDOFKr4HovpFab7AKn8Ls7GHouhhtV2wYArouMDf3KDQt68k/3tuIIAmGYTwGXRcwDBkqWY9AqSSQSMgT9bpAp+OA6JGeJ964JHzz3o9Ox+kCL5VElwJbAMrlMnYAtBcW7oKmfTJUy728l1Fx0J6dfXCnXhflchmXg9+mz54Fr6v9KICLAGJEP+np73EjRELT9e9ddDHsREKsq6/xuZzgTiYj/rm1hQIANJuTBNx7Q+AqHMcnI8TnDk1OzhYAvLGxQZ1MRqypSVhwS7B5+TJ9+tZbj8Fxkt4Ctr33UARkGAfS6Z9tXr5M2wAKAN5/+22BfF7wlfPn6X+dDv3btikGPNwDbJqAZY0Xptl9r+MgBnzjHdPkNQBXzp/3XK1fBNDc2qJSOk3i2WeLxJzrGTq+lKO3YOj/bdt+d+PIEcxtbdHFiQnsACgXCsRX4nFRAlCtVlHa3j7p7XqCIzj4pBsU4cEVOHetVHrh2s4OlQAo4/83nxcMABVNE1UAP3/iiVeFEO95GQQXHgbeL/yjeeLpp//0nosFAAX31R5vJBKixCwA4PRrr7UqOzsv9/R/v+8BgyK4R2BG7fr1v/zuuedqAFBiFlezWUe+PHtKKqDruriuac4ukfPX06ef3zNwBJHzb7zx4i6Rc53Z6XkWTExMCF3XBREJInJWVlbWd5vNf9wwuBumZW0+8MAD5wAIZha6rouJiQmRz+cFuSQ1ADEAKQBTAGbW1tZWxE06Njc3fw1gFsA0gLSLpbmPAW9TYgBIAJgAcODw4cMfsyyrdBPwzSeffPKzAHIAJgEkXSzNBfcI6ADiLsNpAHPFYvG3N4peq9X+BmAewD4AGRdDD2cv3HACYa2urq4CsG/kh4oLFy686K6h1lVYPS+sgypkXMbztVrt9F6ztyzryvz8/C0ADrilTbjyc/AleXBahJWw33zzzT/sNftSqfTy9va2GVCgb/ZhFbrMmEwmFzqdzuYeBHBOnDhxD4CDALJR5utHQAuZcXZjY+OX46I3Go1zrvn2uyVNhM0XVQIESwDAfuaZZ/4ohGiPI//6+royX9iAGPYTXl8zViqVV0bN3rbt9+6+++7bXPNNRplv0Ov6oBltANbrr7/+/KjZVyqVV8+dO7cbuF+Mkn0/FZQZ9wNYaLVahVEUeOmll+4PmC81zHyDzBgLmvHChQu/GAbebDb/A2DBJT0xyHzDSoBQGexjx469LIR4fxD7S5cuvbAX841qxrmrV6/+PrLxHad59OjRI8MePKMSoEAZkm49D66urt4bRaBSqbwCYG7Qg2evKgTNON9oNP7Vj8CZM2ceDJkvtpfso8zobVbeeuutx8PgnU7nncDkG8l8o5Yh/HzYv7S0dItt2+UggUuXLv3KzX4qatcz+g+X3Z3QM5jW1taa1Wr1VOC8derUqVMArNCTD3vpgCgzGq4ZJwBMnzx58jNCCNvt/T+70mfd7OM3Kv+glky5JKZardZpIYRYX1//tgueCcz9PZtvkBmNAIlMsVh80HGcd5eWllTmSbf2Ny37sBn1AInkHXfcka7Vao+7wIkAuDYOARqDRFCR4L9FRIxkQhqDJPUh1O/5MVYHaGOUot+eoV/Ljl3jm3nd2EToAyA8lgokhMCHeTA+5OMjAh8R+IjA/wcA48M20iwTwSYAAAAASUVORK5CYII=') center center no-repeat", i.style.backgroundSize = "contain", t.appendChild(i), t
                }
            }]), t
        }();
    e.default = l
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = function () {
            function t(e) {
                (0, o.default)(this, t), this.config = this.set(e), this.map = {}, this.domControl = {}
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.bottom = t.bottom || "200px", t.left = t.left || "10px", t.position = t.position || "absolute", t
                }
            }, {
                key: "callback",
                value: function (t) {
                    this.map = t;
                    for (var e = 0; e < this.map.dom.children.length; e++) "OvuRouteMapSwitch" == this.map.dom.children[e].className && this.map.dom.removeChild(this.map.dom.children[e]);
                    this.addDom(), this.domStyle(), this.domClick();
                    var i = this;
                    this.map.event.on("loaded", function () {
                        "MODE_3D" == i.map.config.get("showViewMode") ? i.domControl.button3D.click() : "MODE_2D" == i.map.config.get("showViewMode") && i.domControl.button2D.click()
                    })
                }
            }, {
                key: "addDom",
                value: function () {
                    var t = void 0,
                        e = void 0,
                        i = void 0,
                        r = void 0;
                    return t = this.createElement("div"), t.setAttribute("class", "OvuRouteMapSwitch"), r = this.createElement("style"), e = this.createElement("button"), i = this.createElement("button"), "MODE_2D" === this.map.config.get("showViewModel") ? (e.setAttribute("class", "btn btn-select"), i.setAttribute("class", "btn")) : "MODE_3D" === this.map.config.get("showViewModel") && (i.setAttribute("class", "btn btn-select"), e.setAttribute("class", "btn")), e.innerHTML = "2D", i.innerHTML = "3D", r.innerHTML = ".OvuRouteMapSwitch .btn{\n                width: 45px;\n                height: 30px;\n                border: 1px solid #ccc;\n                color: #333;\n                background-color: #FFF;\n                line-height: 30px;\n                font-size: 14px;\n                text-align: center;\n            }\n            .OvuRouteMapSwitch .btn-select{\n                background-color: #337ab7;\n                color: #FFF;\n                border: 1px solid #2e6da4;\n            }\n            .OvuRouteMapSwitch .btn:hover {\n                background-color: #DDD;\n            }\n            .OvuRouteMapSwitch .btn-select:hover {\n                background-color: #286090;\n                color: #FFF;\n            }\n            ", t.appendChild(e), t.appendChild(i), t.appendChild(r), this.map.dom.appendChild(t), this.domControl = {
                        dom: t,
                        button2D: e,
                        button3D: i
                    }, this
                }
            }, {
                key: "createElement",
                value: function (t) {
                    return document.createElement(t)
                }
            }, {
                key: "domStyle",
                value: function () {
                    return this.domControl.dom.style.width = "45px", this.domControl.dom.style.display = "inline-block", this.domControl.dom.style.cursor = "pointer", this.domControl.dom.style.borderTopRightRadius = "3px", this.domControl.dom.style.borderTopLeftRadius = "3px", this.domControl.dom.style.position = this.config.position, this.domControl.dom.style.bottom = this.config.bottom, this.domControl.dom.style.left = this.config.left, this.domControl.button2D.style.borderTopRightRadius = "3px", this.domControl.button2D.style.borderTopLeftRadius = "3px", this.domControl.button3D.style.borderBottomRightRadius = "3px", this.domControl.button3D.style.borderBottomLeftRadius = "3px", this
                }
            }, {
                key: "domClick",
                value: function (t) {
                    var e = this;
                    this.domControl.button2D.onclick = function () {
                        e.domControl.button2D.setAttribute("class", "btn btn-select"), e.domControl.button3D.setAttribute("class", "btn"), e.map.mapTo2D()
                    }, this.domControl.button3D.onclick = function () {
                        e.domControl.button2D.setAttribute("class", "btn"), e.domControl.button3D.setAttribute("class", "btn btn-select"), e.map.mapTo3D()
                    }
                }
            }]), t
        }();
    e.default = l
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(84),
        o = r(n),
        a = i(9),
        s = r(a),
        l = i(2),
        h = r(l),
        c = i(3),
        u = r(c),
        p = function () {
            function t(e) {
                var i = this;
                if ((0, h.default)(this, t), this.userDom = e.content, e.id || 0 === e.id) this.id = e.id, this.floor = e.floor;
                else {
                    if (!e.position || "{}" === (0, s.default)(e.position)) throw new Error("The information window invokes the parameter error");
                    this.position = e.position, this.positionXYZ = e.positionXYZ
                }
                this.closeFlog = !0;
                var r = this;
                this.positioning = function () {
                    i.infoWindowPosition(), r.map.event.on("controlMap", r.infoWindowPosition), r.map.event.on("changeModel", i.infoWindowPosition)
                }, this.infoWindowPosition = function () {
                    var t = r.dom.getElementsByClassName("airocov_info_Triangle"),
                        e = void 0;
                    t.length > 0 && (e = r.map.screenCoordinates(r.positionXYZ), r.dom.style.left = (0, o.default)(e.x - r.dom.offsetWidth / 2) + "px", r.dom.style.top = (0, o.default)(e.y - r.dom.offsetHeight) + "px", t[0].style.left = r.dom.offsetWidth / 2 - 12 + "px")
                }
            }
            return (0, u.default)(t, [{
                key: "callback",
                value: function (t) {
                    this.map = t;
                    var e = this.addDom(t);
                    this.map.event.on("changeFloor", this.close), this.id || 0 === this.id ? (this.positionXYZ = this.map.getObjectPositionByInfoId(this.id, this.floor), this.position = this.map.screenCoordinates(this.positionXYZ), this.positionInfowindow(e)) : this.position && "{}" !== (0, s.default)(this.position) && this.positionInfowindow(e)
                }
            }, {
                key: "close",
                value: function () {
                    for (var t = 0; t < this.map.dom.children.length; t++) "airocovInfoWindow" == this.map.dom.children[t].className && this.map.dom.removeChild(this.map.dom.children[t]);
                    this.map.event.off("controlMap", this.infoWindowPosition), this.map.event.off("changeModel", this.infoWindowPosition), this.map.event.off("changeFloor", this.close)
                }
            }, {
                key: "addDom",
                value: function (t) {
                    this.closeFlog = !0;
                    var e = document.createElement("div");
                    e.setAttribute("class", "airocovInfoWindow"), this.dom = e, e.style.position = "absolute";
                    var i = document.createElement("div");
                    i.innerHTML = this.userDom, i.style.overflow = "hidden", i.style.fontFamily = '"Helvetica Neue",Helvetica,Arial,sans-serif', i.style.backgroundColor = "#FFF", i.style.borderRadius = "3px", i.style.border = "1px solid #39a8e8", i.style.padding = "9px 16px", i.style.zIndex = "999", t.dom.appendChild(e), e.appendChild(i);
                    var r = document.createElement("div"),
                        n = document.createElement("div"),
                        o = document.createElement("div");
                    n.setAttribute("class", "airocov_info_close"), o.setAttribute("class", "airocov_info_Triangle"), e.appendChild(r), e.appendChild(n), r.appendChild(o), r.style.position = "relative", r.style.width = "100%", r.style.height = "16px", r.style.color = "#337ab7", n.innerHTML = "", n.style.color = "#333", n.style.position = "absolute", n.style.top = "0px", n.style.right = "2px", n.style.width = "15px", n.style.height = "15px", n.style.lineHeight = "15px", n.style.textAlign = "center", n.style.cursor = "pointer", n.style.backgroundColor = "#efefef", n.style.borderRadius = "7px", o.style.borderLeft = "12px solid transparent", o.style.borderRight = "12px solid transparent", o.style.borderTop = "16px solid #39a8e8", o.style.opacity = ".8", o.style.position = "absolute", o.style.bottom = "0", o.style.left = e.offsetWidth / 2 - 12 + "px";
                    var a = this;
                    return n.onclick = function () {
                        a.closeFlog = !1, t.dom.removeChild(a.dom)
                    }, e
                }
            }, {
                key: "positionInfowindow",
                value: function (t) {
                    t.style.left = (0, o.default)(this.position.x - t.offsetWidth / 2) + "px", t.style.top = (0, o.default)(this.position.y - t.offsetHeight) + "px";
                    var e = t.getElementsByClassName("airocov_info_Triangle");
                    e.length > 0 && (e[0].style.left = t.offsetWidth / 2 - 12 + "px")
                }
            }]), t
        }();
    e.default = p
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(42),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = i(94),
        f = r(p),
        d = i(10),
        m = r(d),
        g = (i(31), function () {
            function t() {
                (0, o.default)(this, t)
            }
            return (0, s.default)(t, [{
                key: "drawFence",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    t[0][0] == t[t.length - 1][0] && t[0][1] == t[t.length - 1][1] || t.push(t[0]);
                    var i = e.height ? e.height : 10,
                        r = this.getConfig(e),
                        n = h.default.drawFence(t, r);
                    return n.position.setY(i), n.name = "polyLine", n
                }
            }, {
                key: "drawLine",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        i = e.height ? e.height : 10,
                        r = !!e.lineType && e.lineType,
                        n = this.getConfig(e),
                        o = h.default.drawDirectionLine(t, n, r);
                    return o.position.setY(i), o.name = "polyLine", o
                }
            }, {
                key: "drawPath",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = e.height ? e.height : 2,
                        r = e.radius ? e.radius : 1,
                        n = e.imgUrl ? e.imgUrl : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABdwAAAH0CAYAAAAnhe8sAAAKN2lDQ1BzUkdCIElFQzYxOTY2LTIuMQAAeJydlndUU9kWh8+9N71QkhCKlNBraFICSA29SJEuKjEJEErAkAAiNkRUcERRkaYIMijggKNDkbEiioUBUbHrBBlE1HFwFBuWSWStGd+8ee/Nm98f935rn73P3Wfvfda6AJD8gwXCTFgJgAyhWBTh58WIjYtnYAcBDPAAA2wA4HCzs0IW+EYCmQJ82IxsmRP4F726DiD5+yrTP4zBAP+flLlZIjEAUJiM5/L42VwZF8k4PVecJbdPyZi2NE3OMErOIlmCMlaTc/IsW3z2mWUPOfMyhDwZy3PO4mXw5Nwn4405Er6MkWAZF+cI+LkyviZjg3RJhkDGb+SxGXxONgAoktwu5nNTZGwtY5IoMoIt43kA4EjJX/DSL1jMzxPLD8XOzFouEiSniBkmXFOGjZMTi+HPz03ni8XMMA43jSPiMdiZGVkc4XIAZs/8WRR5bRmyIjvYODk4MG0tbb4o1H9d/JuS93aWXoR/7hlEH/jD9ld+mQ0AsKZltdn6h21pFQBd6wFQu/2HzWAvAIqyvnUOfXEeunxeUsTiLGcrq9zcXEsBn2spL+jv+p8Of0NffM9Svt3v5WF485M4knQxQ143bmZ6pkTEyM7icPkM5p+H+B8H/nUeFhH8JL6IL5RFRMumTCBMlrVbyBOIBZlChkD4n5r4D8P+pNm5lona+BHQllgCpSEaQH4eACgqESAJe2Qr0O99C8ZHA/nNi9GZmJ37z4L+fVe4TP7IFiR/jmNHRDK4ElHO7Jr8WgI0IABFQAPqQBvoAxPABLbAEbgAD+ADAkEoiARxYDHgghSQAUQgFxSAtaAYlIKtYCeoBnWgETSDNnAYdIFj4DQ4By6By2AE3AFSMA6egCnwCsxAEISFyBAVUod0IEPIHLKFWJAb5AMFQxFQHJQIJUNCSAIVQOugUqgcqobqoWboW+godBq6AA1Dt6BRaBL6FXoHIzAJpsFasBFsBbNgTzgIjoQXwcnwMjgfLoK3wJVwA3wQ7oRPw5fgEVgKP4GnEYAQETqiizARFsJGQpF4JAkRIauQEqQCaUDakB6kH7mKSJGnyFsUBkVFMVBMlAvKHxWF4qKWoVahNqOqUQdQnag+1FXUKGoK9RFNRmuizdHO6AB0LDoZnYsuRlegm9Ad6LPoEfQ4+hUGg6FjjDGOGH9MHCYVswKzGbMb0445hRnGjGGmsVisOtYc64oNxXKwYmwxtgp7EHsSewU7jn2DI+J0cLY4X1w8TogrxFXgWnAncFdwE7gZvBLeEO+MD8Xz8MvxZfhGfA9+CD+OnyEoE4wJroRIQiphLaGS0EY4S7hLeEEkEvWITsRwooC4hlhJPEQ8TxwlviVRSGYkNimBJCFtIe0nnSLdIr0gk8lGZA9yPFlM3kJuJp8h3ye/UaAqWCoEKPAUVivUKHQqXFF4pohXNFT0VFysmK9YoXhEcUjxqRJeyUiJrcRRWqVUo3RU6YbStDJV2UY5VDlDebNyi/IF5UcULMWI4kPhUYoo+yhnKGNUhKpPZVO51HXURupZ6jgNQzOmBdBSaaW0b2iDtCkVioqdSrRKnkqNynEVKR2hG9ED6On0Mvph+nX6O1UtVU9Vvuom1TbVK6qv1eaoeajx1UrU2tVG1N6pM9R91NPUt6l3qd/TQGmYaYRr5Grs0Tir8XQObY7LHO6ckjmH59zWhDXNNCM0V2ju0xzQnNbS1vLTytKq0jqj9VSbru2hnaq9Q/uE9qQOVcdNR6CzQ+ekzmOGCsOTkc6oZPQxpnQ1df11Jbr1uoO6M3rGelF6hXrtevf0Cfos/ST9Hfq9+lMGOgYhBgUGrQa3DfGGLMMUw12G/YavjYyNYow2GHUZPTJWMw4wzjduNb5rQjZxN1lm0mByzRRjyjJNM91tetkMNrM3SzGrMRsyh80dzAXmu82HLdAWThZCiwaLG0wS05OZw2xljlrSLYMtCy27LJ9ZGVjFW22z6rf6aG1vnW7daH3HhmITaFNo02Pzq62ZLde2xvbaXPJc37mr53bPfW5nbse322N3055qH2K/wb7X/oODo4PIoc1h0tHAMdGx1vEGi8YKY21mnXdCO3k5rXY65vTW2cFZ7HzY+RcXpkuaS4vLo3nG8/jzGueNueq5clzrXaVuDLdEt71uUnddd457g/sDD30PnkeTx4SnqWeq50HPZ17WXiKvDq/XbGf2SvYpb8Tbz7vEe9CH4hPlU+1z31fPN9m31XfKz95vhd8pf7R/kP82/xsBWgHcgOaAqUDHwJWBfUGkoAVB1UEPgs2CRcE9IXBIYMj2kLvzDecL53eFgtCA0O2h98KMw5aFfR+OCQ8Lrwl/GGETURDRv4C6YMmClgWvIr0iyyLvRJlESaJ6oxWjE6Kbo1/HeMeUx0hjrWJXxl6K04gTxHXHY+Oj45vipxf6LNy5cDzBPqE44foi40V5iy4s1licvvj4EsUlnCVHEtGJMYktie85oZwGzvTSgKW1S6e4bO4u7hOeB28Hb5Lvyi/nTyS5JpUnPUp2Td6ePJninlKR8lTAFlQLnqf6p9alvk4LTduf9ik9Jr09A5eRmHFUSBGmCfsytTPzMoezzLOKs6TLnJftXDYlChI1ZUPZi7K7xTTZz9SAxESyXjKa45ZTk/MmNzr3SJ5ynjBvYLnZ8k3LJ/J9879egVrBXdFboFuwtmB0pefK+lXQqqWrelfrry5aPb7Gb82BtYS1aWt/KLQuLC98uS5mXU+RVtGaorH1futbixWKRcU3NrhsqNuI2ijYOLhp7qaqTR9LeCUXS61LK0rfb+ZuvviVzVeVX33akrRlsMyhbM9WzFbh1uvb3LcdKFcuzy8f2x6yvXMHY0fJjpc7l+y8UGFXUbeLsEuyS1oZXNldZVC1tep9dUr1SI1XTXutZu2m2te7ebuv7PHY01anVVda926vYO/Ner/6zgajhop9mH05+x42Rjf2f836urlJo6m06cN+4X7pgYgDfc2Ozc0tmi1lrXCrpHXyYMLBy994f9Pdxmyrb6e3lx4ChySHHn+b+O31w0GHe4+wjrR9Z/hdbQe1o6QT6lzeOdWV0iXtjusePhp4tLfHpafje8vv9x/TPVZzXOV42QnCiaITn07mn5w+lXXq6enk02O9S3rvnIk9c60vvG/wbNDZ8+d8z53p9+w/ed71/LELzheOXmRd7LrkcKlzwH6g4wf7HzoGHQY7hxyHui87Xe4Znjd84or7ldNXva+euxZw7dLI/JHh61HXb95IuCG9ybv56Fb6ree3c27P3FlzF3235J7SvYr7mvcbfjT9sV3qID0+6j068GDBgztj3LEnP2X/9H686CH5YcWEzkTzI9tHxyZ9Jy8/Xvh4/EnWk5mnxT8r/1z7zOTZd794/DIwFTs1/lz0/NOvm1+ov9j/0u5l73TY9P1XGa9mXpe8UX9z4C3rbf+7mHcTM7nvse8rP5h+6PkY9PHup4xPn34D94Tz+49wZioAAAAJcEhZcwAALiMAAC4jAXilP3YAABANSURBVHic7dixDUBQAABREusoTGB1EygsxAaqS77IexNcfcuxbvcEAAB82n6d8+gGAADg3TI6AAAAAAAA/sBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAAcMdAAAAAAAChjsAAAAAAAQMdwAAAAAACBjuAAAAAAAQMNwBAAAAACBguAMAAAAAQMBwBwAAAACAgOEOAAAAAAABwx0AAAAAAAKGOwAAAAAABAx3AAAAAAAIGO4AAAAAABAw3AEAAAAAIGC4AwAAAABAwHAHAAAAAICA4Q4AAAAAAAHDHQAAAAAAAoY7AAAAAAAEDHcAAAAAAAgY7gAAAAAAEDDcAQAAAAAgYLgDAAAAAEDAcAcAAAAAgIDhDgAAAAAAgQcBzAvOvuFZogAAAABJRU5ErkJggg==",
                        o = e.speed ? e.speed : 5,
                        a = e.sinLength ? e.sinLength : 10,
                        s = 1;
                    e.lineType && ("curve" === e.lineType ? s = 1 : "straight" === e.lineType && (s = 0));
                    var l = h.default.addPath(t, i, r, a, n, s);
                    return l.name = "path", l.info.properties = {
                        speed: o
                    }, l
                }
            }, {
                key: "drawRoad",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                        n = arguments[4],
                        o = arguments[5];
                    if (t.length < 2) return console.error("start&end points is error!"), !1;
                    if (i instanceof Array) i.length < 2 && console.error("The path is error!");
                    else {
                        if (!(i instanceof Object && i.paths instanceof Array)) return console.error("The path is error!"), !1;
                        if (i.field && i.paths.length !== i.field.length) return console.error("The path is error!"), !1
                    }
                    var a = [],
                        s = [],
                        l = void 0,
                        h = [];
                    if (n) {
                        if (n instanceof Array) n.length < 2 && console.error("The path2 is error!");
                        else {
                            if (!(n instanceof Object && n.paths instanceof Array)) return console.error("The path2 is error!"), !1;
                            if (n.field && n.paths.length !== n.field.length) return console.error("The path2 is error!"), !1
                        }
                        var c = 1 / 0;
                        o instanceof Array || console.error("params 'elevators' format error."), s = o.slice();
                        for (var u = 0; u < o.length; u++) {
                            var p = f.default.findingPath([t[0][0], t[0][2]], s[u], i);
                            if (!p) return !1;
                            for (var d = 0, m = 0; m < p.length - 1; m++) d += f.default.getdistance1(p[m], p[m + 1]);
                            d < c && (c = d, l = u, a = p)
                        }
                        if (a.forEach(function (e) {
                                e[2] = e[1], e[1] = t[0][1]
                            }), a.pop(), !(h = f.default.findingPath(s[l], [t[1][0], t[1][2]], n))) return !1;
                        h.shift(), h.forEach(function (e) {
                            e[2] = e[1], e[1] = t[1][1]
                        }), a = a.concat(h)
                    } else {
                        var g = f.default.findingPath(t[0], t[1], i);
                        if (!g) return !1;
                        a.push.apply(a, g)
                    }
                    var v = this.type(r);
                    return v ? this[v](a, e) : this.drawLine(a, e)
                }
            }, {
                key: "drawArrow",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        i = e.color || 16711680,
                        r = e.height || 5,
                        n = void 0,
                        o = void 0,
                        a = e.lineType || !1,
                        s = e.dashSize || 3,
                        l = e.gapSize || 2,
                        h = new u.Mesh;
                    h.info = {};
                    for (var c = new u.LineDashedMaterial({
                            color: i,
                            scale: 1,
                            dashSize: s,
                            gapSize: l
                        }), p = 0; p < t.length - 1; p++) {
                        var f = new u.Vector3(t[p + 1][0] - t[p][0], 0, t[p + 1][1] - t[p][1]),
                            d = m.default.getdistance(t[p], t[p + 1]);
                        n = e.headLength || .2 * d, o = e.headWidth || .2 * n;
                        var g = new u.ArrowHelper(f, new u.Vector3(t[p][0], r, t[p][1]), d, i, n, o);
                        if (a) {
                            var v = new u.Geometry;
                            v.vertices.push(new u.Vector3(t[p][0], r, t[p][1])), v.vertices.push(new u.Vector3(t[p + 1][0], r, t[p + 1][1]));
                            var y = new u.Line(v, c);
                            y.computeLineDistances(), y.info = {}, g.children[0] = y
                        }
                        g.info = {}, g.children[0].info = {}, g.children[1].info = {}, h.add(g)
                    }
                    return h
                }
            }, {
                key: "drawMeshLine",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        i = e.lineColor ? e.lineColor : 15833878,
                        r = e.lineWidth ? e.lineWidth : 1,
                        n = e.height ? e.height : 10,
                        o = Boolean(e.direction),
                        a = h.default.addMeshLine(t, i, r, n, o);
                    return a.name = "meshLine", a
                }
            }, {
                key: "drawWordsFence",
                value: function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        i = e.height ? e.height : 10,
                        r = !!e.lineType && e.lineType,
                        n = e.str ? e.str : "",
                        o = e.imgUrl ? e.imgUrl : "",
                        a = this.getConfig(e);
                    t[0][0] == t[t.length - 1][0] && t[0][1] == t[t.length - 1][1] || t.push(t[0]);
                    var s = void 0;
                    if (n.length || o.length) {
                        var l = e.size || 24,
                            c = e.wordsPosition ? e.wordsPosition : [0, 0],
                            u = e.imgPosition ? e.imgPosition : [0, 0],
                            p = e.gap || .2,
                            f = e.imgWidth || 200,
                            d = e.imgHeight || 300;
                        s = h.default.addWordsFence(t, r, a, i, [n, l, c], [o, f, d, u], p)
                    } else s = h.default.drawFence(t, a);
                    return s.position.setY(i), s.name = "wordsFence", s
                }
            }, {
                key: "getConfig",
                value: function (t) {
                    var e = t.color ? t.color : 15833878,
                        i = t.opacity ? t.opacity : .2,
                        r = t.lineColor ? t.lineColor : 15833878,
                        n = t.dashSize ? t.dashSize : 3,
                        o = t.gapSize ? t.gapSize : 1,
                        a = [];
                    return a[0] = new u.MeshLambertMaterial({
                        color: e,
                        side: u.FrontSide,
                        transparent: !0,
                        opacity: i
                    }), a[1] = new u.LineBasicMaterial({
                        color: r
                    }), a[2] = new u.LineDashedMaterial({
                        color: r,
                        scale: 1,
                        dashSize: n,
                        gapSize: o
                    }), a
                }
            }, {
                key: "verdictFence",
                value: function (t, e) {
                    var i = [],
                        r = [],
                        n = [];
                    if (void 0 == this.fences[e]) return -2;
                    for (var o = this.fences[e], a = 0; a < o.length - 1; a++) {
                        if (i[a] = [o[a + 1][0] - o[a][0], o[a + 1][1] - o[a][1]], r[a] = [t[0] - o[a][0], t[1] - o[a][1]], n[a] = i[a][0] * r[a][1] - i[a][1] * r[a][0], 0 == n[a]) return 0;
                        if (n[0] * n[a] < 0) return -1
                    }
                    return 1
                }
            }, {
                key: "nearestPoint",
                value: function (t, e) {
                    var i, r = [],
                        n = 0,
                        o = [];
                    if (void 0 == this.fences[e]) return !1;
                    for (var a = this.fences[e], s = 0; s < a.length - 1; s++) r[s] = Math.sqrt(Math.pow(a[s][0] - t[0], 2) + Math.pow(a[s][1] - t[1], 2)), 0 == s && (i = r[s]), r[s] < i && (i = r[s], n = s);
                    o[0] = [t[0] - a[n][0], t[1] - a[n][1]], o[1] = [a[n + 1][0] - a[n][0], a[n + 1][1] - a[n][1]], o[2] = 0 == n ? [a[a.length - 2][0] - a[n][0], a[a.length - 2][1] - a[n][1]] : [a[n - 1][0] - a[n][0], a[n - 1][1] - a[n][1]];
                    var l, h = this.getdistance(t, a[n]),
                        c = this.getFootPoint(t, a[n], a[n + 1], 2);
                    return l = 0 == n ? this.getFootPoint(t, a[n], a[a.length - 2], 2) : this.getFootPoint(t, a[n], a[n - 1], 3), this.getmin(this.getmin(h, c), l)
                }
            }, {
                key: "getFootPoint",
                value: function (t, e, i) {
                    var r, n, o;
                    e[0] == i[0] ? (r = 1, n = 0, o = -e[0]) : e[1] == i[1] ? (r = 0, n = 1, o = -e[1]) : (r = 1 / (i[0] - e[0]), n = -1 / (i[1] - e[1]), o = e[1] / (i[1] - e[1]) - e[0] / (i[0] - e[0]));
                    var a = Math.sqrt(r * r + n * n);
                    r /= a, n /= a, o /= a;
                    var s = [];
                    s[0] = (n * n * t[0] - r * n * t[1] - r * o) / (r * r + n * n), s[1] = (-r * n * t[0] + r * r * t[1] - n * o) / (r * r + n * n);
                    var l = [e[0], i[0]].sort(this.sortNumber),
                        h = [e[1], i[1]].sort(this.sortNumber);
                    return s[0] >= l[0] && s[0] <= l[1] && s[1] >= h[0] && s[1] <= h[1] ? (s[2] = Math.abs(t[0] * r + t[1] * n + o), s) : (s[0] = e[0], s[1] = e[1], s[2] = Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])), s)
                }
            }, {
                key: "sortNumber",
                value: function (t, e) {
                    return t - e
                }
            }, {
                key: "getdistance",
                value: function (t, e) {
                    var i = [];
                    return i[0] = e[0], i[1] = e[1], i[3] = Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])), i
                }
            }, {
                key: "getmin",
                value: function (t, e) {
                    return t[2] < e[2] ? t : e
                }
            }, {
                key: "type",
                value: function () {
                    return ["drawLine", "drawPath", "drawMeshLine", "drawArrow"][arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1]
                }
            }]), t
        }());
    e.default = g
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(42),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = function () {
            function t(e, i) {
                if ((0, o.default)(this, t), !e) return void console.error("the first param of constructor of Heatmap is error");
                this.map = e, this.floorNum = i.floorNum ? i.floorNum : "F1", this.groupName = i.groupName ? i.groupName : "makerLineGroupxxxxx", this.height = i.height ? i.height : 10, this.lineType = !!i.height && i.lineType, this.color = i.color ? i.color : 15833878, this.opacity = i.opacity ? i.opacity : .2, this.lineColor = i.lineColor ? i.lineColor : 15833878, this.dashSize = i.dashSize ? i.dashSize : 3, this.gapSize = i.gapSize ? i.gapSize : 1, this.points = [], this.moveflag = !1, this.drawflag = !0;
                var r = this;
                this.map.event.on("move", function (t) {
                    if (r.drawflag && r.moveflag) {
                        var e = r.points.concat([
                            [t.position.x, t.position.z]
                        ]);
                        r.clearLayer();
                        var i = r.dynDrawLine(e);
                        r.addDrawToLayer(i)
                    }
                }), this.map.event.on("click", function (t) {
                    if (r.drawflag)
                        if (r.points && 0 != r.points.length) {
                            r.points.push([t.position.x, t.position.z]), r.clearLayer();
                            var e = r.dynDrawLine(r.points);
                            r.addDrawToLayer(e)
                        } else r.points = [
                            [t.position.x, t.position.z]
                        ], r.moveflag = !0
                })
            }
            return (0, s.default)(t, [{
                key: "dynDrawLine",
                value: function (t) {
                    var e = (arguments.length > 1 && void 0 !== arguments[1] && arguments[1], this.height ? this.height : 10),
                        i = !!this.lineType && this.lineType,
                        r = this.getConfig();
                    if (t && 1 != t.lenght) {
                        var n = h.default.dynDrawDirectionLine(t, r, i),
                            o = n.mesh;
                        return o.position.setY(e), o.name = "drawLine", o
                    }
                }
            }, {
                key: "addDrawToLayer",
                value: function (t) {
                    this.map.addToLayer(t, this.floorNum, this.groupName, !0)
                }
            }, {
                key: "clearLayer",
                value: function () {
                    this.map.clearLayer(this.floorNum, this.groupName, !0)
                }
            }, {
                key: "clearPoint",
                value: function () {
                    this.clearLayer(), this.points = []
                }
            }, {
                key: "startDraw",
                value: function () {
                    this.clearPoint(), this.clearLayer(), this.drawflag = !0
                }
            }, {
                key: "endDraw",
                value: function () {
                    this.clearPoint(), this.clearLayer(), this.drawflag = !1
                }
            }, {
                key: "deletePoints",
                value: function () {
                    if (this.points.length > 0 && (1 === this.points.length && (this.moveflag = !0), this.points.pop(), this.clearLayer(), 0 != this.points.length)) {
                        var t = this.dynDrawLine(this.points);
                        this.addDrawToLayer(t)
                    }
                }
            }, {
                key: "getPoint",
                value: function () {
                    console.warn(this.points)
                }
            }, {
                key: "setFloorNum",
                value: function (t) {
                    this.floorNum = t
                }
            }, {
                key: "setGroupName",
                value: function (t) {
                    this.groupName = t
                }
            }, {
                key: "getConfig",
                value: function () {
                    var t = this.color ? this.color : 15833878,
                        e = this.opacity ? this.opacity : .2,
                        i = this.lineColor ? this.lineColor : 15833878,
                        r = this.dashSize ? this.dashSize : 3,
                        n = this.gapSize ? this.gapSize : 1,
                        o = [];
                    return o[0] = new u.MeshLambertMaterial({
                        color: t,
                        side: u.FrontSide,
                        transparent: !0,
                        opacity: e
                    }), o[1] = new u.LineBasicMaterial({
                        color: i
                    }), o[2] = new u.LineDashedMaterial({
                        color: i,
                        scale: 1,
                        dashSize: r,
                        gapSize: n
                    }), o
                }
            }]), t
        }();
    e.default = p
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(42),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = function () {
            function t(e, i) {
                if ((0, o.default)(this, t), !e) return void console.error("the first param of constructor of Heatmap is error");
                this.map = e, this.floorNum = i.floorNum ? i.floorNum : "F1", this.groupName = i.groupName ? i.groupName : "makerFanceGroupxxxxx", this.height = i.height ? i.height : 5, this.color = i.color ? i.color : "#ffff00", this.opacity = i.opacity ? i.opacity : .5, this.lineColor = i.lineColor ? i.lineColor : "#ff0000", this.dashSize = i.dashSize ? i.dashSize : 3, this.gapSize = i.gapSize ? i.gapSize : 1, this.points = [], this.moveflag = !1, this.drawflag = !0;
                var r = this;
                this.map.event.on("move", function (t) {
                    if (r.drawflag && r.moveflag) {
                        var e = r.points.concat([
                            [t.position.x, t.position.z]
                        ]);
                        r.clearLayer();
                        var i = r.dynDrawFance(e);
                        r.addDrawToLayer(i)
                    }
                }), this.map.event.on("click", function (t) {
                    if (r.drawflag)
                        if (r.points && 0 != r.points.length)
                            if (1 == r.points.length) {
                                r.points.push([t.position.x, t.position.z]), r.clearLayer();
                                var e = r.dynDrawFance(r.points);
                                r.addDrawToLayer(e)
                            } else {
                                r.points.push([t.position.x, t.position.z]), r.clearLayer();
                                var e = r.dynDrawFance(r.points);
                                r.addDrawToLayer(e)
                            }
                    else r.points = [
                        [t.position.x, t.position.z]
                    ], r.moveflag = !0
                })
            }
            return (0, s.default)(t, [{
                key: "dynDrawFance",
                value: function (t) {
                    var e = this.getConfig(),
                        i = void 0;
                    i = t[0][0] != t[t.length - 1][0] || t[0][1] != t[t.length - 1][1] ? t.concat([t[0]]) : t;
                    var r = h.default.drawFence(i, e);
                    return r.position.setY(this.height), r.name = "wordsFence", r
                }
            }, {
                key: "addDrawToLayer",
                value: function (t) {
                    this.map.addToLayer(t, this.floorNum, this.groupName, !0)
                }
            }, {
                key: "clearLayer",
                value: function () {
                    this.map.clearLayer(this.floorNum, this.groupName, !0)
                }
            }, {
                key: "clearPoint",
                value: function () {
                    this.clearLayer(), this.points = []
                }
            }, {
                key: "startDraw",
                value: function () {
                    this.clearPoint(), this.clearLayer(), this.drawflag = !0
                }
            }, {
                key: "endDraw",
                value: function () {
                    this.clearPoint(), this.clearLayer(), this.drawflag = !1
                }
            }, {
                key: "deletePoints",
                value: function () {
                    if (this.points.length > 0 && (this.clearLayer(), 1 === this.points.length && (this.moveflag = !0), this.points.pop(), 0 != this.points.length)) {
                        var t = this.dynDrawFance(this.points);
                        this.addDrawToLayer(t)
                    }
                }
            }, {
                key: "setFloorNum",
                value: function (t) {
                    this.floorNum = t
                }
            }, {
                key: "setGroupName",
                value: function (t) {
                    this.groupName = t
                }
            }, {
                key: "getPoint",
                value: function () {
                    console.warn(this.points)
                }
            }, {
                key: "getConfig",
                value: function () {
                    var t = this.color,
                        e = this.opacity,
                        i = this.lineColor,
                        r = this.dashSize,
                        n = this.gapSize,
                        o = [];
                    return o[0] = new u.MeshLambertMaterial({
                        color: t,
                        side: u.FrontSide,
                        transparent: !0,
                        opacity: e
                    }), o[1] = new u.LineBasicMaterial({
                        color: i
                    }), o[2] = new u.LineDashedMaterial({
                        color: i,
                        scale: 1,
                        dashSize: r,
                        gapSize: n
                    }), o
                }
            }]), t
        }();
    e.default = p
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    var n = i(9),
        o = r(n),
        a = i(2),
        s = r(a),
        l = i(3),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = function () {
            function t() {
                (0, s.default)(this, t)
            }
            return (0, h.default)(t, [{
                key: "drawMonitor",
                value: function (t, e) {
                    var i = t.direction ? t.direction : 0,
                        r = t.arc ? t.arc : 60,
                        n = Boolean(t.surround);
                    if (r <= 0 || r > 360) return void console.error("the angle must be in range from 0 to 360!");
                    var o = new u.Mesh,
                        a = {
                            id: o.id,
                            drawType: {
                                func: "drawMonitor",
                                type: "vidicon"
                            },
                            splicing: o.id
                        };
                    if (n) {
                        var s = t.sector[0].length,
                            l = r / 1;
                        if (s) {
                            var h = this.drawCircular(l, r, t.sector[0]);
                            h.info = a, o.add(h)
                        }
                        for (var c = s || 0, p = 1; p < t.sector.length; p++)
                            if (t.sector[p].length) {
                                var f = this.drawRing(c, r, 1, t.sector[p]);
                                f.info = a, o.add(f), c += t.sector[p].length
                            } var d = this.drawEdge(c, r, 1);
                        d.info = a, o.add(d), o.rotation.z = i * Math.PI * 2 / 360, o.rotation.x = Math.PI / 2
                    }
                    var m = void 0;
                    if (t.imgUrl) {
                        m = t.imgUrl;
                        var g = (new u.TextureLoader).load(m),
                            v = new u.SpriteMaterial({
                                map: g,
                                color: 16777215,
                                transparent: !1
                            }),
                            y = t.size || 2;
                        y > 10 && (y = 10), y < 2 && (y = 2);
                        var A = new u.Sprite(v);
                        A.scale.set(y, y, y), A.position.setZ(y / 2), A.info = a, o.add(A)
                    }
                    return o.position.set(e[0], e[1], e[2]), o.name = t.name || "vidicon", o.info = a, o
                }
            }, {
                key: "drawCircular",
                value: function (t, e, i) {
                    var r = new u.MeshToonMaterial({
                            color: i.color || "#ff0000",
                            side: u.DoubleSide,
                            transparent: !0,
                            opacity: i.opacity || "0.2"
                        }),
                        n = i.length || 2,
                        o = new u.CircleGeometry(n, t, 0, e * Math.PI * 2 / 360);
                    return new u.Mesh(o, r)
                }
            }, {
                key: "drawRing",
                value: function (t, e, i, r) {
                    var n = i,
                        o = Math.floor(e / n),
                        a = t + r.length,
                        s = r.color || "#ff0000",
                        l = r.opacity || .2,
                        h = new u.Shape;
                    h.moveTo(t, 0);
                    for (var c = 0; c < o; c++) h.lineTo(a * Math.cos(n * c * Math.PI * 2 / 360), a * Math.sin(n * c * Math.PI * 2 / 360));
                    h.lineTo(a * Math.cos(e * Math.PI * 2 / 360), a * Math.sin(e * Math.PI * 2 / 360));
                    for (var p = 0; p < o; p++) h.lineTo(t * Math.cos((e - n * p) * Math.PI * 2 / 360), t * Math.sin((e - n * p) * Math.PI * 2 / 360));
                    h.lineTo(t, 0);
                    var f = new u.MeshBasicMaterial({
                            color: s,
                            side: u.DoubleSide,
                            transparent: !0,
                            opacity: l
                        }),
                        d = new u.ShapeGeometry(h);
                    return new u.Mesh(d, f)
                }
            }, {
                key: "drawEdge",
                value: function (t, e, i) {
                    var r = i,
                        n = Math.floor(e / r),
                        o = new u.Geometry;
                    360 !== e && o.vertices.push(new u.Vector3(0, 0, 0));
                    for (var a = 0; a <= n; a++) o.vertices.push(new u.Vector3(t * Math.cos((e - r * a) * Math.PI * 2 / 360), t * Math.sin((e - r * a) * Math.PI * 2 / 360)));
                    return 360 !== e && o.vertices.push(new u.Vector3(0, 0, 0)), new u.Line(o, new u.LineBasicMaterial({
                        color: "#000000"
                    }))
                }
            }, {
                key: "updateMonitor",
                value: function (t, e) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                    if (e && "{}" !== (0, o.default)(e)) {
                        var r = t.info;
                        t.children = [];
                        var n = e.direction ? e.direction : 0,
                            a = e.arc ? e.arc : 60,
                            s = Boolean(e.surround);
                        if (a <= 0 || a > 360) return void console.error("the angle must be in range from 0 to 360!");
                        if (s) {
                            var l = e.sector[0].length,
                                h = a / 1;
                            if (l) {
                                var c = this.drawCircular(h, a, e.sector[0]);
                                c.info = r, t.add(c)
                            }
                            for (var p = l || 0, f = 1; f < e.sector.length; f++)
                                if (e.sector[f].length) {
                                    var d = this.drawRing(p, a, 1, e.sector[f]);
                                    d.info = r, t.add(d), p += e.sector[f].length
                                } var m = this.drawEdge(p, a, 1);
                            m.info = r, t.add(m), t.rotation.z = n * Math.PI * 2 / 360, t.rotation.x = Math.PI / 2
                        }
                        var g = void 0;
                        if (e.imgUrl) {
                            g = e.imgUrl;
                            var v = (new u.TextureLoader).load(g),
                                y = new u.SpriteMaterial({
                                    map: v,
                                    color: 16777215,
                                    transparent: !1
                                }),
                                A = NaN;
                            A > 10 && (A = 10), A < 2 && (A = 2);
                            var x = new u.Sprite(y);
                            x.scale.set(A, A, A), x.position.setZ(A / 2), x.info = r, t.add(x)
                        }
                        t.name = e.name || t.name
                    }
                    3 === i.length && t.position.set(i[0], i[1], i[2])
                }
            }]), t
        }();
    t.exports = p
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(4),
        h = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(l),
        c = i(43),
        u = r(c),
        p = i(21),
        f = function () {
            function t(e) {
                (0, o.default)(this, t), this.imageMarker(this.set(e)), this.sprite = {}
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.dom = t.dom ? t.dom : void 0, t.imgMarker = t.imgMarker ? t.imgMarker : void 0, t.styleSheet = t.styleSheet ? t.styleSheet : void 0, t.info = t.info ? t.info : void 0, t.color = t.color || "0xffffff", t.lnglat = t.lnglat ? t.lnglat : void 0, t.mapCenter = t.mapCenter ? t.mapCenter : void 0, t.position = t.position ? t.position : void 0, t.name = t.name || "imageMarker", t.size = t.size || 3, t.y = t.y || 2, t.userData = t.userData || {}, t.center = t.center || [.5, .5], t
                }
            }, {
                key: "imageMarker",
                value: function (t) {
                    function e() {
                        var e = void 0,
                            i = void 0;
                        if (t.info) {
                            var o = t.info;
                            i = document.createElement("canvas");
                            var a = i.getContext("2d");
                            a.font = "30px Calibri";
                            var s = a.measureText(o);
                            s.width < 80 ? (i.style.width = "80px", i.width = 80) : (i.style.width = s.width + "px", i.width = s.width), i.style.height = "120px", i.height = 120, a.lineWidth = 4, a.textBaseline = "top", a.fillStyle = "#000", a.font = "30px Calibri", s.width < 80 ? (a.fillText(o, 40 - s.width / 2, 0), a.drawImage(n, 0, 42, 80, 80)) : (a.fillText(o, 0, 0), a.drawImage(n, s.width / 2 - 40, 42, 80, 80)), e = new h.CanvasTexture(i)
                        } else e = (new h.TextureLoader).load(r);
                        var l = i ? i.width / i.height : 1,
                            c = new h.SpriteMaterial({
                                map: e,
                                color: t.color,
                                transparent: !1
                            }),
                            u = new h.Sprite(c);
                        u.name = t.name;
                        var f = t.size;
                        if (u.scale.set(f * l, f, f), u.center = new h.Vector2(t.center[0], t.center[1]), t.lnglat && t.mapCenter) {
                            var d = (0, p.coordinatesToMercato)({
                                coordinates: t.lnglat,
                                mapCenter: (0, p.coordinateToMercato)(t.mapCenter)
                            });
                            u.position.set(d[0], t.y, d[1])
                        } else {
                            if (!t.position) return console.error("mapError:lnglator mapCenter or position undefined"), null;
                            u.position.set(t.position.x, t.position.y, t.position.z)
                        }
                        var m = {
                            id: u.id,
                            size: {
                                x: t.size * l,
                                y: t.size,
                                z: t.size
                            },
                            drawType: {
                                func: "imageMarker",
                                type: "marker"
                            },
                            properties: {
                                mapCenter: [0, 0],
                                userData: t.userData
                            }
                        };
                        return u.info = m, u
                    }
                    var i = this,
                        r = void 0,
                        n = new Image;
                    if (t.dom) {
                        var o = t.dom.cloneNode(!0);
                        o.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
                        t.styleSheet && u.default.get(t.styleSheet).then(function (a) {
                            r = 'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="\n                        ' + t.dom.style.width.replace(/px/, "") + ' " height=" ' + t.dom.style.height.replace(/px/, "") + ' "><foreignObject x="0" y="0" width="100%" height="100%"> \n                            ' + (new XMLSerializer).serializeToString(o).replace(/#/g, "%23").replace(/\n/g, "%0A") + " \n                            <style> " + a + " </style></foreignObject></svg>", n.src = r, n.onload = function (r) {
                                var n = e();
                                i.sprite = n, t.callback.call(i, n)
                            }
                        })
                    } else t.imgMarker ? (r = t.imgMarker, n.src = r, n.onload = function (r) {
                        var n = e();
                        i.sprite = n, t.callback.call(i, n)
                    }) : console.error("icon address error!")
                }
            }]), t
        }();
    e.default = f
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(2),
        o = r(n),
        a = i(3),
        s = r(a),
        l = i(4),
        h = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(l),
        c = i(43),
        u = (r(c), i(21)),
        p = function () {
            function t(e) {
                return (0, o.default)(this, t), this.TextMarker(this.set(e))
            }
            return (0, s.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.text = t.text ? t.text : "", t.color = t.color || "#000", t.zoom = t.zoom || 1, t.lnglat = t.lnglat ? t.lnglat : void 0, t.mapCenter = t.mapCenter ? t.mapCenter : void 0, t.position = t.position ? t.position : void 0, t.name = t.name || "TextMarker", t.size = t.size || 3, t.y = t.y || 2, t.userData = t.userData || {}, t.center = t.center || [.5, .5], t
                }
            }, {
                key: "TextMarker",
                value: function (t) {
                    function e(e) {
                        if (t.text) {
                            var i = void 0,
                                r = void 0,
                                n = t.text,
                                o = document.createElement("canvas"),
                                a = o.getContext("2d");
                            a.font = "40px Calibri";
                            var s = a.measureText(n);
                            o.style.width = s.width + "px", o.style.height = "40px", o.width = s.width, o.height = 40, a.lineWidth = 4, a.textAlign = "left", a.textBaseline = "middle", a.fillStyle = "#000";
                            var l = void 0;
                            a.font = "40px Calibri";
                            var c = a.createPattern(e, "repeat");
                            if (a.strokeStyle = c, a.strokeText(n, 0, o.height / 2), a.fillStyle = t.color, a.fillText(n, 0, o.height / 2), i = new h.CanvasTexture(o), r = new h.SpriteMaterial({
                                    map: i,
                                    transparent: !0,
                                    opacity: 1
                                }), l = new h.Sprite(r), l.scale.set(s.width / 40 * t.zoom, 1 * t.zoom, 2 * t.zoom), l.center = new h.Vector2(t.center[0], t.center[1]), t.lnglat && t.mapCenter) {
                                var p = (0, u.coordinatesToMercato)({
                                    coordinates: t.lnglat,
                                    mapCenter: (0, u.coordinateToMercato)(t.mapCenter)
                                });
                                l.position.set(p[0], t.y, p[1])
                            } else {
                                if (!t.position) return void console.error("position is not defined");
                                l.position.set(t.position.x, t.position.y, t.position.z)
                            }
                            var f = {
                                id: l.id,
                                scale: {
                                    x: s.width / 40 * t.zoom,
                                    y: 1 * t.zoom,
                                    z: 2 * t.zoom
                                },
                                drawType: {
                                    func: "TextMarker",
                                    type: "Marker"
                                },
                                properties: {
                                    mapCenter: [0, 0],
                                    userData: t.userData
                                }
                            };
                            return l.info = f, l
                        }
                    }
                    var i = this;
                    (new h.ImageLoader).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAMAAABFaP0WAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRF////AAAAVcLTfgAAAA5JREFUeNpiYAABgAADAAAGAAHgQhFOAAAAAElFTkSuQmCC", function (r) {
                        var n = e(r);
                        t.callback.call(i, n)
                    })
                }
            }]), t
        }();
    e.default = p
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(39),
        o = r(n),
        a = i(2),
        s = r(a),
        l = i(3),
        h = r(l),
        c = i(4),
        u = function (t) {
            if (t && t.__esModule) return t;
            var e = {};
            if (null != t)
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e.default = t, e
        }(c),
        p = i(43),
        f = (r(p), i(219)),
        d = r(f),
        m = function () {
            function t(e, i) {
                if ((0, s.default)(this, t), !e) return void console.error("the first param of constructor of Heatmap is error");
                this.map = e, this.loader = new u.TextureLoader, this.config = this.set(i), this.createHeatmap(this.config), this.config.legend.show && this.addDom()
            }
            return (0, h.default)(t, [{
                key: "set",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return t.data = t.data ? t.data : {}, t.floorName = t.floorName ? t.floorName : map.floors[0], t.layerName = t.layerName ? t.layerName : "heatmapLayer", t.gradient = t.gradient ? t.gradient : {
                        .15: "rgb(0,145,255)",
                        .35: "rgb(0,0,255)",
                        .65: "rgb(0,255,0)",
                        .85: "yellow",
                        .95: "rgb(255,0,0)"
                    }, t.radius = t.radius ? t.radius : 6, t.maxOpacity = t.maxOpacity ? t.maxOpacity : 1, t.minOpacity = t.minOpacity ? t.minOpacity : 0, t.blur = t.blur ? t.blur : .85, t.xField = t.xField ? t.xField : "x", t.yField = t.yField ? t.yField : "y", t.valueField = t.valueField ? t.valueField : "value", t.legend = t.legend ? (0, o.default)({}, {
                        left: "100px",
                        bottom: "100px",
                        fontSize: "14px",
                        show: !0
                    }, t.legend) : {
                        left: "100px",
                        bottom: "100px",
                        fontSize: "14px",
                        show: !0
                    }, t
                }
            }, {
                key: "addDom",
                value: function () {
                    var t = document.createElement("div");
                    t.setAttribute("class", "AirocovHeatmap"), t.style.position = "absolute", t.style.left = this.config.legend.left, t.style.bottom = this.config.legend.bottom, this.config.legend.right && (t.style.right = this.config.legend.right), this.config.legend.top && (t.style.top = this.config.legend.top), this.map.dom.appendChild(t);
                    var e = this.config.gradient,
                        i = this.config.legend.fontSize,
                        r = 0,
                        n = 0,
                        o = [];
                    for (var a in e) e.hasOwnProperty(a) && (n > 0 && (o[n - 1] = document.createElement("div"), o[n - 1].setAttribute("id", "AirocovHeatmapItem-" + (n - 1)), o[n - 1].style.fontSize = i, o[n - 1].style.lineHeight = i, o[n - 1].style.marginBottom = "5px", o[n - 1].innerHTML = r + " ~ " + a, document.styleSheets[0].insertRule("#AirocovHeatmapItem-" + (n - 1) + '::before { \n                        content: "";\n                        margin-right: 10px;\n                        border-radius: 3px;\n                        display: inline-block;\n                        width: 20px;\n                        height: ' + i + ";\n                        background: " + e[a] + "\n                    }", 0)), r = a, n++);
                    o[n - 1] = document.createElement("div"), o[n - 1].setAttribute("id", "AirocovHeatmapItem-" + (n - 1)), o[n - 1].style.fontSize = i, o[n - 1].style.lineHeight = i, o[n - 1].style.marginBottom = "5px", o[n - 1].innerHTML = r + " ~ 1", document.styleSheets[0].insertRule("#AirocovHeatmapItem-" + (n - 1) + '::before { \n            content: "";\n            margin-right: 10px;\n            border-radius: 3px;\n            display: inline-block;\n            width: 20px;\n            height: ' + i + ";\n            background: " + e[r] + "\n        }", 0), t.appendChild(o[n - 1]);
                    for (var s = o.length - 1; s >= 0; s--) t.appendChild(o[s])
                }
            }, {
                key: "clearDom",
                value: function () {
                    for (var t = 0; t < this.map.dom.children.length; t++) "AirocovHeatmap" == this.map.dom.children[t].className && this.map.dom.removeChild(this.map.dom.children[t])
                }
            }, {
                key: "createHeatmap",
                value: function (t) {
                    this.destroy();
                    for (var e = 0, i = this.map.extremum[t.floorName].l / 200 < 1 ? this.map.extremum[t.floorName].l : this.map.extremum[t.floorName].l / 200, r = 10 * this.map.extremum[t.floorName].l / i, n = 10 * this.map.extremum[t.floorName].w / i, o = t.data, a = new d.default({
                            width: r,
                            height: n,
                            radius: 10 * t.radius,
                            gradient: t.gradient,
                            maxOpacity: t.maxOpacity,
                            minOpacity: t.minOpacity,
                            blur: t.blur,
                            xField: t.xField,
                            yField: t.yField,
                            valueField: t.valueField
                        }), s = 0; s < o.length; s++) o[s].value > e && (e = o[s].value), o[s].x *= 10, o[s].y *= 10, o[s].x -= 10 * this.map.extremum[t.floorName].xExtremum[0] / i, o[s].y -= 10 * this.map.extremum[t.floorName].yExtremum[0] / i;
                    a.setData({
                        max: e,
                        data: o
                    }), console.warn(r), console.warn(n), console.warn(10 * t.radius), console.warn(t.opacity), console.warn(t.gradient), console.warn(t.maxOpacity), console.warn(t.minOpacity), console.warn(t.blur), console.warn(t.xField), console.warn(t.yField), console.warn(t.valueField), console.warn(e), console.warn(o), this.heatmapInstance = a, this.createplane(a.getDataURL(), t)
                }
            }, {
                key: "createplane",
                value: function (t, e) {
                    var i = this;
                    this.loader.load(t, function (t) {
                        t.needsUpdate = !0;
                        var r = new u.PlaneGeometry(i.map.extremum[e.floorName].l, i.map.extremum[e.floorName].w),
                            n = new u.Mesh(r, new u.MeshLambertMaterial({
                                map: t,
                                side: u.FrontSide,
                                transparent: !0,
                                depthWrite: !1,
                                depthTest: !1
                            }));
                        n.material.needsUpdate = !0, n.renderOrder = 2, n.rotation.x = -Math.PI / 2, n.position.y = 0, n.position.x = i.map.extremum[e.floorName].l / 2 + i.map.extremum[e.floorName].xExtremum[0], n.position.z = i.map.extremum[e.floorName].w / 2 + i.map.extremum[e.floorName].yExtremum[0];
                        var o = {
                            drawType: {
                                func: "heatmapMarker",
                                type: "heatmap"
                            },
                            properties: {
                                mapCenter: [0, 0]
                            }
                        };
                        n.info = o, i.heatmapMesh = n, i.planeMesh = i.map.addToLayer(n, e.floorName, e.layerName), e.callback.call(i, i.heatmapInstance)
                    })
                }
            }, {
                key: "setData",
                value: function (t) {
                    var e = 0;
                    if (t)
                        for (var i = 0; i < t.length; i++) t[i].value > e && (e = t[i].value), t[i].x *= 10, t[i].y *= 10, t[i].x -= 10 * this.map.extremum[this.config.floorName].xExtremum[0], t[i].y -= 10 * this.map.extremum[this.config.floorName].yExtremum[0];
                    else t = [];
                    this.heatmapInstance.setData({
                        max: e,
                        data: t
                    });
                    var r = this;
                    this.loader.load(this.heatmapInstance.getDataURL(), function (t) {
                        r.heatmapMesh.material.map = t
                    })
                }
            }, {
                key: "addData",
                value: function (t) {
                    for (var e = 0; e < t.length; e++) t[e].x *= 10, t[e].y *= 10, t[e].x -= 10 * this.map.extremum[this.config.floorName].xExtremum[0], t[e].y -= 10 * this.map.extremum[this.config.floorName].yExtremum[0];
                    this.heatmapInstance.addData(t);
                    var i = this;
                    this.loader.load(this.heatmapInstance.getDataURL(), function (t) {
                        i.heatmapMesh.material.map = t
                    })
                }
            }, {
                key: "clear",
                value: function () {
                    this.setData()
                }
            }, {
                key: "destroy",
                value: function () {
                    this.clearDom(), this.map.clearLayer(this.config.floorName, this.config.layerName)
                }
            }, {
                key: "show",
                value: function () {
                    this.heatmapMesh.visible = !0
                }
            }, {
                key: "hide",
                value: function () {
                    this.heatmapMesh.visible = !1
                }
            }]), t
        }();
    e.default = m
}, function (t, e, i) {
    "use strict";

    function r(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(44),
        o = r(n),
        a = i(2),
        s = r(a),
        l = i(3),
        h = r(l),
        c = {
            defaultRadius: 6,
            defaultGradient: {
                .15: "rgb(0,145,255)",
                .35: "rgb(0,0,255)",
                .65: "rgb(0,255,0)",
                .85: "yellow",
                .95: "rgb(255,0,0)"
            },
            defaultMaxOpacity: 1,
            defaultMinOpacity: 0,
            defaultBlur: .85,
            defaultXField: "x",
            defaultYField: "y",
            defaultValueField: "value",
            width: 100,
            height: 60
        },
        u = function () {
            function t(e) {
                (0, s.default)(this, t), this._config = this.mergeConfig(e), this._coordinator = new p, this._renderer = new f(this._config), this._store = new d(this._config), this._connect()
            }
            return (0, h.default)(t, [{
                key: "mergeConfig",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        e = {};
                    for (var i in c) e[i] = c[i];
                    for (var r in t) e[r] = t[r];
                    return e
                }
            }, {
                key: "_connect",
                value: function () {
                    var t = this._renderer,
                        e = this._coordinator,
                        i = this._store,
                        r = this;
                    e.on("renderpartial", t.renderPartial, t), e.on("renderall", t.renderAll, t), e.on("extremachange", function (t) {
                        r._config.onExtremaChange && r._config.onExtremaChange({
                            min: t.min,
                            max: t.max,
                            gradient: r._config.gradient || r._config.defaultGradient
                        })
                    }), i.setCoordinator(e)
                }
            }, {
                key: "addData",
                value: function () {
                    return this._store.addData.apply(this._store, arguments), this
                }
            }, {
                key: "removeData",
                value: function () {
                    return this._store.removeData && this._store.removeData.apply(this._store, arguments), this
                }
            }, {
                key: "setData",
                value: function () {
                    return this._store.setData.apply(this._store, arguments), this
                }
            }, {
                key: "setDataMax",
                value: function () {
                    return this._store.setDataMax.apply(this._store, arguments), this
                }
            }, {
                key: "setDataMin",
                value: function () {
                    return this._store.setDataMin.apply(this._store, arguments), this
                }
            }, {
                key: "configure",
                value: function (t) {
                    return this._config = Util.merge(this._config, t), this._renderer.updateConfig(this._config), this._coordinator.emit("renderall", this._store._getInternalData()), this
                }
            }, {
                key: "repaint",
                value: function () {
                    return this._coordinator.emit("renderall", this._store._getInternalData()), this
                }
            }, {
                key: "getData",
                value: function () {
                    return this._store.getData()
                }
            }, {
                key: "getDataURL",
                value: function () {
                    return this._renderer.getDataURL()
                }
            }, {
                key: "getValueAt",
                value: function (t) {
                    return this._store.getValueAt ? this._store.getValueAt(t) : this._renderer.getValueAt ? this._renderer.getValueAt(t) : null
                }
            }]), t
        }(),
        p = function () {
            function t() {
                (0, s.default)(this, t), this.cStore = {}
            }
            return (0, h.default)(t, [{
                key: "on",
                value: function (t, e, i) {
                    var r = this.cStore;
                    r[t] || (r[t] = []), r[t].push(function (t) {
                        return e.call(i, t)
                    })
                }
            }, {
                key: "emit",
                value: function (t, e) {
                    var i = this.cStore;
                    if (i[t])
                        for (var r = i[t].length, n = 0; n < r; n++) {
                            var o = i[t][n];
                            o(e)
                        }
                }
            }]), t
        }(),
        f = function () {
            function t(e) {
                (0, s.default)(this, t);
                var i = this.shadowCanvas = document.createElement("canvas"),
                    r = this.canvas = e.canvas || document.createElement("canvas");
                this._renderBoundaries = [1e4, 1e4, 0, 0];
                r.className = "heatmap-canvas", this._width = r.width = i.width = e.width, this._height = r.height = i.height = e.height, this.shadowCtx = i.getContext("2d"), this.ctx = r.getContext("2d"), this._palette = this._getColorPalette(e), this._templates = {}, this._setStyles(e)
            }
            return (0, h.default)(t, [{
                key: "_getColorPalette",
                value: function (t) {
                    var e = t.gradient || t.defaultGradient,
                        i = document.createElement("canvas"),
                        r = i.getContext("2d");
                    i.width = 256, i.height = 1;
                    var n = r.createLinearGradient(0, 0, 256, 1);
                    for (var o in e) n.addColorStop(o, e[o]);
                    return r.fillStyle = n, r.fillRect(0, 0, 256, 1), r.getImageData(0, 0, 256, 1).data
                }
            }, {
                key: "_getPointTemplate",
                value: function (t, e) {
                    var i = document.createElement("canvas"),
                        r = i.getContext("2d"),
                        n = t,
                        o = t;
                    if (i.width = i.height = 2 * t, 1 == e) r.beginPath(), r.arc(n, o, t, 0, 2 * Math.PI, !1), r.fillStyle = "rgba(0,0,0,1)", r.fill();
                    else {
                        var a = r.createRadialGradient(n, o, t * e, n, o, t);
                        a.addColorStop(0, "rgba(0,0,0,1)"), a.addColorStop(1, "rgba(0,0,0,0)"), r.fillStyle = a, r.fillRect(0, 0, 2 * t, 2 * t)
                    }
                    return i
                }
            }, {
                key: "_prepareData",
                value: function (t) {
                    for (var e = [], i = t.min, r = t.max, n = t.radi, a = t.data, s = (0, o.default)(a), l = s.length; l--;)
                        for (var h = s[l], c = (0, o.default)(a[h]), u = c.length; u--;) {
                            var p = c[u],
                                f = a[h][p],
                                d = n[h][p];
                            e.push({
                                x: h,
                                y: p,
                                value: f,
                                radius: d
                            })
                        }
                    return {
                        min: i,
                        max: r,
                        data: e
                    }
                }
            }, {
                key: "renderPartial",
                value: function (t) {
                    this._drawAlpha(t), this._colorize()
                }
            }, {
                key: "renderAll",
                value: function (t) {
                    this._clear(), this._drawAlpha(this._prepareData(t)), this._colorize()
                }
            }, {
                key: "_updateGradient",
                value: function (t) {
                    this._palette = _getColorPalette(t)
                }
            }, {
                key: "updateConfig",
                value: function (t) {
                    t.gradient && this._updateGradient(t), this._setStyles(t)
                }
            }, {
                key: "setDimensions",
                value: function (t, e) {
                    this._width = t, this._height = e, this.canvas.width = this.shadowCanvas.width = t, this.canvas.height = this.shadowCanvas.height = e
                }
            }, {
                key: "_clear",
                value: function () {
                    this.shadowCtx.clearRect(0, 0, 500, 300), this.ctx.clearRect(0, 0, 500, 300)
                }
            }, {
                key: "_setStyles",
                value: function (t) {
                    this._blur = 0 == t.blur ? 0 : t.blur || t.defaultBlur, t.backgroundColor && (this.canvas.style.backgroundColor = t.backgroundColor), this._opacity = 255 * (t.opacity || 0), this._maxOpacity = 255 * (t.maxOpacity || t.defaultMaxOpacity), this._minOpacity = 255 * (t.minOpacity || t.defaultMinOpacity), this._useGradientOpacity = !!t.useGradientOpacity
                }
            }, {
                key: "_drawAlpha",
                value: function (t) {
                    for (var e = this._min = t.min, i = this._max = t.max, r = t.data || [], n = r.length, o = 1 - this._blur; n--;) {
                        var a = r[n],
                            s = a.x,
                            l = a.y,
                            h = a.radius,
                            c = Math.min(a.value, i),
                            u = s - h,
                            p = l - h,
                            f = this.shadowCtx,
                            d = void 0;
                        this._templates[h] ? d = this._templates[h] : this._templates[h] = d = this._getPointTemplate(h, o), f.globalAlpha = c / Math.abs(i - e), f.drawImage(d, u, p), u < this._renderBoundaries[0] && (this._renderBoundaries[0] = u), p < this._renderBoundaries[1] && (this._renderBoundaries[1] = p), u + 2 * h > this._renderBoundaries[2] && (this._renderBoundaries[2] = u + 2 * h), p + 2 * h > this._renderBoundaries[3] && (this._renderBoundaries[3] = p + 2 * h)
                    }
                }
            }, {
                key: "_colorize",
                value: function () {
                    var t = this._renderBoundaries[0],
                        e = this._renderBoundaries[1],
                        i = this._renderBoundaries[2] - t,
                        r = this._renderBoundaries[3] - e,
                        n = this._width,
                        o = this._height,
                        a = this._opacity,
                        s = this._maxOpacity,
                        l = this._minOpacity,
                        h = this._useGradientOpacity;
                    t < 0 && (t = 0), e < 0 && (e = 0), t + i > n && (i = n - t), e + r > o && (r = o - e);
                    for (var c = this.shadowCtx.getImageData(t, e, 500, 300), u = c.data, p = c.data.length, f = this._palette, d = 3; d < p; d += 4) {
                        var m = u[d],
                            g = 4 * m;
                        if (g) {
                            var v = void 0;
                            v = a > 0 ? a : m < s ? m < l ? l : m : s, u[d - 3] = f[g], u[d - 2] = f[g + 1], u[d - 1] = f[g + 2], u[d] = h ? f[g + 3] : v
                        }
                    }
                    this.ctx.putImageData(c, t, e), this._renderBoundaries = [1e3, 1e3, 0, 0]
                }
            }, {
                key: "getValueAt",
                value: function (t) {
                    var e = this.shadowCtx,
                        i = e.getImageData(t.x, t.y, 1, 1),
                        r = i.data[3],
                        n = this._max,
                        o = this._min;
                    return Math.abs(n - o) * (r / 255) >> 0
                }
            }, {
                key: "getDataURL",
                value: function () {
                    return this.canvas.toDataURL()
                }
            }]), t
        }(),
        d = function () {
            function t(e) {
                (0, s.default)(this, t), this._coordinator = {}, this._data = [], this._radi = [], this._min = 0, this._max = 1, this._xField = e.xField || e.defaultXField, this._yField = e.yField || e.defaultYField, this._valueField = e.valueField || e.defaultValueField, e.radius && (this._cfgRadius = e.radius)
            }
            return (0, h.default)(t, [{
                key: "_organiseData",
                value: function (t, e) {
                    var i = t[this._xField],
                        r = t[this._yField],
                        n = this._radi,
                        o = this._data,
                        a = this._max,
                        s = this._min,
                        l = t[this._valueField] || 1,
                        h = t.radius || this._cfgRadius || c.defaultRadius;
                    return o[i] || (o[i] = [], n[i] = []), o[i][r] ? o[i][r] += l : (o[i][r] = l, n[i][r] = h), o[i][r] > a ? (e ? this.setDataMax(o[i][r]) : this._max = o[i][r], !1) : {
                        x: i,
                        y: r,
                        value: l,
                        radius: h,
                        min: s,
                        max: a
                    }
                }
            }, {
                key: "_unOrganizeData",
                value: function () {
                    var t = [],
                        e = this._data,
                        i = this._radi;
                    for (var r in e)
                        for (var n in e[r]) t.push({
                            x: r,
                            y: n,
                            radius: i[r][n],
                            value: e[r][n]
                        });
                    return {
                        min: this._min,
                        max: this._max,
                        data: t
                    }
                }
            }, {
                key: "_onExtremaChange",
                value: function () {
                    this._coordinator.emit("extremachange", {
                        min: this._min,
                        max: this._max
                    })
                }
            }, {
                key: "addData",
                value: function () {
                    if (arguments[0].length > 0)
                        for (var t = arguments[0], e = t.length; e--;) this.addData.call(this, t[e]);
                    else {
                        var i = this._organiseData(arguments[0], !0);
                        i && this._coordinator.emit("renderpartial", {
                            min: this._min,
                            max: this._max,
                            data: [i]
                        })
                    }
                    return this
                }
            }, {
                key: "setData",
                value: function (t) {
                    var e = t.data,
                        i = e.length;
                    this._data = [], this._radi = [];
                    for (var r = 0; r < i; r++) this._organiseData(e[r], !1);
                    return this._max = t.max, this._min = t.min || 0, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                }
            }, {
                key: "removeData",
                value: function () {}
            }, {
                key: "setDataMax",
                value: function (t) {
                    return this._max = t, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                }
            }, {
                key: "setDataMin",
                value: function (t) {
                    return this._min = t, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                }
            }, {
                key: "setCoordinator",
                value: function (t) {
                    this._coordinator = t
                }
            }, {
                key: "_getInternalData",
                value: function () {
                    return {
                        max: this._max,
                        min: this._min,
                        data: this._data,
                        radi: this._radi
                    }
                }
            }, {
                key: "getData",
                value: function () {
                    return this._unOrganizeData()
                }
            }]), t
        }();
    e.default = u
}]);